(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.CloudFileManager = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],2:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":1,"ieee754":18,"isarray":19}],3:[function(require,module,exports){
/*istanbul ignore start*/"use strict";

exports.__esModule = true;
exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
  for (var i = 0; i < changes.length; i++) {
    change = changes[i];
    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }
  return ret;
}


},{}],4:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
function convertChangesToXML(changes) {
  var ret = [];
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }
  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');

  return n;
}


},{}],5:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.default = /*istanbul ignore end*/Diff;
function Diff() {}

Diff.prototype = { /*istanbul ignore start*/
  /*istanbul ignore end*/diff: function diff(oldString, newString) {
    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var callback = options.callback;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    this.options = options;

    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }

    // Allow subclasses to massage the input prior to running
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);

    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));

    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{ newPos: -1, components: [] }];

    // Seed editLength = 0, i.e. the content starts with the same values
    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{ value: newString.join(''), count: newString.length }]);
    }

    // Main worker method. checks all permutations of a given edit length for acceptance.
    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        }

        // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list
          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

        // If we have hit the end of both strings, then we are done
        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    }

    // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.
    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.
          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];
    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
    } else {
      components.push({ count: 1, added: added, removed: removed });
    }
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({ count: commonCount });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
    return left === right;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
    return value;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
    return value.split('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });

        component.value = value.join('');
      } else {
        component.value = newString.slice(newPos, newPos + component.count).join('');
      }
      newPos += component.count;

      // Common case
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = oldString.slice(oldPos, oldPos + component.count).join('');
      oldPos += component.count;

      // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }

  // Special case handle for when one terminal is ignored. For this case we merge the
  // terminal into the prior string and drop the change.
  var lastComponent = components[componentLen - 1];
  if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return { newPos: path.newPos, components: path.components.slice(0) };
}


},{}],6:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.characterDiff = undefined;
exports. /*istanbul ignore end*/diffChars = diffChars;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
function diffChars(oldStr, newStr, callback) {
  return characterDiff.diff(oldStr, newStr, callback);
}


},{"./base":5}],7:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.cssDiff = undefined;
exports. /*istanbul ignore end*/diffCss = diffCss;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}


},{"./base":5}],8:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.jsonDiff = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports. /*istanbul ignore end*/diffJson = diffJson;
/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_line = require('./line') /*istanbul ignore end*/;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/

var objectPrototypeToString = Object.prototype.toString;

var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
jsonDiff.useLongestToken = true;

jsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff. /*istanbul ignore end*/tokenize;
jsonDiff.castInput = function (value) {
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), undefined, '  ');
};
jsonDiff.equals = function (left, right) {
  return (/*istanbul ignore start*/_base2.default. /*istanbul ignore end*/prototype.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  );
};

function diffJson(oldObj, newObj, callback) {
  return jsonDiff.diff(oldObj, newObj, callback);
}

// This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed.
function canonicalize(obj, stack, replacementStack) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
    for (key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(key)) {
        sortedKeys.push(key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      key = sortedKeys[i];
      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}


},{"./base":5,"./line":9}],9:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.lineDiff = undefined;
exports. /*istanbul ignore end*/diffLines = diffLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/);

  // Ignore the final empty token that occurs if the string ends with a new line
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }

  // Merge the content and line separators into single tokens
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
  return lineDiff.diff(oldStr, newStr, options);
}


},{"../util/params":17,"./base":5}],10:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.sentenceDiff = undefined;
exports. /*istanbul ignore end*/diffSentences = diffSentences;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}


},{"./base":5}],11:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.wordDiff = undefined;
exports. /*istanbul ignore end*/diffWords = diffWords;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;

var /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/

// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

var reWhitespace = /\S/;

var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2.default() /*istanbul ignore end*/;
wordDiff.equals = function (left, right) {
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function (value) {
  var tokens = value.split(/(\s+|\b)/);

  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, callback) {
  return wordDiff.diff(oldStr, newStr, callback);
}


},{"../util/params":17,"./base":5}],12:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;
/*istanbul ignore end*/
var /*istanbul ignore start*/_base = require('./diff/base') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_character = require('./diff/character') /*istanbul ignore end*/;

var /*istanbul ignore start*/_word = require('./diff/word') /*istanbul ignore end*/;

var /*istanbul ignore start*/_line = require('./diff/line') /*istanbul ignore end*/;

var /*istanbul ignore start*/_sentence = require('./diff/sentence') /*istanbul ignore end*/;

var /*istanbul ignore start*/_css = require('./diff/css') /*istanbul ignore end*/;

var /*istanbul ignore start*/_json = require('./diff/json') /*istanbul ignore end*/;

var /*istanbul ignore start*/_apply = require('./patch/apply') /*istanbul ignore end*/;

var /*istanbul ignore start*/_parse = require('./patch/parse') /*istanbul ignore end*/;

var /*istanbul ignore start*/_create = require('./patch/create') /*istanbul ignore end*/;

var /*istanbul ignore start*/_dmp = require('./convert/dmp') /*istanbul ignore end*/;

var /*istanbul ignore start*/_xml = require('./convert/xml') /*istanbul ignore end*/;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
exports. /*istanbul ignore end*/Diff = _base2.default;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;
/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;
/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;
/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;
/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;


},{"./convert/dmp":3,"./convert/xml":4,"./diff/base":5,"./diff/character":6,"./diff/css":7,"./diff/json":8,"./diff/line":9,"./diff/sentence":10,"./diff/word":11,"./patch/apply":13,"./patch/create":14,"./patch/parse":15}],13:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/applyPatch = applyPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;

var /*istanbul ignore start*/_parse = require('./parse') /*istanbul ignore end*/;

var /*istanbul ignore start*/_distanceIterator = require('../util/distance-iterator') /*istanbul ignore end*/;

/*istanbul ignore start*/
var _distanceIterator2 = _interopRequireDefault(_distanceIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/function applyPatch(source, uniDiff) {
  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  if (typeof uniDiff === 'string') {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  }

  // Apply the diff to the input
  var lines = source.split('\n'),
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
    return (/*istanbul ignore end*/line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  /**
   * Checks if the hunk exactly fits on the provided location
   */
  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line[0],
          content = line.substr(1);

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }
        toPos++;
      }
    }

    return true;
  }

  // Search best fit offsets for each hunk based on the previous ones
  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;

    var iterator = /*istanbul ignore start*/(0, _distanceIterator2.default) /*istanbul ignore end*/(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    }

    // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text
    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  }

  // Apply patch hunks
  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.offset + _hunk.newStart - 1;
    if (_hunk.newLines == 0) {
      _toPos++;
    }

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line[0],
          content = line.substr(1);

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
    }
  }

  // Handle EOFNL insertion/removal
  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
  }
  return lines.join('\n');
}

// Wrapper that supports multiple file patches via callbacks.
function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  var currentIndex = 0;
  function processIndex() {
    var index = uniDiff[currentIndex++];
    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent);

      setTimeout(processIndex, 0);
    });
  }
  processIndex();
}


},{"../util/distance-iterator":16,"./parse":15}],14:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;

var /*istanbul ignore start*/_line = require('../diff/line') /*istanbul ignore end*/;

/*istanbul ignore start*/
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = { context: 4 };
  }

  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr);
  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;
  /*istanbul ignore start*/
  var _loop = function _loop( /*istanbul ignore end*/i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }

      // Output our changes
      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      })));

      // Track the updated file position
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping
          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);
          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            if (lines.length == 0 && !oldEOFNewline) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            } else if (!oldEOFNewline || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }
          hunks.push(hunk);

          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }
      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    /*istanbul ignore start*/
    _loop( /*istanbul ignore end*/i);
  }

  return {
    oldFileName: oldFileName, newFileName: newFileName,
    oldHeader: oldHeader, newHeader: newHeader,
    hunks: hunks
  };
}

function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

  var ret = [];
  if (oldFileName == newFileName) {
    ret.push('Index: ' + oldFileName);
  }
  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}

function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}


},{"../diff/line":9}],15:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/parsePatch = parsePatch;
function parsePatch(uniDiff) {
  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var diffstr = uniDiff.split('\n'),
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index);

    // Parse diff metadata
    while (i < diffstr.length) {
      var line = diffstr[i];

      // File header found, end parsing diff metadata
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      }

      // Diff index
      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) {
        index.index = header[1];
      }

      i++;
    }

    // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header
    parseFileHeader(index);
    parseFileHeader(index);

    // Parse hunks
    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  }

  // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.
  function parseFileHeader(index) {
    var fileHeader = /^(\-\-\-|\+\+\+)\s+(\S*)\s?(.*?)\s*$/.exec(diffstr[i]);
    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      index[keyPrefix + 'FileName'] = fileHeader[2];
      index[keyPrefix + 'Header'] = fileHeader[3];

      i++;
    }
  }

  // Parses a hunk
  // This assumes that we are at the start of a hunk.
  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: +chunkHeader[2] || 1,
      newStart: +chunkHeader[3],
      newLines: +chunkHeader[4] || 1,
      lines: []
    };

    var addCount = 0,
        removeCount = 0;
    for (; i < diffstr.length; i++) {
      var operation = diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    }

    // Handle the empty block count case
    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }

    // Perform optional sanity checking
    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}


},{}],16:[function(require,module,exports){
/*istanbul ignore start*/"use strict";

exports.__esModule = true;

exports.default = /*istanbul ignore end*/function (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;

  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      }

      // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)
      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      }

      // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location
      if (minLine <= start - localOffset) {
        return - localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    }

    // We tried to fit hunk before text beginning and beyond text lenght, then
    // hunk can't fit on the text. Return undefined
  };
};


},{}],17:[function(require,module,exports){
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/generateOptions = generateOptions;
function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }
  return defaults;
}


},{}],18:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],19:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],20:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var lcs = require('./lib/lcs');
var array = require('./lib/array');
var patch = require('./lib/jsonPatch');
var inverse = require('./lib/inverse');
var jsonPointer = require('./lib/jsonPointer');
var encodeSegment = jsonPointer.encodeSegment;

exports.diff = diff;
exports.patch = patch.apply;
exports.patchInPlace = patch.applyInPlace;
exports.inverse = inverse;
exports.clone = patch.clone;

// Errors
exports.InvalidPatchOperationError = require('./lib/InvalidPatchOperationError');
exports.TestFailedError = require('./lib/TestFailedError');
exports.PatchNotInvertibleError = require('./lib/PatchNotInvertibleError');

var isValidObject = patch.isValidObject;
var defaultHash = patch.defaultHash;

/**
 * Compute a JSON Patch representing the differences between a and b.
 * @param {object|array|string|number|null} a
 * @param {object|array|string|number|null} b
 * @param {?function|?object} options if a function, see options.hash
 * @param {?function(x:*):String|Number} options.hash used to hash array items
 *  in order to recognize identical objects, defaults to JSON.stringify
 * @param {?function(index:Number, array:Array):object} options.makeContext
 *  used to generate patch context. If not provided, context will not be generated
 * @returns {array} JSON Patch such that patch(diff(a, b), a) ~ b
 */
function diff(a, b, options) {
	return appendChanges(a, b, '', initState(options, [])).patch;
}

/**
 * Create initial diff state from the provided options
 * @param {?function|?object} options @see diff options above
 * @param {array} patch an empty or existing JSON Patch array into which
 *  the diff should generate new patch operations
 * @returns {object} initialized diff state
 */
function initState(options, patch) {
	if(typeof options === 'object') {
		return {
			patch: patch,
			hash: orElse(isFunction, options.hash, defaultHash),
			makeContext: orElse(isFunction, options.makeContext, defaultContext),
			invertible: !(options.invertible === false)
		};
	} else {
		return {
			patch: patch,
			hash: orElse(isFunction, options, defaultHash),
			makeContext: defaultContext,
			invertible: true
		};
	}
}

/**
 * Given two JSON values (object, array, number, string, etc.), find their
 * differences and append them to the diff state
 * @param {object|array|string|number|null} a
 * @param {object|array|string|number|null} b
 * @param {string} path
 * @param {object} state
 * @returns {Object} updated diff state
 */
function appendChanges(a, b, path, state) {
	if(Array.isArray(a) && Array.isArray(b)) {
		return appendArrayChanges(a, b, path, state);
	}

	if(isValidObject(a) && isValidObject(b)) {
		return appendObjectChanges(a, b, path, state);
	}

	return appendValueChanges(a, b, path, state);
}

/**
 * Given two objects, find their differences and append them to the diff state
 * @param {object} o1
 * @param {object} o2
 * @param {string} path
 * @param {object} state
 * @returns {Object} updated diff state
 */
function appendObjectChanges(o1, o2, path, state) {
	var keys = Object.keys(o2);
	var patch = state.patch;
	var i, key;

	for(i=keys.length-1; i>=0; --i) {
		key = keys[i];
		var keyPath = path + '/' + encodeSegment(key);
		if(o1[key] !== void 0) {
			appendChanges(o1[key], o2[key], keyPath, state);
		} else {
			patch.push({ op: 'add', path: keyPath, value: o2[key] });
		}
	}

	keys = Object.keys(o1);
	for(i=keys.length-1; i>=0; --i) {
		key = keys[i];
		if(o2[key] === void 0) {
			var p = path + '/' + encodeSegment(key);
			if(state.invertible) {
				patch.push({ op: 'test', path: p, value: o1[key] });
			}
			patch.push({ op: 'remove', path: p });
		}
	}

	return state;
}

/**
 * Given two arrays, find their differences and append them to the diff state
 * @param {array} a1
 * @param {array} a2
 * @param {string} path
 * @param {object} state
 * @returns {Object} updated diff state
 */
function appendArrayChanges(a1, a2, path, state) {
	var a1hash = array.map(state.hash, a1);
	var a2hash = array.map(state.hash, a2);

	var lcsMatrix = lcs.compare(a1hash, a2hash);

	return lcsToJsonPatch(a1, a2, path, state, lcsMatrix);
}

/**
 * Transform an lcsMatrix into JSON Patch operations and append
 * them to state.patch, recursing into array elements as necessary
 * @param {array} a1
 * @param {array} a2
 * @param {string} path
 * @param {object} state
 * @param {object} lcsMatrix
 * @returns {object} new state with JSON Patch operations added based
 *  on the provided lcsMatrix
 */
function lcsToJsonPatch(a1, a2, path, state, lcsMatrix) {
	var offset = 0;
	return lcs.reduce(function(state, op, i, j) {
		var last, context;
		var patch = state.patch;
		var p = path + '/' + (j + offset);

		if (op === lcs.REMOVE) {
			// Coalesce adjacent remove + add into replace
			last = patch[patch.length-1];
			context = state.makeContext(j, a1);

			if(state.invertible) {
				patch.push({ op: 'test', path: p, value: a1[j], context: context });
			}

			if(last !== void 0 && last.op === 'add' && last.path === p) {
				last.op = 'replace';
				last.context = context;
			} else {
				patch.push({ op: 'remove', path: p, context: context });
			}

			offset -= 1;

		} else if (op === lcs.ADD) {
			// See https://tools.ietf.org/html/rfc6902#section-4.1
			// May use either index===length *or* '-' to indicate appending to array
			patch.push({ op: 'add', path: p, value: a2[i],
				context: state.makeContext(j, a1)
			});

			offset += 1;

		} else {
			appendChanges(a1[j], a2[i], p, state);
		}

		return state;

	}, state, lcsMatrix);
}

/**
 * Given two number|string|null values, if they differ, append to diff state
 * @param {string|number|null} a
 * @param {string|number|null} b
 * @param {string} path
 * @param {object} state
 * @returns {object} updated diff state
 */
function appendValueChanges(a, b, path, state) {
	if(a !== b) {
		if(state.invertible) {
			state.patch.push({ op: 'test', path: path, value: a });
		}

		state.patch.push({ op: 'replace', path: path, value: b });
	}

	return state;
}

/**
 * @param {function} predicate
 * @param {*} x
 * @param {*} y
 * @returns {*} x if predicate(x) is truthy, otherwise y
 */
function orElse(predicate, x, y) {
	return predicate(x) ? x : y;
}

/**
 * Default patch context generator
 * @returns {undefined} undefined context
 */
function defaultContext() {
	return void 0;
}

/**
 * @param {*} x
 * @returns {boolean} true if x is a function, false otherwise
 */
function isFunction(x) {
	return typeof x === 'function';
}

},{"./lib/InvalidPatchOperationError":21,"./lib/PatchNotInvertibleError":22,"./lib/TestFailedError":23,"./lib/array":24,"./lib/inverse":28,"./lib/jsonPatch":29,"./lib/jsonPointer":30,"./lib/lcs":32}],21:[function(require,module,exports){
module.exports = InvalidPatchOperationError;

function InvalidPatchOperationError(message) {
	Error.call(this);
	this.name = this.constructor.name;
	this.message = message;
	if(typeof Error.captureStackTrace === 'function') {
		Error.captureStackTrace(this, this.constructor);
	}
}

InvalidPatchOperationError.prototype = Object.create(Error.prototype);
InvalidPatchOperationError.prototype.constructor = InvalidPatchOperationError;
},{}],22:[function(require,module,exports){
module.exports = PatchNotInvertibleError;

function PatchNotInvertibleError(message) {
	Error.call(this);
	this.name = this.constructor.name;
	this.message = message;
	if(typeof Error.captureStackTrace === 'function') {
		Error.captureStackTrace(this, this.constructor);
	}
}

PatchNotInvertibleError.prototype = Object.create(Error.prototype);
PatchNotInvertibleError.prototype.constructor = PatchNotInvertibleError;
},{}],23:[function(require,module,exports){
module.exports = TestFailedError;

function TestFailedError(message) {
	Error.call(this);
	this.name = this.constructor.name;
	this.message = message;
	if(typeof Error.captureStackTrace === 'function') {
		Error.captureStackTrace(this, this.constructor);
	}
}

TestFailedError.prototype = Object.create(Error.prototype);
TestFailedError.prototype.constructor = TestFailedError;
},{}],24:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

exports.cons = cons;
exports.tail = tail;
exports.map = map;

/**
 * Prepend x to a, without mutating a. Faster than a.unshift(x)
 * @param {*} x
 * @param {Array} a array-like
 * @returns {Array} new Array with x prepended
 */
function cons(x, a) {
	var l = a.length;
	var b = new Array(l+1);
	b[0] = x;
	for(var i=0; i<l; ++i) {
		b[i+1] = a[i];
	}

	return b;
}

/**
 * Create a new Array containing all elements in a, except the first.
 *  Faster than a.slice(1)
 * @param {Array} a array-like
 * @returns {Array} new Array, the equivalent of a.slice(1)
 */
function tail(a) {
	var l = a.length-1;
	var b = new Array(l);
	for(var i=0; i<l; ++i) {
		b[i] = a[i+1];
	}

	return b;
}

/**
 * Map any array-like. Faster than Array.prototype.map
 * @param {function} f
 * @param {Array} a array-like
 * @returns {Array} new Array mapped by f
 */
function map(f, a) {
	var b = new Array(a.length);
	for(var i=0; i< a.length; ++i) {
		b[i] = f(a[i]);
	}
	return b;
}
},{}],25:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a deep copy of x which must be a legal JSON object/array/value
 * @param {object|array|string|number|null} x object/array/value to clone
 * @returns {object|array|string|number|null} clone of x
 */
module.exports = clone;

function clone(x) {
	if(x == null || typeof x !== 'object') {
		return x;
	}

	if(Array.isArray(x)) {
		return cloneArray(x);
	}

	return cloneObject(x);
}

function cloneArray (x) {
	var l = x.length;
	var y = new Array(l);

	for (var i = 0; i < l; ++i) {
		y[i] = clone(x[i]);
	}

	return y;
}

function cloneObject (x) {
	var keys = Object.keys(x);
	var y = {};

	for (var k, i = 0, l = keys.length; i < l; ++i) {
		k = keys[i];
		y[k] = clone(x[k]);
	}

	return y;
}

},{}],26:[function(require,module,exports){
var jsonPointer = require('./jsonPointer');

/**
 * commute the patch sequence a,b to b,a
 * @param {object} a patch operation
 * @param {object} b patch operation
 */
module.exports = function commutePaths(a, b) {
	// TODO: cases for special paths: '' and '/'
	var left = jsonPointer.parse(a.path);
	var right = jsonPointer.parse(b.path);
	var prefix = getCommonPathPrefix(left, right);
	var isArray = isArrayPath(left, right, prefix.length);

	// Never mutate the originals
	var ac = copyPatch(a);
	var bc = copyPatch(b);

	if(prefix.length === 0 && !isArray) {
		// Paths share no common ancestor, simple swap
		return [bc, ac];
	}

	if(isArray) {
		return commuteArrayPaths(ac, left, bc, right);
	} else {
		return commuteTreePaths(ac, left, bc, right);
	}
};

function commuteTreePaths(a, left, b, right) {
	if(a.path === b.path) {
		throw new TypeError('cannot commute ' + a.op + ',' + b.op + ' with identical object paths');
	}
	// FIXME: Implement tree path commutation
	return [b, a];
}

/**
 * Commute two patches whose common ancestor (which may be the immediate parent)
 * is an array
 * @param a
 * @param left
 * @param b
 * @param right
 * @returns {*}
 */
function commuteArrayPaths(a, left, b, right) {
	if(left.length === right.length) {
		return commuteArraySiblings(a, left, b, right);
	}

	if (left.length > right.length) {
		// left is longer, commute by "moving" it to the right
		left = commuteArrayAncestor(b, right, a, left, -1);
		a.path = jsonPointer.absolute(jsonPointer.join(left));
	} else {
		// right is longer, commute by "moving" it to the left
		right = commuteArrayAncestor(a, left, b, right, 1);
		b.path = jsonPointer.absolute(jsonPointer.join(right));
	}

	return [b, a];
}

function isArrayPath(left, right, index) {
	return jsonPointer.isValidArrayIndex(left[index])
		&& jsonPointer.isValidArrayIndex(right[index]);
}

/**
 * Commute two patches referring to items in the same array
 * @param l
 * @param lpath
 * @param r
 * @param rpath
 * @returns {*[]}
 */
function commuteArraySiblings(l, lpath, r, rpath) {

	var target = lpath.length-1;
	var lindex = +lpath[target];
	var rindex = +rpath[target];

	var commuted;

	if(lindex < rindex) {
		// Adjust right path
		if(l.op === 'add' || l.op === 'copy') {
			commuted = rpath.slice();
			commuted[target] = Math.max(0, rindex - 1);
			r.path = jsonPointer.absolute(jsonPointer.join(commuted));
		} else if(l.op === 'remove') {
			commuted = rpath.slice();
			commuted[target] = rindex + 1;
			r.path = jsonPointer.absolute(jsonPointer.join(commuted));
		}
	} else if(r.op === 'add' || r.op === 'copy') {
		// Adjust left path
		commuted = lpath.slice();
		commuted[target] = lindex + 1;
		l.path = jsonPointer.absolute(jsonPointer.join(commuted));
	} else if (lindex > rindex && r.op === 'remove') {
		// Adjust left path only if remove was at a (strictly) lower index
		commuted = lpath.slice();
		commuted[target] = Math.max(0, lindex - 1);
		l.path = jsonPointer.absolute(jsonPointer.join(commuted));
	}

	return [r, l];
}

/**
 * Commute two patches with a common array ancestor
 * @param l
 * @param lpath
 * @param r
 * @param rpath
 * @param direction
 * @returns {*}
 */
function commuteArrayAncestor(l, lpath, r, rpath, direction) {
	// rpath is longer or same length

	var target = lpath.length-1;
	var lindex = +lpath[target];
	var rindex = +rpath[target];

	// Copy rpath, then adjust its array index
	var rc = rpath.slice();

	if(lindex > rindex) {
		return rc;
	}

	if(l.op === 'add' || l.op === 'copy') {
		rc[target] = Math.max(0, rindex - direction);
	} else if(l.op === 'remove') {
		rc[target] = Math.max(0, rindex + direction);
	}

	return rc;
}

function getCommonPathPrefix(p1, p2) {
	var p1l = p1.length;
	var p2l = p2.length;
	if(p1l === 0 || p2l === 0 || (p1l < 2 && p2l < 2)) {
		return [];
	}

	// If paths are same length, the last segment cannot be part
	// of a common prefix.  If not the same length, the prefix cannot
	// be longer than the shorter path.
	var l = p1l === p2l
		? p1l - 1
		: Math.min(p1l, p2l);

	var i = 0;
	while(i < l && p1[i] === p2[i]) {
		++i
	}

	return p1.slice(0, i);
}

function copyPatch(p) {
	if(p.op === 'remove') {
		return { op: p.op, path: p.path };
	}

	if(p.op === 'copy' || p.op === 'move') {
		return { op: p.op, path: p.path, from: p.from };
	}

	// test, add, replace
	return { op: p.op, path: p.path, value: p.value };
}
},{"./jsonPointer":30}],27:[function(require,module,exports){
module.exports = deepEquals;

/**
 * Compare 2 JSON values, or recursively compare 2 JSON objects or arrays
 * @param {object|array|string|number|boolean|null} a
 * @param {object|array|string|number|boolean|null} b
 * @returns {boolean} true iff a and b are recursively equal
 */
function deepEquals(a, b) {
	if(a === b) {
		return true;
	}

	if(Array.isArray(a) && Array.isArray(b)) {
		return compareArrays(a, b);
	}

	if(typeof a === 'object' && typeof b === 'object') {
		return compareObjects(a, b);
	}

	return false;
}

function compareArrays(a, b) {
	if(a.length !== b.length) {
		return false;
	}

	for(var i = 0; i<a.length; ++i) {
		if(!deepEquals(a[i], b[i])) {
			return false;
		}
	}

	return true;
}

function compareObjects(a, b) {
	if((a === null && b !== null) || (a !== null && b === null)) {
		return false;
	}

	var akeys = Object.keys(a);
	var bkeys = Object.keys(b);

	if(akeys.length !== bkeys.length) {
		return false;
	}

	for(var i = 0, k; i<akeys.length; ++i) {
		k = akeys[i];
		if(!(k in b && deepEquals(a[k], b[k]))) {
			return false;
		}
	}

	return true;
}
},{}],28:[function(require,module,exports){
var patches = require('./patches');

module.exports = function inverse(p) {
	var pr = [];
	var i, skip;
	for(i = p.length-1; i>= 0; i -= skip) {
		skip = invertOp(pr, p[i], i, p);
	}

	return pr;
};

function invertOp(patch, c, i, context) {
	var op = patches[c.op];
	return op !== void 0 && typeof op.inverse === 'function'
		? op.inverse(patch, c, i, context)
		: 1;
}

},{"./patches":33}],29:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var patches = require('./patches');
var clone = require('./clone');
var InvalidPatchOperationError = require('./InvalidPatchOperationError');

exports.apply = patch;
exports.applyInPlace = patchInPlace;
exports.clone = clone;
exports.isValidObject = isValidObject;
exports.defaultHash = defaultHash;

var defaultOptions = {};

/**
 * Apply the supplied JSON Patch to x
 * @param {array} changes JSON Patch
 * @param {object|array|string|number} x object/array/value to patch
 * @param {object} options
 * @param {function(index:Number, array:Array, context:object):Number} options.findContext
 *  function used adjust array indexes for smarty/fuzzy patching, for
 *  patches containing context
 * @returns {object|array|string|number} patched version of x. If x is
 *  an array or object, it will be mutated and returned. Otherwise, if
 *  x is a value, the new value will be returned.
 */
function patch(changes, x, options) {
	return patchInPlace(changes, clone(x), options);
}

function patchInPlace(changes, x, options) {
	if(!options) {
		options = defaultOptions;
	}

	// TODO: Consider throwing if changes is not an array
	if(!Array.isArray(changes)) {
		return x;
	}

	var patch, p;
	for(var i=0; i<changes.length; ++i) {
		p = changes[i];
		patch = patches[p.op];

		if(patch === void 0) {
			throw new InvalidPatchOperationError('invalid op ' + JSON.stringify(p));
		}

		x = patch.apply(x, p, options);
	}

	return x;
}

function defaultHash(x) {
	return isValidObject(x) || isArray(x) ? JSON.stringify(x) : x;
}

function isValidObject (x) {
	return x !== null && Object.prototype.toString.call(x) === '[object Object]';
}

function isArray (x) {
	return Object.prototype.toString.call(x) === '[object Array]';
}

},{"./InvalidPatchOperationError":21,"./clone":25,"./patches":33}],30:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var _parse = require('./jsonPointerParse');

exports.find = find;
exports.join = join;
exports.absolute = absolute;
exports.parse = parse;
exports.contains = contains;
exports.encodeSegment = encodeSegment;
exports.decodeSegment = decodeSegment;
exports.parseArrayIndex = parseArrayIndex;
exports.isValidArrayIndex = isValidArrayIndex;

// http://tools.ietf.org/html/rfc6901#page-2
var separator = '/';
var separatorRx = /\//g;
var encodedSeparator = '~1';
var encodedSeparatorRx = /~1/g;

var escapeChar = '~';
var escapeRx = /~/g;
var encodedEscape = '~0';
var encodedEscapeRx = /~0/g;

/**
 * Find the parent of the specified path in x and return a descriptor
 * containing the parent and a key.  If the parent does not exist in x,
 * return undefined, instead.
 * @param {object|array} x object or array in which to search
 * @param {string} path JSON Pointer string (encoded)
 * @param {?function(index:Number, array:Array, context:object):Number} findContext
 *  optional function used adjust array indexes for smarty/fuzzy patching, for
 *  patches containing context.  If provided, context MUST also be provided.
 * @param {?{before:Array, after:Array}} context optional patch context for
 *  findContext to use to adjust array indices.  If provided, findContext MUST
 *  also be provided.
 * @returns {{target:object|array|number|string, key:string}|undefined}
 */
function find(x, path, findContext, context) {
	if(typeof path !== 'string') {
		return;
	}

	if(path === '') {
		// whole document
		return { target: x, key: void 0 };
	}

	if(path === separator) {
		return { target: x, key: '' };
	}

	var parent = x, key;
	var hasContext = context !== void 0;

	_parse(path, function(segment) {
		// hm... this seems like it should be if(typeof x === 'undefined')
		if(x == null) {
			// Signal that we prematurely hit the end of the path hierarchy.
			parent = null;
			return false;
		}

		if(Array.isArray(x)) {
			key = hasContext
				? findIndex(findContext, parseArrayIndex(segment), x, context)
				: segment === '-' ? segment : parseArrayIndex(segment);
		} else {
			key = segment;
		}

		parent = x;
		x = x[key];
	});

	return parent === null
		? void 0
		: { target: parent, key: key };
}

function absolute(path) {
	return path[0] === separator ? path : separator + path;
}

function join(segments) {
	return segments.join(separator);
}

function parse(path) {
	var segments = [];
	_parse(path, segments.push.bind(segments));
	return segments;
}

function contains(a, b) {
	return b.indexOf(a) === 0 && b[a.length] === separator;
}

/**
 * Decode a JSON Pointer path segment
 * @see http://tools.ietf.org/html/rfc6901#page-3
 * @param {string} s encoded segment
 * @returns {string} decoded segment
 */
function decodeSegment(s) {
	// See: http://tools.ietf.org/html/rfc6901#page-3
	return s.replace(encodedSeparatorRx, separator).replace(encodedEscapeRx, escapeChar);
}

/**
 * Encode a JSON Pointer path segment
 * @see http://tools.ietf.org/html/rfc6901#page-3
 * @param {string} s decoded segment
 * @returns {string} encoded segment
 */
function encodeSegment(s) {
	return s.replace(escapeRx, encodedEscape).replace(separatorRx, encodedSeparator);
}

var arrayIndexRx = /^(0|[1-9]\d*)$/;

/**
 * Return true if s is a valid JSON Pointer array index
 * @param {String} s
 * @returns {boolean}
 */
function isValidArrayIndex(s) {
	return arrayIndexRx.test(s);
}

/**
 * Safely parse a string into a number >= 0. Does not check for decimal numbers
 * @param {string} s numeric string
 * @returns {number} number >= 0
 */
function parseArrayIndex (s) {
	if(isValidArrayIndex(s)) {
		return +s;
	}

	throw new SyntaxError('invalid array index ' + s);
}

function findIndex (findContext, start, array, context) {
	var index = start;

	if(index < 0) {
		throw new Error('array index out of bounds ' + index);
	}

	if(context !== void 0 && typeof findContext === 'function') {
		index = findContext(start, array, context);
		if(index < 0) {
			throw new Error('could not find patch context ' + context);
		}
	}

	return index;
}
},{"./jsonPointerParse":31}],31:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

module.exports = jsonPointerParse;

var parseRx = /\/|~1|~0/g;
var separator = '/';
var escapeChar = '~';
var encodedSeparator = '~1';

/**
 * Parse through an encoded JSON Pointer string, decoding each path segment
 * and passing it to an onSegment callback function.
 * @see https://tools.ietf.org/html/rfc6901#section-4
 * @param {string} path encoded JSON Pointer string
 * @param {{function(segment:string):boolean}} onSegment callback function
 * @returns {string} original path
 */
function jsonPointerParse(path, onSegment) {
	var pos, accum, matches, match;

	pos = path.charAt(0) === separator ? 1 : 0;
	accum = '';
	parseRx.lastIndex = pos;

	while(matches = parseRx.exec(path)) {

		match = matches[0];
		accum += path.slice(pos, parseRx.lastIndex - match.length);
		pos = parseRx.lastIndex;

		if(match === separator) {
			if (onSegment(accum) === false) return path;
			accum = '';
		} else {
			accum += match === encodedSeparator ? separator : escapeChar;
		}
	}

	accum += path.slice(pos);
	onSegment(accum);

	return path;
}

},{}],32:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

exports.compare = compare;
exports.reduce = reduce;

var REMOVE, RIGHT, ADD, DOWN, SKIP;

exports.REMOVE = REMOVE = RIGHT = -1;
exports.ADD    = ADD    = DOWN  =  1;
exports.EQUAL  = SKIP   = 0;

/**
 * Create an lcs comparison matrix describing the differences
 * between two array-like sequences
 * @param {array} a array-like
 * @param {array} b array-like
 * @returns {object} lcs descriptor, suitable for passing to reduce()
 */
function compare(a, b) {
	var cols = a.length;
	var rows = b.length;

	var prefix = findPrefix(a, b);
	var suffix = prefix < cols && prefix < rows
		? findSuffix(a, b, prefix)
		: 0;

	var remove = suffix + prefix - 1;
	cols -= remove;
	rows -= remove;
	var matrix = createMatrix(cols, rows);

	for (var j = cols - 1; j >= 0; --j) {
		for (var i = rows - 1; i >= 0; --i) {
			matrix[i][j] = backtrack(matrix, a, b, prefix, j, i);
		}
	}

	return {
		prefix: prefix,
		matrix: matrix,
		suffix: suffix
	};
}

/**
 * Reduce a set of lcs changes previously created using compare
 * @param {function(result:*, type:number, i:number, j:number)} f
 *  reducer function, where:
 *  - result is the current reduce value,
 *  - type is the type of change: ADD, REMOVE, or SKIP
 *  - i is the index of the change location in b
 *  - j is the index of the change location in a
 * @param {*} r initial value
 * @param {object} lcs results returned by compare()
 * @returns {*} the final reduced value
 */
function reduce(f, r, lcs) {
	var i, j, k, op;

	var m = lcs.matrix;

	// Reduce shared prefix
	var l = lcs.prefix;
	for(i = 0;i < l; ++i) {
		r = f(r, SKIP, i, i);
	}

	// Reduce longest change span
	k = i;
	l = m.length;
	i = 0;
	j = 0;
	while(i < l) {
		op = m[i][j].type;
		r = f(r, op, i+k, j+k);

		switch(op) {
			case SKIP:  ++i; ++j; break;
			case RIGHT: ++j; break;
			case DOWN:  ++i; break;
		}
	}

	// Reduce shared suffix
	i += k;
	j += k;
	l = lcs.suffix;
	for(k = 0;k < l; ++k) {
		r = f(r, SKIP, i+k, j+k);
	}

	return r;
}

function findPrefix(a, b) {
	var i = 0;
	var l = Math.min(a.length, b.length);
	while(i < l && a[i] === b[i]) {
		++i;
	}
	return i;
}

function findSuffix(a, b) {
	var al = a.length - 1;
	var bl = b.length - 1;
	var l = Math.min(al, bl);
	var i = 0;
	while(i < l && a[al-i] === b[bl-i]) {
		++i;
	}
	return i;
}

function backtrack(matrix, a, b, start, j, i) {
	if (a[j+start] === b[i+start]) {
		return { value: matrix[i + 1][j + 1].value, type: SKIP };
	}
	if (matrix[i][j + 1].value < matrix[i + 1][j].value) {
		return { value: matrix[i][j + 1].value + 1, type: RIGHT };
	}

	return { value: matrix[i + 1][j].value + 1, type: DOWN };
}

function createMatrix (cols, rows) {
	var m = [], i, j, lastrow;

	// Fill the last row
	lastrow = m[rows] = [];
	for (j = 0; j<cols; ++j) {
		lastrow[j] = { value: cols - j, type: RIGHT };
	}

	// Fill the last col
	for (i = 0; i<rows; ++i) {
		m[i] = [];
		m[i][cols] = { value: rows - i, type: DOWN };
	}

	// Fill the last cell
	m[rows][cols] = { value: 0, type: SKIP };

	return m;
}

},{}],33:[function(require,module,exports){
var jsonPointer = require('./jsonPointer');
var clone = require('./clone');
var deepEquals = require('./deepEquals');
var commutePaths = require('./commutePaths');

var array = require('./array');

var TestFailedError = require('./TestFailedError');
var InvalidPatchOperationError = require('./InvalidPatchOperationError');
var PatchNotInvertibleError = require('./PatchNotInvertibleError');

var find = jsonPointer.find;
var parseArrayIndex = jsonPointer.parseArrayIndex;

exports.test = {
	apply: applyTest,
	inverse: invertTest,
	commute: commuteTest
};

exports.add = {
	apply: applyAdd,
	inverse: invertAdd,
	commute: commuteAddOrCopy
};

exports.remove = {
	apply: applyRemove,
	inverse: invertRemove,
	commute: commuteRemove
};

exports.replace = {
	apply: applyReplace,
	inverse: invertReplace,
	commute: commuteReplace
};

exports.move = {
	apply: applyMove,
	inverse: invertMove,
	commute: commuteMove
};

exports.copy = {
	apply: applyCopy,
	inverse: notInvertible,
	commute: commuteAddOrCopy
};

/**
 * Apply a test operation to x
 * @param {object|array} x
 * @param {object} test test operation
 * @throws {TestFailedError} if the test operation fails
 */

function applyTest(x, test, options) {
	var pointer = find(x, test.path, options.findContext, test.context);
	var target = pointer.target;
	var index, value;

	if(Array.isArray(target)) {
		index = parseArrayIndex(pointer.key);
		//index = findIndex(options.findContext, index, target, test.context);
		value = target[index];
	} else {
		value = pointer.key === void 0 ? pointer.target : pointer.target[pointer.key];
	}

	if(!deepEquals(value, test.value)) {
		throw new TestFailedError('test failed ' + JSON.stringify(test));
	}

	return x;
}

/**
 * Invert the provided test and add it to the inverted patch sequence
 * @param pr
 * @param test
 * @returns {number}
 */
function invertTest(pr, test) {
	pr.push(test);
	return 1;
}

function commuteTest(test, b) {
	if(test.path === b.path && b.op === 'remove') {
		throw new TypeError('Can\'t commute test,remove -> remove,test for same path');
	}

	if(b.op === 'test' || b.op === 'replace') {
		return [b, test];
	}

	return commutePaths(test, b);
}

/**
 * Apply an add operation to x
 * @param {object|array} x
 * @param {object} change add operation
 */
function applyAdd(x, change, options) {
	var pointer = find(x, change.path, options.findContext, change.context);

	if(notFound(pointer)) {
		throw new InvalidPatchOperationError('path does not exist ' + change.path);
	}

	if(change.value === void 0) {
		throw new InvalidPatchOperationError('missing value');
	}

	var val = clone(change.value);

	// If pointer refers to whole document, replace whole document
	if(pointer.key === void 0) {
		return val;
	}

	_add(pointer, val);
	return x;
}

function _add(pointer, value) {
	var target = pointer.target;

	if(Array.isArray(target)) {
		// '-' indicates 'append' to array
		if(pointer.key === '-') {
			target.push(value);
		} else if (pointer.key > target.length) {
			throw new InvalidPatchOperationError('target of add outside of array bounds')
		} else {
			target.splice(pointer.key, 0, value);
		}
	} else if(isValidObject(target)) {
		target[pointer.key] = value;
	} else {
		throw new InvalidPatchOperationError('target of add must be an object or array ' + pointer.key);
	}
}

function invertAdd(pr, add) {
	var context = add.context;
	if(context !== void 0) {
		context = {
			before: context.before,
			after: array.cons(add.value, context.after)
		}
	}
	pr.push({ op: 'test', path: add.path, value: add.value, context: context });
	pr.push({ op: 'remove', path: add.path, context: context });
	return 1;
}

function commuteAddOrCopy(add, b) {
	if(add.path === b.path && b.op === 'remove') {
		throw new TypeError('Can\'t commute add,remove -> remove,add for same path');
	}

	return commutePaths(add, b);
}

/**
 * Apply a replace operation to x
 * @param {object|array} x
 * @param {object} change replace operation
 */
function applyReplace(x, change, options) {
	var pointer = find(x, change.path, options.findContext, change.context);

	if(notFound(pointer) || missingValue(pointer)) {
		throw new InvalidPatchOperationError('path does not exist ' + change.path);
	}

	if(change.value === void 0) {
		throw new InvalidPatchOperationError('missing value');
	}

	var value = clone(change.value);

	// If pointer refers to whole document, replace whole document
	if(pointer.key === void 0) {
		return value;
	}

	var target = pointer.target;

	if(Array.isArray(target)) {
		target[parseArrayIndex(pointer.key)] = value;
	} else {
		target[pointer.key] = value;
	}

	return x;
}

function invertReplace(pr, c, i, patch) {
	var prev = patch[i-1];
	if(prev === void 0 || prev.op !== 'test' || prev.path !== c.path) {
		throw new PatchNotInvertibleError('cannot invert replace w/o test');
	}

	var context = prev.context;
	if(context !== void 0) {
		context = {
			before: context.before,
			after: array.cons(prev.value, array.tail(context.after))
		}
	}

	pr.push({ op: 'test', path: prev.path, value: c.value });
	pr.push({ op: 'replace', path: prev.path, value: prev.value });
	return 2;
}

function commuteReplace(replace, b) {
	if(replace.path === b.path && b.op === 'remove') {
		throw new TypeError('Can\'t commute replace,remove -> remove,replace for same path');
	}

	if(b.op === 'test' || b.op === 'replace') {
		return [b, replace];
	}

	return commutePaths(replace, b);
}

/**
 * Apply a remove operation to x
 * @param {object|array} x
 * @param {object} change remove operation
 */
function applyRemove(x, change, options) {
	var pointer = find(x, change.path, options.findContext, change.context);

	// key must exist for remove
	if(notFound(pointer) || pointer.target[pointer.key] === void 0) {
		throw new InvalidPatchOperationError('path does not exist ' + change.path);
	}

	_remove(pointer);
	return x;
}

function _remove (pointer) {
	var target = pointer.target;

	var removed;
	if (Array.isArray(target)) {
		removed = target.splice(parseArrayIndex(pointer.key), 1);
		return removed[0];

	} else if (isValidObject(target)) {
		removed = target[pointer.key];
		delete target[pointer.key];
		return removed;

	} else {
		throw new InvalidPatchOperationError('target of remove must be an object or array');
	}
}

function invertRemove(pr, c, i, patch) {
	var prev = patch[i-1];
	if(prev === void 0 || prev.op !== 'test' || prev.path !== c.path) {
		throw new PatchNotInvertibleError('cannot invert remove w/o test');
	}

	var context = prev.context;
	if(context !== void 0) {
		context = {
			before: context.before,
			after: array.tail(context.after)
		}
	}

	pr.push({ op: 'add', path: prev.path, value: prev.value, context: context });
	return 2;
}

function commuteRemove(remove, b) {
	if(remove.path === b.path && b.op === 'remove') {
		return [b, remove];
	}

	return commutePaths(remove, b);
}

/**
 * Apply a move operation to x
 * @param {object|array} x
 * @param {object} change move operation
 */
function applyMove(x, change, options) {
	if(jsonPointer.contains(change.path, change.from)) {
		throw new InvalidPatchOperationError('move.from cannot be ancestor of move.path');
	}

	var pto = find(x, change.path, options.findContext, change.context);
	var pfrom = find(x, change.from, options.findContext, change.fromContext);

	_add(pto, _remove(pfrom));
	return x;
}

function invertMove(pr, c) {
	pr.push({ op: 'move',
		path: c.from, context: c.fromContext,
		from: c.path, fromContext: c.context });
	return 1;
}

function commuteMove(move, b) {
	if(move.path === b.path && b.op === 'remove') {
		throw new TypeError('Can\'t commute move,remove -> move,replace for same path');
	}

	return commutePaths(move, b);
}

/**
 * Apply a copy operation to x
 * @param {object|array} x
 * @param {object} change copy operation
 */
function applyCopy(x, change, options) {
	var pto = find(x, change.path, options.findContext, change.context);
	var pfrom = find(x, change.from, options.findContext, change.fromContext);

	if(notFound(pfrom) || missingValue(pfrom)) {
		throw new InvalidPatchOperationError('copy.from must exist');
	}

	var target = pfrom.target;
	var value;

	if(Array.isArray(target)) {
		value = target[parseArrayIndex(pfrom.key)];
	} else {
		value = target[pfrom.key];
	}

	_add(pto, clone(value));
	return x;
}

// NOTE: Copy is not invertible
// See https://github.com/cujojs/jiff/issues/9
// This needs more thought. We may have to extend/amend JSON Patch.
// At first glance, this seems like it should just be a remove.
// However, that's not correct.  It violates the involution:
// invert(invert(p)) ~= p.  For example:
// invert(copy) -> remove
// invert(remove) -> add
// thus: invert(invert(copy)) -> add (DOH! this should be copy!)

function notInvertible(_, c) {
	throw new PatchNotInvertibleError('cannot invert ' + c.op);
}

function notFound (pointer) {
	return pointer === void 0 || (pointer.target == null && pointer.key !== void 0);
}

function missingValue(pointer) {
	return pointer.key !== void 0 && pointer.target[pointer.key] === void 0;
}

/**
 * Return true if x is a non-null object
 * @param {*} x
 * @returns {boolean}
 */
function isValidObject (x) {
	return x !== null && typeof x === 'object';
}

},{"./InvalidPatchOperationError":21,"./PatchNotInvertibleError":22,"./TestFailedError":23,"./array":24,"./clone":25,"./commutePaths":26,"./deepEquals":27,"./jsonPointer":30}],34:[function(require,module,exports){
(function (global){
/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */

(function(global) {
    'use strict';
    // existing version for noConflict()
    var _Base64 = global.Base64;
    var version = "2.3.2";
    // if node.js, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = require('buffer').Buffer;
        } catch (err) {}
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && buffer.from !== Uint8Array.from ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = buffer ?
        buffer.from && buffer.from !== Uint8Array.from ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {		
        // AMD. Register as an anonymous module.	
        define([], function(){ return global.Base64 });
    }
    // that's it!
})(   typeof self   !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
    : typeof global !== 'undefined' ? global
    : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":2}],35:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":36,"./lib/inflate":37,"./lib/utils/common":38,"./lib/zlib/constants":41}],36:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":38,"./utils/strings":39,"./zlib/deflate":43,"./zlib/messages":48,"./zlib/zstream":50}],37:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":38,"./utils/strings":39,"./zlib/constants":41,"./zlib/gzheader":44,"./zlib/inflate":46,"./zlib/messages":48,"./zlib/zstream":50}],38:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],39:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":38}],40:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],41:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],42:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],43:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":38,"./adler32":40,"./crc32":42,"./messages":48,"./trees":49}],44:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],45:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],46:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":38,"./adler32":40,"./crc32":42,"./inffast":45,"./inftrees":47}],47:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":38}],48:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],49:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":38}],50:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],51:[function(require,module,exports){
module.exports={
  "fivehundredpix": {
    "icon": "M42.9,27.6c-2.1,0-3.6,1-5.8,3.5c-1.9-2.5-3.8-3.5-5.8-3.5c-1.7,0-3.7,0.7-4.7,3.2 c-1-2-2.7-2.6-4.1-2.6c-1,0-2,0.2-2.9,1.1l0.6-3.3h6.2v-2.5h-8.4l-1.5,8v0.2h2.7c0.6-1,1.5-1.2,2.3-1.2c1.2,0,2.3,0.6,2.6,2.4v0.7 c-0.2,1.6-1.3,2.6-2.6,2.6c-1.1,0-2.3-0.6-2.4-2.2h-3v0.7c0,0.3,0.5,1.5,0.5,1.6c1.3,2.1,3.4,2.5,5,2.5c1.8,0,3.9-0.7,5.1-3.2 c1.1,2.4,3,3.1,4.8,3.1c2.1,0,3.5-0.9,5.7-3.3c1.9,2.3,3.7,3.3,5.7,3.3c3.4,0,5.1-2.6,5.1-5.6C48,30,46.2,27.6,42.9,27.6z  M34.7,33.7c-0.4,0.4-1,0.9-1.4,1.1c-0.7,0.4-1.3,0.6-1.9,0.6c-0.6,0-1.7-0.4-2.1-1.3c-0.1-0.2-0.2-0.6-0.2-0.7v-0.9 c0.3-1.5,1.1-2.1,2.2-2.1c0.1,0,0.6,0,0.9,0.1c0.4,0.1,0.7,0.3,1.1,0.6c0.4,0.3,2,1.6,2,1.8C35.3,33.2,34.9,33.5,34.7,33.7z  M42.9,35.5c-1.3,0-2.6-0.9-3.9-2.3c1.4-1.5,2.5-2.6,3.8-2.6c1.5,0,2.3,1.1,2.3,2.5C45.2,34.4,44.4,35.5,42.9,35.5z",
    "mask": "M33.3,31.3c-0.4-0.2-0.7-0.4-1.1-0.6c-0.3-0.1-0.8-0.1-0.9-0.1c-1.1,0-1.9,0.6-2.2,2.1v0.9c0,0.1,0.1,0.4,0.2,0.7 c0.3,0.9,1.4,1.3,2.1,1.3s1.2-0.2,1.9-0.6c0.5-0.3,1-0.7,1.4-1.1c0.2-0.2,0.5-0.5,0.5-0.6C35.3,32.8,33.7,31.6,33.3,31.3z  M42.8,30.6c-1.3,0-2.4,1-3.8,2.6c1.3,1.5,2.6,2.3,3.9,2.3c1.5,0,2.2-1.1,2.2-2.4C45.2,31.7,44.3,30.6,42.8,30.6z M0,0v64h64V0H0z  M42.9,38.5c-2,0-3.8-1-5.7-3.3c-2.2,2.4-3.7,3.3-5.7,3.3c-1.8,0-3.7-0.7-4.8-3.1c-1.2,2.5-3.3,3.2-5.1,3.2c-1.6,0-3.8-0.4-5-2.5 C16.5,36,16,34.8,16,34.5v-0.7h3c0.1,1.6,1.3,2.2,2.4,2.2c1.3,0,2.4-0.9,2.6-2.6v-0.7c-0.2-1.8-1.3-2.4-2.6-2.4 c-0.8,0-1.6,0.2-2.3,1.2h-2.7v-0.2l1.5-8h8.4v2.5h-6.2l-0.6,3.3c1-0.9,2-1.1,2.9-1.1c1.4,0,3.2,0.6,4.1,2.6c1-2.4,3-3.2,4.7-3.2 c2,0,3.9,1,5.8,3.5c2.1-2.6,3.7-3.5,5.8-3.5c3.3,0,5.1,2.4,5.1,5.4C48,35.9,46.2,38.5,42.9,38.5z",
    "color": "#222222"
  },
  "bandsintown": {
    "icon": "M25.8,39.3h13.4v1.1H24.7V18h-5.6v28h25.8V33.7h-19V39.3z M31.4,24.7h-5.6v7.8h5.6V24.7z M38.2,24.7h-5.6v7.8h5.6V24.7z M39.3,18v14.6h5.6V18H39.3z",
    "mask": "M0,0v64h64V0H0z M32.6,24.7h5.6v7.8h-5.6V24.7z M25.8,24.7h5.6v7.8h-5.6V24.7z M44.9,46H19.1V18h5.6v22.4h14.6 v-1.1H25.8v-5.6h19V46z M44.9,32.6h-5.6V18h5.6V32.6z",
    "color": "#1B8793"
  },
  "behance": {
    "icon": "M29.1,31c0.8-0.4,1.5-0.9,1.9-1.5c0.4-0.6,0.6-1.4,0.6-2.3c0-0.9-0.1-1.6-0.4-2.2 c-0.3-0.6-0.7-1.1-1.2-1.4c-0.5-0.4-1.1-0.6-1.9-0.8c-0.7-0.2-1.5-0.2-2.4-0.2H17v18.5h8.9c0.8,0,1.6-0.1,2.4-0.3 c0.8-0.2,1.5-0.5,2.1-1c0.6-0.4,1.1-1,1.5-1.7c0.4-0.7,0.5-1.5,0.5-2.4c0-1.2-0.3-2.1-0.8-3C31.1,31.9,30.2,31.3,29.1,31z  M21.1,25.7h3.8c0.4,0,0.7,0,1,0.1c0.3,0.1,0.6,0.2,0.9,0.3c0.3,0.2,0.5,0.4,0.6,0.6c0.2,0.3,0.2,0.6,0.2,1.1c0,0.8-0.2,1.3-0.7,1.7 c-0.5,0.3-1.1,0.5-1.8,0.5h-4.1V25.7z M28.2,36.7c-0.2,0.3-0.4,0.6-0.7,0.7c-0.3,0.2-0.6,0.3-1,0.4c-0.4,0.1-0.7,0.1-1.1,0.1h-4.3 v-5.1h4.4c0.9,0,1.6,0.2,2.1,0.6c0.5,0.4,0.8,1.1,0.8,2C28.4,36,28.3,36.4,28.2,36.7z M46.7,32.3c-0.2-0.9-0.6-1.8-1.2-2.5 C45,29,44.3,28.4,43.5,28c-0.8-0.4-1.8-0.7-3-0.7c-1,0-1.9,0.2-2.8,0.5c-0.8,0.4-1.6,0.9-2.2,1.5c-0.6,0.6-1.1,1.4-1.4,2.2 c-0.3,0.9-0.5,1.8-0.5,2.8c0,1,0.2,2,0.5,2.8c0.3,0.9,0.8,1.6,1.4,2.2c0.6,0.6,1.3,1.1,2.2,1.4c0.9,0.3,1.8,0.5,2.9,0.5 c1.5,0,2.8-0.3,3.9-1c1.1-0.7,1.9-1.8,2.4-3.4h-3.2c-0.1,0.4-0.4,0.8-1,1.2c-0.5,0.4-1.2,0.6-1.9,0.6c-1,0-1.8-0.3-2.4-0.8 c-0.6-0.5-0.9-1.5-0.9-2.6H47C47,34.2,47,33.2,46.7,32.3z M37.3,32.9c0-0.3,0.1-0.6,0.2-0.9c0.1-0.3,0.3-0.6,0.5-0.9 c0.2-0.3,0.5-0.5,0.9-0.7c0.4-0.2,0.9-0.3,1.5-0.3c0.9,0,1.6,0.3,2.1,0.7c0.4,0.5,0.8,1.2,0.8,2.1H37.3z M44.1,23.8h-7.5v1.8h7.5 V23.8z",
    "mask": "M40.4,30.1c-0.6,0-1.1,0.1-1.5,0.3c-0.4,0.2-0.7,0.4-0.9,0.7c-0.2,0.3-0.4,0.6-0.5,0.9c-0.1,0.3-0.2,0.6-0.2,0.9 h6c-0.1-0.9-0.4-1.6-0.8-2.1C42,30.3,41.3,30.1,40.4,30.1z M25.5,32.8h-4.4v5.1h4.3c0.4,0,0.8,0,1.1-0.1c0.4-0.1,0.7-0.2,1-0.4 c0.3-0.2,0.5-0.4,0.7-0.7c0.2-0.3,0.2-0.7,0.2-1.2c0-1-0.3-1.6-0.8-2C27.1,33,26.4,32.8,25.5,32.8z M27,29.5 c0.5-0.3,0.7-0.9,0.7-1.7c0-0.4-0.1-0.8-0.2-1.1c-0.2-0.3-0.4-0.5-0.6-0.6c-0.3-0.2-0.6-0.3-0.9-0.3c-0.3-0.1-0.7-0.1-1-0.1h-3.8 v4.3h4.1C25.9,30.1,26.5,29.9,27,29.5z M0,0v64h64V0H0z M36.6,23.8h7.5v1.8h-7.5V23.8z M31.9,38.1c-0.4,0.7-0.9,1.2-1.5,1.7 c-0.6,0.4-1.3,0.8-2.1,1c-0.8,0.2-1.6,0.3-2.4,0.3H17V22.6h8.7c0.9,0,1.7,0.1,2.4,0.2c0.7,0.2,1.3,0.4,1.9,0.8 c0.5,0.4,0.9,0.8,1.2,1.4c0.3,0.6,0.4,1.3,0.4,2.2c0,0.9-0.2,1.7-0.6,2.3c-0.4,0.6-1,1.1-1.9,1.5c1.1,0.3,2,0.9,2.5,1.7 c0.6,0.8,0.8,1.8,0.8,3C32.5,36.6,32.3,37.4,31.9,38.1z M47,35.3h-9.6c0,1.1,0.4,2.1,0.9,2.6c0.5,0.5,1.3,0.8,2.4,0.8 c0.7,0,1.4-0.2,1.9-0.6c0.5-0.4,0.9-0.8,1-1.2h3.2c-0.5,1.6-1.3,2.8-2.4,3.4c-1.1,0.7-2.4,1-3.9,1c-1.1,0-2-0.2-2.9-0.5 c-0.8-0.3-1.6-0.8-2.2-1.4c-0.6-0.6-1-1.4-1.4-2.2c-0.3-0.9-0.5-1.8-0.5-2.8c0-1,0.2-1.9,0.5-2.8c0.3-0.9,0.8-1.6,1.4-2.2 c0.6-0.6,1.3-1.1,2.2-1.5c0.8-0.4,1.8-0.5,2.8-0.5c1.1,0,2.1,0.2,3,0.7c0.8,0.4,1.5,1,2.1,1.8c0.5,0.7,0.9,1.6,1.2,2.5 C47,33.2,47,34.2,47,35.3z",
    "color": "#007CFF"
  },
  "codepen": {
    "icon": "M24.4,35l6.8,4.5v-4L27.4,33L24.4,35z M23.8,30.6v2.7l2.1-1.4L23.8,30.6z M31.2,28.5v-4L24.4,29 l3,2L31.2,28.5z M39.6,29l-6.8-4.5v4l3.7,2.5L39.6,29z M32,30l-3,2l3,2l3-2L32,30z M32,16c-8.8,0-16,7.2-16,16c0,8.8,7.2,16,16,16 s16-7.2,16-16C48,23.2,40.8,16,32,16z M41.9,35.1c0,0.3-0.1,0.6-0.4,0.7l-9.1,5.9c-0.3,0.2-0.6,0.2-0.9,0l-9.1-5.9 c-0.2-0.2-0.4-0.4-0.4-0.7v-6.2c0-0.3,0.1-0.6,0.4-0.7l9.1-5.9c0.3-0.2,0.6-0.2,0.9,0l9.1,5.9c0.2,0.2,0.4,0.4,0.4,0.7V35.1z  M32.8,35.5v4l6.8-4.5l-3-2L32.8,35.5z M40.2,33.4v-2.7L38.1,32L40.2,33.4z",
    "mask": "M0,0v64h64V0H0z M32,48c-8.8,0-16-7.2-16-16c0-8.8,7.2-16,16-16s16,7.2,16,16C48,40.8,40.8,48,32,48z M32.5,22.3 c-0.3-0.2-0.6-0.2-0.9,0l-9.1,5.9c-0.2,0.2-0.4,0.4-0.4,0.7v6.2c0,0.3,0.1,0.6,0.4,0.7l9.1,5.9c0.3,0.2,0.6,0.2,0.9,0l9.1-5.9 c0.2-0.2,0.4-0.4,0.4-0.7v-6.2c0-0.3-0.1-0.6-0.4-0.7L32.5,22.3z M32.8,24.5l6.8,4.5l-3,2l-3.7-2.5V24.5z M31.2,24.5v4L27.4,31l-3-2 L31.2,24.5z M23.8,30.6l2.1,1.4l-2.1,1.4V30.6z M31.2,39.5L24.4,35l3-2l3.7,2.5V39.5z M32,34l-3-2l3-2l3,2L32,34z M32.8,39.5v-4 l3.7-2.5l3,2L32.8,39.5z M40.2,33.4L38.1,32l2.1-1.4V33.4z",
    "color": "##151515"
  },
  "dribbble": {
    "icon": "M32,48c-8.8,0-16-7.2-16-16s7.2-16,16-16 s16,7.2,16,16S40.8,48,32,48z M45.5,34.2C45,34,41.3,32.9,37,33.6c1.8,4.9,2.5,8.9,2.7,9.7C42.7,41.3,44.9,38,45.5,34.2z M37.3,44.6 c-0.2-1.2-1-5.4-2.9-10.4c0,0-0.1,0-0.1,0c-7.7,2.7-10.5,8-10.7,8.5c2.3,1.8,5.2,2.9,8.4,2.9C33.9,45.7,35.7,45.3,37.3,44.6z  M21.8,41.2c0.3-0.5,4.1-6.7,11.1-9c0.2-0.1,0.4-0.1,0.5-0.2c-0.3-0.8-0.7-1.6-1.1-2.3c-6.8,2-13.4,2-14,1.9c0,0.1,0,0.3,0,0.4 C18.3,35.5,19.7,38.7,21.8,41.2z M18.6,29.2c0.6,0,6.2,0,12.6-1.7c-2.3-4-4.7-7.4-5.1-7.9C22.4,21.5,19.5,25,18.6,29.2z M28.8,18.7 c0.4,0.5,2.9,3.9,5.1,8c4.9-1.8,6.9-4.6,7.2-4.9c-2.4-2.1-5.6-3.4-9.1-3.4C30.9,18.4,29.8,18.5,28.8,18.7z M42.6,23.4 c-0.3,0.4-2.6,3.3-7.6,5.4c0.3,0.7,0.6,1.3,0.9,2c0.1,0.2,0.2,0.5,0.3,0.7c4.5-0.6,9.1,0.3,9.5,0.4C45.6,28.7,44.5,25.7,42.6,23.4z",
    "mask": "M34.3,34.3c-7.7,2.7-10.5,8-10.7,8.5c2.3,1.8,5.2,2.9,8.4,2.9c1.9,0,3.7-0.4,5.3-1.1 C37.1,43.4,36.3,39.2,34.3,34.3C34.4,34.2,34.4,34.3,34.3,34.3z M31.3,27.6c-2.3-4-4.7-7.4-5.1-7.9c-3.8,1.8-6.7,5.3-7.6,9.6 C19.2,29.2,24.9,29.3,31.3,27.6z M33,32.1c0.2-0.1,0.4-0.1,0.5-0.2c-0.3-0.8-0.7-1.6-1.1-2.3c-6.8,2-13.4,2-14,1.9 c0,0.1,0,0.3,0,0.4c0,3.5,1.3,6.7,3.5,9.1C22.2,40.6,25.9,34.4,33,32.1z M41.1,21.8c-2.4-2.1-5.6-3.4-9.1-3.4 c-1.1,0-2.2,0.1-3.2,0.4c0.4,0.5,2.9,3.9,5.1,8C38.8,24.9,40.8,22.1,41.1,21.8z M34.9,28.8c0.3,0.7,0.6,1.3,0.9,2 c0.1,0.2,0.2,0.5,0.3,0.7c4.5-0.6,9.1,0.3,9.5,0.4c0-3.2-1.2-6.2-3.1-8.5C42.3,23.8,40,26.7,34.9,28.8z M37,33.6 c1.8,4.9,2.5,8.9,2.7,9.7c3.1-2.1,5.2-5.4,5.9-9.2C45,34,41.3,32.9,37,33.6z M0,0v64h64V0H0z M32,48c-8.8,0-16-7.2-16-16 s7.2-16,16-16s16,7.2,16,16S40.8,48,32,48z",
    "color": "#ea4c89"
  },
  "dropbox": {
    "icon": "M25.4,17.1L16,23.3l6.5,5.2l9.5-5.9L25.4,17.1z M16,33.7l9.4,6.1l6.6-5.5l-9.5-5.9L16,33.7z  M32,34.3l6.6,5.5l9.4-6.1l-6.5-5.2L32,34.3z M48,23.3l-9.4-6.1L32,22.6l9.5,5.9L48,23.3z M32,35.5L25.4,41l-2.8-1.8v2.1l9.4,5.7 l9.4-5.7v-2.1L38.6,41L32,35.5z",
    "mask": "M0,0v64h64V0H0z M41.5,41.2L32,46.9l-9.4-5.7v-2.1l2.8,1.8l6.6-5.5l6.6,5.5l2.8-1.8V41.2z M48,33.7l-9.4,6.1 L32,34.3l-6.6,5.5L16,33.7l6.5-5.2L16,23.3l9.4-6.1l6.6,5.5l6.6-5.5l9.4,6.1l-6.5,5.2L48,33.7z M22.5,28.5l9.5,5.9l9.5-5.9L32,22.6 L22.5,28.5z",
    "color": "#1081DE"
  },
  "email": {
    "icon": "M17,22v20h30V22H17z M41.1,25L32,32.1L22.9,25H41.1z M20,39V26.6l12,9.3l12-9.3V39H20z",
    "mask": "M41.1,25H22.9l9.1,7.1L41.1,25z M44,26.6l-12,9.3l-12-9.3V39h24V26.6z M0,0v64h64V0H0z M47,42H17V22h30V42z",
    "color": "#7f7f7f"
  },
  "facebook": {
    "icon": "M34.1,47V33.3h4.6l0.7-5.3h-5.3v-3.4c0-1.5,0.4-2.6,2.6-2.6l2.8,0v-4.8c-0.5-0.1-2.2-0.2-4.1-0.2 c-4.1,0-6.9,2.5-6.9,7V28H24v5.3h4.6V47H34.1z",
    "mask": "M0,0v64h64V0H0z M39.6,22l-2.8,0c-2.2,0-2.6,1.1-2.6,2.6V28h5.3l-0.7,5.3h-4.6V47h-5.5V33.3H24V28h4.6V24 c0-4.6,2.8-7,6.9-7c2,0,3.6,0.1,4.1,0.2V22z",
    "color": "#3b5998"
  },
  "flickr": {
    "icon": "M32,16c-8.8,0-16,7.2-16,16s7.2,16,16,16s16-7.2,16-16S40.8,16,32,16z M26,37c-2.8,0-5-2.2-5-5 s2.2-5,5-5s5,2.2,5,5S28.8,37,26,37z M38,37c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S40.8,37,38,37z",
    "mask": "M38,27c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S40.8,27,38,27z M0,0v64h64V0H0z M32,48c-8.8,0-16-7.2-16-16 s7.2-16,16-16s16,7.2,16,16S40.8,48,32,48z M26,27c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S28.8,27,26,27z",
    "color": "#0063db"
  },
  "foursquare": {
    "icon": "M41.5,17c0,0-14.3,0-16.5,0c-2.3,0-3,1.7-3,2.8c0,1.1,0,26.3,0,26.3c0,1.2,0.7,1.7,1,1.8 c0.4,0.1,1.4,0.3,2-0.4c0,0,7.8-9.1,7.9-9.2c0.2-0.2,0.2-0.2,0.4-0.2c0.4,0,3.4,0,5.1,0c2.1,0,2.5-1.5,2.7-2.4 c0.2-0.7,2.3-11.3,2.9-14.7C44.6,18.4,43.9,17,41.5,17z M41.1,35.7c0.2-0.7,2.3-11.3,2.9-14.7 M40.5,21.5l-0.7,3.6 c-0.1,0.4-0.6,0.8-1,0.8c-0.5,0-6.4,0-6.4,0c-0.7,0-1.2,0.5-1.2,1.2v0.8c0,0.7,0.5,1.2,1.2,1.2c0,0,5,0,5.5,0c0.5,0,1,0.6,0.9,1.1 c-0.1,0.5-0.6,3.3-0.7,3.6c-0.1,0.3-0.4,0.8-1,0.8c-0.5,0-4.5,0-4.5,0c-0.8,0-1.1,0.1-1.6,0.8c-0.5,0.7-5.4,6.5-5.4,6.5 c0,0.1-0.1,0-0.1,0V21.4c0-0.5,0.4-1,1-1c0,0,12.8,0,13.3,0C40.2,20.4,40.6,20.9,40.5,21.5z",
    "mask": "M39.7,20.4c-0.5,0-13.3,0-13.3,0c-0.6,0-1,0.5-1,1v20.5c0,0.1,0,0.1,0.1,0c0,0,4.9-5.9,5.4-6.5 c0.5-0.7,0.8-0.8,1.6-0.8c0,0,3.9,0,4.5,0c0.6,0,1-0.5,1-0.8c0.1-0.3,0.6-3,0.7-3.6c0.1-0.5-0.4-1.1-0.9-1.1c-0.5,0-5.5,0-5.5,0 c-0.7,0-1.2-0.5-1.2-1.2v-0.8c0-0.7,0.5-1.2,1.2-1.2c0,0,6,0,6.4,0c0.5,0,0.9-0.4,1-0.8l0.7-3.6C40.6,20.9,40.2,20.4,39.7,20.4z  M0,0v64h64V0H0z M44,20.9l-1,5.2c-0.8,4.2-1.8,9-1.9,9.5c-0.2,0.9-0.6,2.4-2.7,2.4h-5.1c-0.2,0-0.2,0-0.4,0.2 c-0.1,0.1-7.9,9.2-7.9,9.2c-0.6,0.7-1.6,0.6-2,0.4c-0.4-0.1-1-0.6-1-1.8c0,0,0-25.2,0-26.3c0-1.1,0.7-2.8,3-2.8c2.3,0,16.5,0,16.5,0 C43.9,17,44.6,18.4,44,20.9z",
    "color": "#0072b1"
  },
  "github": {
    "icon": "M32,16c-8.8,0-16,7.2-16,16c0,7.1,4.6,13.1,10.9,15.2 c0.8,0.1,1.1-0.3,1.1-0.8c0-0.4,0-1.4,0-2.7c-4.5,1-5.4-2.1-5.4-2.1c-0.7-1.8-1.8-2.3-1.8-2.3c-1.5-1,0.1-1,0.1-1 c1.6,0.1,2.5,1.6,2.5,1.6c1.4,2.4,3.7,1.7,4.7,1.3c0.1-1,0.6-1.7,1-2.1c-3.6-0.4-7.3-1.8-7.3-7.9c0-1.7,0.6-3.2,1.6-4.3 c-0.2-0.4-0.7-2,0.2-4.2c0,0,1.3-0.4,4.4,1.6c1.3-0.4,2.6-0.5,4-0.5c1.4,0,2.7,0.2,4,0.5c3.1-2.1,4.4-1.6,4.4-1.6 c0.9,2.2,0.3,3.8,0.2,4.2c1,1.1,1.6,2.5,1.6,4.3c0,6.1-3.7,7.5-7.3,7.9c0.6,0.5,1.1,1.5,1.1,3c0,2.1,0,3.9,0,4.4 c0,0.4,0.3,0.9,1.1,0.8C43.4,45.1,48,39.1,48,32C48,23.2,40.8,16,32,16z",
    "mask": "M0,0v64h64V0H0z M37.1,47.2c-0.8,0.2-1.1-0.3-1.1-0.8c0-0.5,0-2.3,0-4.4c0-1.5-0.5-2.5-1.1-3 c3.6-0.4,7.3-1.7,7.3-7.9c0-1.7-0.6-3.2-1.6-4.3c0.2-0.4,0.7-2-0.2-4.2c0,0-1.3-0.4-4.4,1.6c-1.3-0.4-2.6-0.5-4-0.5 c-1.4,0-2.7,0.2-4,0.5c-3.1-2.1-4.4-1.6-4.4-1.6c-0.9,2.2-0.3,3.8-0.2,4.2c-1,1.1-1.6,2.5-1.6,4.3c0,6.1,3.7,7.5,7.3,7.9 c-0.5,0.4-0.9,1.1-1,2.1c-0.9,0.4-3.2,1.1-4.7-1.3c0,0-0.8-1.5-2.5-1.6c0,0-1.6,0-0.1,1c0,0,1,0.5,1.8,2.3c0,0,0.9,3.1,5.4,2.1 c0,1.3,0,2.3,0,2.7c0,0.4-0.3,0.9-1.1,0.8C20.6,45.1,16,39.1,16,32c0-8.8,7.2-16,16-16c8.8,0,16,7.2,16,16 C48,39.1,43.4,45.1,37.1,47.2z",
    "color": "#4183c4"
  },
  "google_play": {
    "icon": "M24.4,45.6l16-8.8l-3.6-3.6L24.4,45.6z M22.2,18.5c-0.1,0.2-0.2,0.5-0.2,0.9v25.1 c0,0.4,0.1,0.6,0.2,0.9L35.6,32L22.2,18.5z M47.1,30.8L42.1,28L38.1,32l4,4l5-2.8C48.3,32.5,48.3,31.4,47.1,30.8z M40.4,27.1 l-15.9-8.8l12.3,12.3L40.4,27.1z",
    "mask": "M0,0v64h64V0H0z M40.4,27.1l-3.6,3.6L24.5,18.4L40.4,27.1z M22,44.5V19.4c0-0.4,0.1-0.7,0.2-0.9L35.6,32 L22.2,45.4C22.1,45.2,22,44.9,22,44.5z M24.4,45.6l12.4-12.4l3.6,3.6L24.4,45.6z M47.1,33.2l-5,2.8l-4-4l3.9-3.9l5.1,2.8 C48.3,31.4,48.3,32.5,47.1,33.2z",
    "color": "#40BBC1"
  },
  "google": {
    "icon": "M35.4,17h-8c-1.1,0-2.2,0.1-3.4,0.4 c-1.2,0.3-2.4,0.9-3.5,1.8c-1.7,1.6-2.5,3.4-2.5,5.4c0,1.6,0.6,3.1,1.8,4.3c1.1,1.3,2.7,2,4.9,2c0.4,0,0.8,0,1.3-0.1 c-0.1,0.2-0.2,0.4-0.2,0.7c-0.1,0.2-0.2,0.5-0.2,0.9c0,0.6,0.1,1.1,0.4,1.5c0.2,0.4,0.5,0.8,0.8,1.2c-0.9,0-2.1,0.1-3.5,0.4 c-1.4,0.2-2.8,0.7-4.1,1.5c-1.2,0.7-1.9,1.5-2.4,2.4c-0.5,0.9-0.7,1.7-0.7,2.5c0,1.5,0.7,2.8,2.1,3.9c1.4,1.2,3.5,1.8,6.3,1.8 c3.3-0.1,5.9-0.9,7.7-2.4c1.7-1.5,2.6-3.2,2.6-5.2c0-1.4-0.3-2.5-0.9-3.3c-0.6-0.8-1.4-1.6-2.2-2.3l-1.4-1.1 c-0.2-0.2-0.4-0.4-0.6-0.7c-0.2-0.3-0.4-0.6-0.4-1c0-0.4,0.1-0.8,0.4-1.1c0.2-0.3,0.4-0.6,0.7-0.8c0.4-0.4,0.8-0.7,1.2-1.1 c0.3-0.4,0.6-0.7,0.9-1.2c0.6-0.9,0.9-2,0.9-3.4c0-0.8-0.1-1.5-0.3-2.1c-0.2-0.6-0.5-1.1-0.7-1.5c-0.3-0.5-0.6-0.8-0.9-1.2 c-0.3-0.3-0.6-0.5-0.8-0.7H33L35.4,17z M31,38.9c0.7,0.8,1,1.6,1,2.7c0,1.3-0.5,2.3-1.5,3.1c-1,0.8-2.4,1.2-4.3,1.3 c-2.1,0-3.8-0.5-5-1.4c-1.3-0.9-1.9-2.1-1.9-3.5c0-0.7,0.1-1.3,0.4-1.8c0.3-0.5,0.6-0.9,0.9-1.2c0.4-0.3,0.8-0.6,1.1-0.7 c0.4-0.2,0.7-0.3,0.9-0.4c0.9-0.3,1.7-0.5,2.5-0.6c0.8-0.1,1.4-0.1,1.6-0.1c0.3,0,0.6,0,0.9,0C29.2,37.3,30.3,38.2,31,38.9z  M29.7,27.1c-0.1,0.5-0.3,1.1-0.7,1.6c-0.7,0.7-1.6,1.1-2.6,1.1c-0.8,0-1.6-0.3-2.2-0.8c-0.6-0.5-1.2-1.1-1.6-1.9 c-0.8-1.6-1.3-3.1-1.3-4.5c0-1.1,0.3-2.1,0.9-3c0.7-0.9,1.6-1.3,2.7-1.3c0.8,0,1.5,0.3,2.2,0.7c0.6,0.5,1.1,1.1,1.5,1.9 c0.8,1.6,1.2,3.2,1.2,4.8C29.8,26.1,29.8,26.5,29.7,27.1z M43.7,29.5v-4.3h-2.5v4.3H37V32h4.2v4.2h2.5V32H48v-2.5H43.7z",
    "mask": "M0,0v64h64V0H0z M31.3,19.1c0.3,0.3,0.6,0.7,0.9,1.2c0.3,0.4,0.5,0.9,0.7,1.5c0.2,0.6,0.3,1.3,0.3,2.1 c0,1.4-0.3,2.6-0.9,3.4c-0.3,0.4-0.6,0.8-0.9,1.2c-0.4,0.4-0.8,0.7-1.2,1.1c-0.2,0.2-0.5,0.5-0.7,0.8c-0.2,0.3-0.4,0.7-0.4,1.1 c0,0.4,0.1,0.8,0.4,1c0.2,0.3,0.4,0.5,0.6,0.7l1.4,1.1c0.8,0.7,1.6,1.5,2.2,2.3c0.6,0.8,0.9,2,0.9,3.3c0,1.9-0.9,3.7-2.6,5.2 c-1.8,1.6-4.3,2.4-7.7,2.4c-2.8,0-4.9-0.6-6.3-1.8c-1.4-1.1-2.1-2.4-2.1-3.9c0-0.7,0.2-1.6,0.7-2.5c0.4-0.9,1.2-1.7,2.4-2.4 c1.3-0.7,2.7-1.2,4.1-1.5c1.4-0.2,2.6-0.3,3.5-0.4c-0.3-0.4-0.5-0.8-0.8-1.2c-0.3-0.4-0.4-0.9-0.4-1.5c0-0.4,0-0.6,0.2-0.9 c0.1-0.2,0.2-0.5,0.2-0.7c-0.5,0.1-0.9,0.1-1.3,0.1c-2.1,0-3.8-0.7-4.9-2c-1.2-1.2-1.8-2.7-1.8-4.3c0-2,0.8-3.8,2.5-5.4 c1.1-0.9,2.3-1.6,3.5-1.8c1.2-0.2,2.3-0.4,3.4-0.4h8L33,18.4h-2.5C30.7,18.6,31,18.8,31.3,19.1z M48,32h-4.3v4.2h-2.5V32H37v-2.5 h4.2v-4.3h2.5v4.3H48V32z M27.1,19.1c-0.6-0.5-1.4-0.7-2.2-0.7c-1.1,0-2,0.5-2.7,1.3c-0.6,0.9-0.9,1.9-0.9,3c0,1.5,0.4,3,1.3,4.5 c0.4,0.7,0.9,1.4,1.6,1.9c0.6,0.5,1.4,0.8,2.2,0.8c1.1,0,1.9-0.4,2.6-1.1c0.3-0.5,0.6-1,0.7-1.6c0.1-0.5,0.1-1,0.1-1.4 c0-1.6-0.4-3.2-1.2-4.8C28.2,20.2,27.7,19.5,27.1,19.1z M26.9,36.2c-0.2,0-0.7,0-1.6,0.1c-0.8,0.1-1.7,0.3-2.5,0.6 c-0.2,0.1-0.5,0.2-0.9,0.4c-0.4,0.2-0.7,0.4-1.1,0.7c-0.4,0.3-0.7,0.7-0.9,1.2c-0.3,0.5-0.4,1.1-0.4,1.8c0,1.4,0.6,2.6,1.9,3.5 c1.2,0.9,2.9,1.4,5,1.4c1.9,0,3.3-0.4,4.3-1.3c1-0.8,1.5-1.8,1.5-3.1c0-1-0.3-1.9-1-2.7c-0.7-0.7-1.8-1.6-3.3-2.6 C27.5,36.2,27.2,36.2,26.9,36.2z",
    "color": "#dd4b39"
  },
  "instagram": {
    "icon": "M43.5,29.7h-2.6c0.2,0.7,0.3,1.5,0.3,2.3 c0,5.1-4.1,9.2-9.2,9.2c-5.1,0-9.2-4.1-9.2-9.2c0-0.8,0.1-1.6,0.3-2.3h-2.6v12.7c0,0.6,0.5,1.2,1.2,1.2h20.8c0.6,0,1.2-0.5,1.2-1.2 V29.7z M43.5,21.6c0-0.6-0.5-1.2-1.2-1.2h-3.5c-0.6,0-1.2,0.5-1.2,1.2v3.5c0,0.6,0.5,1.2,1.2,1.2h3.5c0.6,0,1.2-0.5,1.2-1.2V21.6z  M32,26.2c-3.2,0-5.8,2.6-5.8,5.8c0,3.2,2.6,5.8,5.8,5.8s5.8-2.6,5.8-5.8C37.8,28.8,35.2,26.2,32,26.2 M43.5,47H20.5 c-1.9,0-3.5-1.6-3.5-3.5V20.5c0-1.9,1.5-3.5,3.5-3.5h23.1c1.9,0,3.5,1.5,3.5,3.5v23.1C47,45.4,45.5,47,43.5,47",
    "mask": "M41.2,32c0,5.1-4.1,9.2-9.2,9.2c-5.1,0-9.2-4.1-9.2-9.2c0-0.8,0.1-1.6,0.3-2.3h-2.6v12.7c0,0.6,0.5,1.2,1.2,1.2 h20.8c0.6,0,1.2-0.5,1.2-1.2V29.7h-2.6C41.1,30.4,41.2,31.2,41.2,32z M32,37.8c3.2,0,5.8-2.6,5.8-5.8c0-3.2-2.6-5.8-5.8-5.8 c-3.2,0-5.8,2.6-5.8,5.8C26.2,35.2,28.8,37.8,32,37.8z M42.4,20.5h-3.5c-0.6,0-1.2,0.5-1.2,1.2v3.5c0,0.6,0.5,1.2,1.2,1.2h3.5 c0.6,0,1.2-0.5,1.2-1.2v-3.5C43.5,21,43,20.5,42.4,20.5z M0,0v64h64V0H0z M47,43.5c0,1.9-1.5,3.5-3.5,3.5H20.5 c-1.9,0-3.5-1.6-3.5-3.5V20.5c0-1.9,1.5-3.5,3.5-3.5h23.1c1.9,0,3.5,1.5,3.5,3.5V43.5z",
    "color": "#3f729b"
  },
  "itunes": {
    "icon": "M41.1,17c-0.1,0-0.2,0-0.3,0l-14.7,3c-0.6,0.1-1.1,0.7-1.1,1.4v17.6c0,0.8-0.6,1.4-1.4,1.4 h-2.8c-1.9,0-3.4,1.5-3.4,3.4c0,1.9,1.5,3.4,3.4,3.4h2c2.2,0,4-1.8,4-4V27.4c0-0.4,0.3-0.8,0.7-0.9l12.1-2.4c0.1,0,0.1,0,0.2,0 c0.5,0,0.9,0.4,0.9,0.9v11c0,0.8-0.6,1.4-1.4,1.4h-2.8c-1.9,0-3.4,1.5-3.4,3.4c0,1.9,1.5,3.4,3.4,3.4h2c2.2,0,4-1.8,4-4V18.4 C42.5,17.6,41.9,17,41.1,17z",
    "mask": "M0,0v64h64V0H0z M42.5,40c0,2.2-1.8,4-4,4h-2c-1.9,0-3.4-1.5-3.4-3.4s1.5-3.4,3.4-3.4h2.8c0.8,0,1.4-0.6,1.4-1.4 v-11c0-0.5-0.4-0.9-0.9-0.9c-0.1,0-0.1,0-0.2,0l-12.1,2.4c-0.4,0.1-0.7,0.4-0.7,0.9V43c0,2.2-1.8,4-4,4h-2c-1.9,0-3.4-1.5-3.4-3.4 c0-1.9,1.5-3.4,3.4-3.4h2.8c0.8,0,1.4-0.6,1.4-1.4V21.3c0-0.7,0.5-1.2,1.1-1.4l14.7-3c0.1,0,0.2,0,0.3,0c0.8,0,1.4,0.6,1.4,1.4V40z",
    "color": "#E049D1"
  },
  "linkedin": {
    "icon": "M20.4,44h5.4V26.6h-5.4V44z M23.1,18c-1.7,0-3.1,1.4-3.1,3.1c0,1.7,1.4,3.1,3.1,3.1 c1.7,0,3.1-1.4,3.1-3.1C26.2,19.4,24.8,18,23.1,18z M39.5,26.2c-2.6,0-4.4,1.4-5.1,2.8h-0.1v-2.4h-5.2V44h5.4v-8.6 c0-2.3,0.4-4.5,3.2-4.5c2.8,0,2.8,2.6,2.8,4.6V44H46v-9.5C46,29.8,45,26.2,39.5,26.2z",
    "mask": "M0,0v64h64V0H0z M25.8,44h-5.4V26.6h5.4V44z M23.1,24.3c-1.7,0-3.1-1.4-3.1-3.1c0-1.7,1.4-3.1,3.1-3.1 c1.7,0,3.1,1.4,3.1,3.1C26.2,22.9,24.8,24.3,23.1,24.3z M46,44h-5.4v-8.4c0-2,0-4.6-2.8-4.6c-2.8,0-3.2,2.2-3.2,4.5V44h-5.4V26.6 h5.2V29h0.1c0.7-1.4,2.5-2.8,5.1-2.8c5.5,0,6.5,3.6,6.5,8.3V44z",
    "color": "#007fb1"
  },
  "medium": {
    "icon": "M47,23.7h-1.2c-0.4,0-0.9,0.6-0.9,1v14.7c0,0.4,0.5,1,0.9,1H47v3.4H36.4v-3.4h2.1V24.9h-0.1 l-5.3,18.9h-4.1l-5.2-18.9h-0.1v15.5H26v3.4h-9v-3.4h1.2c0.5,0,1-0.6,1-1V24.7c0-0.4-0.5-1-1-1H17v-3.6h11.3l3.7,13.8h0.1l3.7-13.8 H47V23.7z",
    "mask": "M0,0v64h64V0H0z M47,23.7h-1.2c-0.4,0-0.9,0.6-0.9,1v14.7c0,0.4,0.5,1,0.9,1H47v3.4H36.4v-3.4h2.1V24.9h-0.1 l-5.3,18.9h-4.1l-5.2-18.9h-0.1v15.5H26v3.4h-9v-3.4h1.2c0.5,0,1-0.6,1-1V24.7c0-0.4-0.5-1-1-1H17v-3.6h11.3l3.7,13.8h0.1l3.7-13.8 H47V23.7z",
    "color": "#333332"
  },
  "meetup": {
    "icon": "M30.8,33.4c0-6.3,1.9-11.9,3.5-15.3c0.5-1.1,0.9-1.4,1.9-1.4c1.3,0,2.9,0.2,4.1,0.4 c1.1,0.2,1.5,1.6,1.7,2.5c1.2,4.5,4.7,18.7,5.5,22.4c0.2,0.8,0.6,2,0.1,2.3c-0.4,0.2-2.5,0.9-3.9,1c-0.6,0.1-1.1-0.6-1.4-1.5 c-1.5-4.6-3.5-11.8-5.2-16.6c0,3.7-0.3,10.8-0.4,12c-0.1,1.7-0.4,3.7-1.8,3.9c-1.1,0.2-2.4,0.4-4,0.4c-1.3,0-1.8-0.9-2.4-1.8 c-1-1.4-3.1-4.8-4.1-6.9c0.3,2.3,0.7,4.7,0.9,5.8c0.1,0.8,0,1.5-0.6,1.9c-1,0.7-3.2,1.4-4.1,1.4c-0.8,0-1.5-0.8-1.6-1.6 c-0.7-3.4-1.2-8-1.1-11.1c0-2.8,0-5.9,0.2-8.3c0-0.7,0.3-1.1,0.9-1.4c1.2-0.5,3-0.6,4.7-0.3c0.8,0.1,1,0.8,1.4,1.4 C26.9,25.5,28.9,29.5,30.8,33.4z",
    "mask": "M0,0v64h64V0H0z M47.8,44.3c-0.4,0.2-2.5,0.9-3.9,1c-0.6,0.1-1.1-0.6-1.4-1.5c-1.5-4.6-3.5-11.8-5.2-16.6 c0,3.7-0.3,10.8-0.4,12c-0.1,1.7-0.4,3.7-1.8,3.9c-1.1,0.2-2.4,0.4-4,0.4c-1.3,0-1.8-0.9-2.4-1.8c-1-1.4-3.1-4.8-4.1-6.9 c0.3,2.3,0.7,4.7,0.9,5.8c0.1,0.8,0,1.5-0.6,1.9c-1,0.7-3.2,1.4-4.1,1.4c-0.8,0-1.5-0.8-1.6-1.6c-0.7-3.4-1.2-8-1.1-11.1 c0-2.8,0-5.9,0.2-8.3c0-0.7,0.3-1.1,0.9-1.4c1.2-0.5,3-0.6,4.7-0.3c0.8,0.1,1,0.8,1.4,1.4c1.7,2.8,3.8,6.7,5.7,10.6 c0-6.3,1.9-11.9,3.5-15.3c0.5-1.1,0.9-1.4,1.9-1.4c1.3,0,2.9,0.2,4.1,0.4c1.1,0.2,1.5,1.6,1.7,2.5c1.2,4.5,4.7,18.7,5.5,22.4 C47.8,42.8,48.3,44,47.8,44.3z",
    "color": "#E51937"
  },
  "npm": {
    "icon": "M18.9,20v25.6H32V25.5h7.5V46h5.6V20H18.9z",
    "mask": "M68,0v68H0V0H68z M18.9,20v25.6H32V25.5h7.5V46h5.6V20H18.9z",
    "color": "#cb3837"
  },
  "pinterest": {
    "icon": "M32,16c-8.8,0-16,7.2-16,16c0,6.6,3.9,12.2,9.6,14.7c0-1.1,0-2.5,0.3-3.7 c0.3-1.3,2.1-8.7,2.1-8.7s-0.5-1-0.5-2.5c0-2.4,1.4-4.1,3.1-4.1c1.5,0,2.2,1.1,2.2,2.4c0,1.5-0.9,3.7-1.4,5.7 c-0.4,1.7,0.9,3.1,2.5,3.1c3,0,5.1-3.9,5.1-8.5c0-3.5-2.4-6.1-6.7-6.1c-4.9,0-7.9,3.6-7.9,7.7c0,1.4,0.4,2.4,1.1,3.1 c0.3,0.3,0.3,0.5,0.2,0.9c-0.1,0.3-0.3,1-0.3,1.3c-0.1,0.4-0.4,0.6-0.8,0.4c-2.2-0.9-3.3-3.4-3.3-6.1c0-4.5,3.8-10,11.4-10 c6.1,0,10.1,4.4,10.1,9.2c0,6.3-3.5,11-8.6,11c-1.7,0-3.4-0.9-3.9-2c0,0-0.9,3.7-1.1,4.4c-0.3,1.2-1,2.5-1.6,3.4 c1.4,0.4,3,0.7,4.5,0.7c8.8,0,16-7.2,16-16C48,23.2,40.8,16,32,16z",
    "mask": "M0,0v64h64V0H0z M32,48c-1.6,0-3.1-0.2-4.5-0.7c0.6-1,1.3-2.2,1.6-3.4c0.2-0.7,1.1-4.4,1.1-4.4 c0.6,1.1,2.2,2,3.9,2c5.1,0,8.6-4.7,8.6-11c0-4.7-4-9.2-10.1-9.2c-7.6,0-11.4,5.5-11.4,10c0,2.8,1,5.2,3.3,6.1 c0.4,0.1,0.7,0,0.8-0.4c0.1-0.3,0.2-1,0.3-1.3c0.1-0.4,0.1-0.5-0.2-0.9c-0.6-0.8-1.1-1.7-1.1-3.1c0-4,3-7.7,7.9-7.7 c4.3,0,6.7,2.6,6.7,6.1c0,4.6-2,8.5-5.1,8.5c-1.7,0-2.9-1.4-2.5-3.1c0.5-2,1.4-4.2,1.4-5.7c0-1.3-0.7-2.4-2.2-2.4 c-1.7,0-3.1,1.8-3.1,4.1c0,1.5,0.5,2.5,0.5,2.5s-1.8,7.4-2.1,8.7c-0.3,1.2-0.3,2.6-0.3,3.7C19.9,44.2,16,38.6,16,32 c0-8.8,7.2-16,16-16c8.8,0,16,7.2,16,16C48,40.8,40.8,48,32,48z",
    "color": "#cb2128"
  },
  "rdio": {
    "icon": "M47.3,25.7c-3.2,0.1-7.1-2.4-8.7-3.4c-0.1-0.1-0.3-0.2-0.4-0.2c-0.2-0.1-0.3-0.2-0.5-0.3v9.3h0 c0,0.8-0.2,1.7-0.8,2.6l0,0.1c-1.5,2.4-4.7,3.9-7.7,2.9c-2.9-1-3.7-3.8-2.1-6.3l0-0.1c1.5-2.4,4.7-3.9,7.7-2.9 c0.2,0.1,0.4,0.2,0.6,0.3v-6.8c-1.1-0.3-2.2-0.5-3.4-0.5c-6.9,0-12,5.2-12,11.6v0.1c0,6.4,5.1,11.5,12,11.5c6.9,0,12-5.2,12-11.6 v-0.1c0-0.5,0-1-0.1-1.5C47.5,29.5,49,25.8,47.3,25.7z",
    "mask": "M0,0v64h64V0H0z M43.9,30.5c0.1,0.5,0.1,1,0.1,1.5V32c0,6.4-5.1,11.6-12,11.6c-6.9,0-12-5.1-12-11.5V32 c0-6.4,5.1-11.6,12-11.6c1.2,0,2.3,0.2,3.4,0.5v6.8c-0.2-0.1-0.4-0.2-0.6-0.3c-3-1-6.2,0.4-7.7,2.9l0,0.1c-1.5,2.5-0.8,5.3,2.1,6.3 c3,1,6.2-0.4,7.7-2.9l0-0.1c0.5-0.8,0.8-1.7,0.8-2.6h0v-9.3c0.2,0.1,0.3,0.2,0.5,0.3c0.1,0.1,0.3,0.2,0.4,0.2c1.5,1,5.4,3.5,8.7,3.4 C49,25.8,47.5,29.5,43.9,30.5z",
    "color": "#0475C5"
  },
  "rss": {
    "icon": "M24,36c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4s4-1.8,4-4C28,37.8,26.2,36,24,36z M23,18 c-1.1,0-2,0.9-2,2s0.9,2,2,2c10.5,0,19,8.5,19,19c0,1.1,0.9,2,2,2s2-0.9,2-2C46,28.3,35.7,18,23,18z M23,27c-1.1,0-2,0.9-2,2 s0.9,2,2,2c5.5,0,10,4.5,10,10c0,1.1,0.9,2,2,2s2-0.9,2-2C37,33.3,30.7,27,23,27z",
    "mask": "M0,0v64h64V0H0z M24,44c-2.2,0-4-1.8-4-4c0-2.2,1.8-4,4-4s4,1.8,4,4C28,42.2,26.2,44,24,44z M35,43 c-1.1,0-2-0.9-2-2c0-5.5-4.5-10-10-10c-1.1,0-2-0.9-2-2s0.9-2,2-2c7.7,0,14,6.3,14,14C37,42.1,36.1,43,35,43z M44,43 c-1.1,0-2-0.9-2-2c0-10.5-8.5-19-19-19c-1.1,0-2-0.9-2-2s0.9-2,2-2c12.7,0,23,10.3,23,23C46,42.1,45.1,43,44,43z",
    "color": "#EF8733"
  },
  "sharethis": {
    "icon": "M28.3875,32.0001C28.3875,32.0843 28.3683,32.1632 28.3633,32.2471L37.1647,36.6464C37.9182,36.0083 38.8823,35.61 39.9474,35.61C42.3418,35.6105 44.2821,37.5509 44.2821,39.945C44.2821,42.3418 42.3417,44.2821 39.9474,44.2821C37.551,44.2821 35.6127,42.3417 35.6127,39.945C35.6127,39.8587 35.6319,39.7816 35.6367,39.698L26.8353,35.2984C26.0795,35.9341 25.1177,36.3324 24.0526,36.3324C21.6584,36.3324 19.7179,34.3941 19.7179,32.0001C19.7179,29.6036 21.6584,27.6628 24.0526,27.6628C25.1176,27.6628 26.0798,28.0635 26.8353,28.6992L35.6367,24.2997C35.6319,24.2156 35.6127,24.1365 35.6127,24.0502C35.6127,21.6584 37.551,19.7179 39.9474,19.7179C42.3418,19.7179 44.2821,21.6584 44.2821,24.0502C44.2821,26.4466 42.3417,28.3875 39.9474,28.3875C38.88,28.3875 37.9178,27.9868 37.1647,27.3487L28.3633,31.7506C28.368,31.8347 28.3875,31.9138 28.3875,32.0001Z",
    "mask": "M0,0L64,0L64,64L0,64L0,0ZM28.3875,32.0001C28.3875,32.0843 28.3683,32.1632 28.3633,32.2471L37.1647,36.6464C37.9182,36.0083 38.8823,35.61 39.9474,35.61C42.3418,35.6105 44.2821,37.5509 44.2821,39.945C44.2821,42.3418 42.3417,44.2821 39.9474,44.2821C37.551,44.2821 35.6127,42.3417 35.6127,39.945C35.6127,39.8587 35.6319,39.7816 35.6367,39.698L26.8353,35.2984C26.0795,35.9341 25.1177,36.3324 24.0526,36.3324C21.6584,36.3324 19.7179,34.3941 19.7179,32.0001C19.7179,29.6036 21.6584,27.6628 24.0526,27.6628C25.1176,27.6628 26.0798,28.0635 26.8353,28.6992L35.6367,24.2997C35.6319,24.2156 35.6127,24.1365 35.6127,24.0502C35.6127,21.6584 37.551,19.7179 39.9474,19.7179C42.3418,19.7179 44.2821,21.6584 44.2821,24.0502C44.2821,26.4466 42.3417,28.3875 39.9474,28.3875C38.88,28.3875 37.9178,27.9868 37.1647,27.3487L28.3633,31.7506C28.368,31.8347 28.3875,31.9138 28.3875,32.0001Z",
    "color": "#00BF00"
  },
  "smugmug": {
    "icon": "M25.4,22.9c2.8,0,4.1-1.7,3.9-3.1 c-0.1-1.2-1.3-2.4-3.6-2.4c-1.9,0-3.1,1.4-3.3,2.8C22.3,21.6,23.1,23,25.4,22.9z M39.2,22.6c2.6-0.1,3.8-1.5,3.8-2.8 c0-1.5-1.4-3-3.8-2.8c-1.9,0.2-3,1.5-3.2,2.8C35.9,21.3,36.9,22.7,39.2,22.6z M40.9,28.5c-6.6,0.7-6.9,0.7-19,1 c-5.1,0-4,17.5,6.9,17.5C39.2,47,51.7,27.4,40.9,28.5z M29,43.9c-9.5,0-8.2-11.3-6.6-11.4c11.1-0.4,13.9-0.9,17.8-0.9 C44.3,31.6,36.6,43.9,29,43.9z",
    "mask": "M0,0v64h64V0H0z M36.1,19.8c0.2-1.3,1.3-2.6,3.2-2.8c2.4-0.2,3.8,1.3,3.8,2.8c0,1.3-1.2,2.6-3.8,2.8 C36.9,22.7,35.9,21.3,36.1,19.8z M22.5,20.2c0.2-1.4,1.4-2.8,3.3-2.8c2.3,0,3.5,1.1,3.6,2.4c0.2,1.5-1.1,3.1-3.9,3.1 C23.1,23,22.3,21.6,22.5,20.2z M28.8,47c-10.9,0-12-17.5-6.9-17.5c12.1-0.3,12.5-0.3,19-1C51.7,27.4,39.2,47,28.8,47z M40.3,31.6 c-3.9,0-6.8,0.5-17.8,0.9c-1.6,0.1-2.9,11.4,6.6,11.4C36.6,43.9,44.3,31.6,40.3,31.6z",
    "color": "#8cca1e"
  },
  "soundcloud": {
    "icon": "M43.6,30c-0.6,0-1.2,0.1-1.7,0.3c-0.3-4-3.7-7.1-7.7-7.1c-1,0-2,0.2-2.8,0.5 C31.1,23.9,31,24,31,24.3v13.9c0,0.3,0.2,0.5,0.5,0.5c0,0,12.2,0,12.2,0c2.4,0,4.4-1.9,4.4-4.4C48,31.9,46,30,43.6,30z M27.2,25.1 c-0.7,0-1.2,0.5-1.2,1.1v11.3c0,0.7,0.6,1.2,1.2,1.2c0.7,0,1.2-0.6,1.2-1.2V26.2C28.4,25.6,27.8,25.1,27.2,25.1z M22.2,27.8 c-0.7,0-1.2,0.5-1.2,1.1v8.5c0,0.7,0.6,1.2,1.2,1.2s1.2-0.6,1.2-1.2V29C23.4,28.3,22.9,27.8,22.2,27.8z M17.2,30.2 c-0.7,0-1.2,0.5-1.2,1.1v4.9c0,0.7,0.6,1.2,1.2,1.2c0.7,0,1.2-0.6,1.2-1.2v-4.9C18.5,30.7,17.9,30.2,17.2,30.2z",
    "mask": "M0,0v64h64V0H0z M18.5,36.3c0,0.7-0.6,1.2-1.2,1.2c-0.7,0-1.2-0.6-1.2-1.2v-4.9c0-0.6,0.6-1.1,1.2-1.1 c0.7,0,1.2,0.5,1.2,1.1V36.3z M23.4,37.5c0,0.7-0.6,1.2-1.2,1.2S21,38.2,21,37.5V29c0-0.6,0.6-1.1,1.2-1.1s1.2,0.5,1.2,1.1V37.5z  M28.4,37.5c0,0.7-0.6,1.2-1.2,1.2c-0.7,0-1.2-0.6-1.2-1.2V26.2c0-0.6,0.6-1.1,1.2-1.1c0.7,0,1.2,0.5,1.2,1.1V37.5z M43.6,38.7 c0,0-12.1,0-12.2,0c-0.3,0-0.5-0.2-0.5-0.5V24.3c0-0.3,0.1-0.4,0.4-0.5c0.9-0.3,1.8-0.5,2.8-0.5c4,0,7.4,3.1,7.7,7.1 c0.5-0.2,1.1-0.3,1.7-0.3c2.4,0,4.4,2,4.4,4.4C48,36.8,46,38.7,43.6,38.7z",
    "color": "#FF5700"
  },
  "spotify": {
    "icon": "M32,16c-8.8,0-16,7.2-16,16c0,8.8,7.2,16,16,16c8.8,0,16-7.2,16-16C48,23.2,40.8,16,32,16 M39.3,39.1c-0.3,0.5-0.9,0.6-1.4,0.3c-3.8-2.3-8.5-2.8-14.1-1.5c-0.5,0.1-1.1-0.2-1.2-0.7c-0.1-0.5,0.2-1.1,0.8-1.2 c6.1-1.4,11.3-0.8,15.5,1.8C39.5,38,39.6,38.6,39.3,39.1 M41.3,34.7c-0.4,0.6-1.1,0.8-1.7,0.4c-4.3-2.6-10.9-3.4-15.9-1.9 c-0.7,0.2-1.4-0.2-1.6-0.8c-0.2-0.7,0.2-1.4,0.8-1.6c5.8-1.8,13-0.9,18,2.1C41.5,33.4,41.7,34.1,41.3,34.7 M41.5,30.2 c-5.2-3.1-13.7-3.3-18.6-1.9c-0.8,0.2-1.6-0.2-1.9-1c-0.2-0.8,0.2-1.6,1-1.9c5.7-1.7,15-1.4,21,2.1c0.7,0.4,0.9,1.3,0.5,2.1 C43.1,30.4,42.2,30.6,41.5,30.2",
    "mask": "M39,37.7c-4.2-2.6-9.4-3.2-15.5-1.8c-0.5,0.1-0.9,0.7-0.8,1.2c0.1,0.5,0.7,0.9,1.2,0.7c5.6-1.3,10.3-0.8,14.1,1.5 c0.5,0.3,1.1,0.1,1.4-0.3C39.6,38.6,39.5,38,39,37.7z M40.9,33c-4.9-3-12.2-3.9-18-2.1c-0.7,0.2-1,0.9-0.8,1.6 c0.2,0.7,0.9,1,1.6,0.8c5.1-1.5,11.6-0.8,15.9,1.9c0.6,0.4,1.4,0.2,1.7-0.4C41.7,34.1,41.5,33.4,40.9,33z M0,0v64h64V0H0z M32,48 c-8.8,0-16-7.2-16-16c0-8.8,7.2-16,16-16c8.8,0,16,7.2,16,16C48,40.8,40.8,48,32,48z M43,27.6c-5.9-3.5-15.3-3.9-21-2.1 c-0.8,0.2-1.2,1.1-1,1.9c0.2,0.8,1.1,1.2,1.9,1c4.9-1.5,13.4-1.2,18.6,1.9c0.7,0.4,1.6,0.2,2.1-0.5C43.9,29,43.7,28,43,27.6z",
    "color": "#2EBD59"
  },
  "squarespace": {
    "icon": "M46.2,27.6c-2.4-2.4-6.3-2.4-8.7,0l-9.8,9.8c-0.6,0.6-0.6,1.6,0,2.2c0.6,0.6,1.6,0.6,2.2,0 l9.8-9.8c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.6,9.6c1.2,1.2,3.2,1.2,4.4,0l7.5-7.5C48.6,34,48.6,30,46.2,27.6z  M42.9,30.9c-0.6-0.6-1.6-0.6-2.2,0l-9.8,9.8c-1.2,1.2-3.2,1.2-4.4,0c-0.6-0.6-1.6-0.6-2.2,0c-0.6,0.6-0.6,1.6,0,2.2 c2.4,2.4,6.3,2.4,8.7,0l9.8-9.8C43.5,32.5,43.5,31.5,42.9,30.9z M39.6,21.1c-2.4-2.4-6.3-2.4-8.7,0l-9.8,9.8c-0.6,0.6-0.6,1.6,0,2.2 c0.6,0.6,1.6,0.6,2.2,0l9.8-9.8c1.2-1.2,3.2-1.2,4.4,0c0.6,0.6,1.6,0.6,2.2,0C40.2,22.7,40.2,21.7,39.6,21.1z M36.4,24.4 c-0.6-0.6-1.6-0.6-2.2,0l-9.8,9.8c-1.2,1.2-3.2,1.2-4.4,0c-1.2-1.2-1.2-3.2,0-4.4l9.6-9.6c-1.2-1.2-3.2-1.2-4.4,0l-7.5,7.5 c-2.4,2.4-2.4,6.3,0,8.7c2.4,2.4,6.3,2.4,8.7,0l9.8-9.8C37,25.9,37,25,36.4,24.4z",
    "mask": "M0,0v64h64V0H0z M39.6,21.1c0.6,0.6,0.6,1.6,0,2.2c-0.6,0.6-1.6,0.6-2.2,0c-1.2-1.2-3.2-1.2-4.4,0l-9.8,9.8 c-0.6,0.6-1.6,0.6-2.2,0c-0.6-0.6-0.6-1.6,0-2.2l9.8-9.8C33.3,18.7,37.2,18.7,39.6,21.1z M17.8,36.4c-2.4-2.4-2.4-6.3,0-8.7l7.5-7.5 c1.2-1.2,3.2-1.2,4.4,0L20,29.8c-1.2,1.2-1.2,3.2,0,4.4c1.2,1.2,3.2,1.2,4.4,0l9.8-9.8c0.6-0.6,1.6-0.6,2.2,0c0.6,0.6,0.6,1.6,0,2.2 l-9.8,9.8C24.1,38.8,20.2,38.8,17.8,36.4z M24.4,42.9c-0.6-0.6-0.6-1.6,0-2.2c0.6-0.6,1.6-0.6,2.2,0c1.2,1.2,3.2,1.2,4.4,0l9.8-9.8 c0.6-0.6,1.6-0.6,2.2,0c0.6,0.6,0.6,1.6,0,2.2l-9.8,9.8C30.7,45.3,26.8,45.3,24.4,42.9z M46.2,36.4l-7.5,7.5c-1.2,1.2-3.2,1.2-4.4,0 l9.6-9.6c1.2-1.2,1.2-3.2,0-4.4c-1.2-1.2-3.2-1.2-4.4,0l-9.8,9.8c-0.6,0.6-1.6,0.6-2.2,0c-0.6-0.6-0.6-1.6,0-2.2l9.8-9.8 c2.4-2.4,6.3-2.4,8.7,0C48.6,30,48.6,34,46.2,36.4z",
    "color": "#1C1C1C"
  },
  "tumblr": {
    "icon": "M39.2,41c-0.6,0.3-1.6,0.5-2.4,0.5c-2.4,0.1-2.9-1.7-2.9-3v-9.3h6v-4.5h-6V17c0,0-4.3,0-4.4,0 c-0.1,0-0.2,0.1-0.2,0.2c-0.3,2.3-1.4,6.4-5.9,8.1v3.9h3V39c0,3.4,2.5,8.1,9,8c2.2,0,4.7-1,5.2-1.8L39.2,41z",
    "mask": "M0,0v64h64V0H0z M35.4,47c-6.5,0.1-9-4.7-9-8v-9.8h-3v-3.9c4.6-1.6,5.6-5.7,5.9-8.1c0-0.2,0.1-0.2,0.2-0.2 c0.1,0,4.4,0,4.4,0v7.6h6v4.5h-6v9.3c0,1.3,0.5,3,2.9,3c0.8,0,1.9-0.3,2.4-0.5l1.4,4.3C40.1,46,37.6,47,35.4,47z",
    "color": "#2c4762"
  },
  "twitch": {
    "icon": "M40,25.6h-2.5v7.6H40V25.6z M33,25.6h-2.5v7.6H33V25.6z M20.9,18L19,23.1v20.4h7v3.8h3.8l3.8-3.8h5.7l7.6-7.6V18H20.9z M44.5,34.5L40,39h-7l-3.8,3.8V39h-5.7V20.5h21V34.5z",
    "mask": "M0,0v64h64V0H0z M47,35.8l-7.6,7.6h-5.7l-3.8,3.8H26v-3.8h-7V23.1l1.9-5.1H47V35.8z M29.2,42.8L33,39h7l4.5-4.5 v-14h-21V39h5.7V42.8z M37.5,25.6H40v7.6h-2.5V25.6z M30.5,25.6H33v7.6h-2.5V25.6z",
    "color": "#6441A5"
  },
  "twitter": {
    "icon": "M48,22.1c-1.2,0.5-2.4,0.9-3.8,1c1.4-0.8,2.4-2.1,2.9-3.6c-1.3,0.8-2.7,1.3-4.2,1.6 C41.7,19.8,40,19,38.2,19c-3.6,0-6.6,2.9-6.6,6.6c0,0.5,0.1,1,0.2,1.5c-5.5-0.3-10.3-2.9-13.5-6.9c-0.6,1-0.9,2.1-0.9,3.3 c0,2.3,1.2,4.3,2.9,5.5c-1.1,0-2.1-0.3-3-0.8c0,0,0,0.1,0,0.1c0,3.2,2.3,5.8,5.3,6.4c-0.6,0.1-1.1,0.2-1.7,0.2c-0.4,0-0.8,0-1.2-0.1 c0.8,2.6,3.3,4.5,6.1,4.6c-2.2,1.8-5.1,2.8-8.2,2.8c-0.5,0-1.1,0-1.6-0.1c2.9,1.9,6.4,2.9,10.1,2.9c12.1,0,18.7-10,18.7-18.7 c0-0.3,0-0.6,0-0.8C46,24.5,47.1,23.4,48,22.1z",
    "mask": "M0,0v64h64V0H0z M44.7,25.5c0,0.3,0,0.6,0,0.8C44.7,35,38.1,45,26.1,45c-3.7,0-7.2-1.1-10.1-2.9 c0.5,0.1,1,0.1,1.6,0.1c3.1,0,5.9-1,8.2-2.8c-2.9-0.1-5.3-2-6.1-4.6c0.4,0.1,0.8,0.1,1.2,0.1c0.6,0,1.2-0.1,1.7-0.2 c-3-0.6-5.3-3.3-5.3-6.4c0,0,0-0.1,0-0.1c0.9,0.5,1.9,0.8,3,0.8c-1.8-1.2-2.9-3.2-2.9-5.5c0-1.2,0.3-2.3,0.9-3.3 c3.2,4,8.1,6.6,13.5,6.9c-0.1-0.5-0.2-1-0.2-1.5c0-3.6,2.9-6.6,6.6-6.6c1.9,0,3.6,0.8,4.8,2.1c1.5-0.3,2.9-0.8,4.2-1.6 c-0.5,1.5-1.5,2.8-2.9,3.6c1.3-0.2,2.6-0.5,3.8-1C47.1,23.4,46,24.5,44.7,25.5z",
    "color": "#00aced"
  },
  "vevo": {
    "icon": "M43,21c-4.5,0-5.4,2.7-6.8,4.6c0,0-3.7,5.6-5.1,7.7l-3-12.3H20l5.1,20.6c1.1,3.7,4.1,3.4,4.1,3.4 c2.1,0,3.6-1.1,5-3.1L48,21C48,21,43.2,21,43,21z",
    "mask": "M0,0v64h64V0H0z M34.2,41.9c-1.4,2.1-2.9,3.1-5,3.1c0,0-3,0.2-4.1-3.4L20,21h8.1l3,12.3c1.4-2.1,5.1-7.7,5.1-7.7 c1.4-1.9,2.2-4.6,6.8-4.6c0.2,0,5,0,5,0L34.2,41.9z",
    "color": "#ED1A3B"
  },
  "vimeo": {
    "icon": "M47,25c-0.1,2.9-2.2,6.9-6.1,12c-4.1,5.3-7.5,8-10.4,8c-1.7,0-3.2-1.6-4.4-4.8 c-0.8-3-1.6-5.9-2.4-8.9c-0.9-3.2-1.9-4.8-2.9-4.8c-0.2,0-1,0.5-2.4,1.4L17,26c1.5-1.3,2.9-2.6,4.4-3.9c2-1.7,3.5-2.6,4.4-2.7 c2.3-0.2,3.8,1.4,4.3,4.8c0.6,3.7,1,6,1.2,6.9c0.7,3.1,1.4,4.6,2.2,4.6c0.6,0,1.6-1,2.8-3c1.3-2,1.9-3.5,2-4.5 c0.2-1.7-0.5-2.6-2-2.6c-0.7,0-1.5,0.2-2.2,0.5c1.5-4.8,4.3-7.2,8.4-7C45.7,19.1,47.2,21.1,47,25z",
    "mask": "M0,0v64h64V0H0z M40.9,37c-4.1,5.3-7.5,8-10.4,8c-1.7,0-3.2-1.6-4.4-4.8c-0.8-3-1.6-5.9-2.4-8.9 c-0.9-3.2-1.9-4.8-2.9-4.8c-0.2,0-1,0.5-2.4,1.4L17,26c1.5-1.3,2.9-2.6,4.4-3.9c2-1.7,3.5-2.6,4.4-2.7c2.3-0.2,3.8,1.4,4.3,4.8 c0.6,3.7,1,6,1.2,6.9c0.7,3.1,1.4,4.6,2.2,4.6c0.6,0,1.6-1,2.8-3c1.3-2,1.9-3.5,2-4.5c0.2-1.7-0.5-2.6-2-2.6c-0.7,0-1.5,0.2-2.2,0.5 c1.5-4.8,4.3-7.2,8.4-7c3.1,0.1,4.5,2.1,4.4,6C46.9,27.9,44.8,31.9,40.9,37z",
    "color": "#1ab7ea"
  },
  "vine": {
    "icon": "M45.2,31.9c-0.8,0.2-1.5,0.3-2.2,0.3c-3.8,0-6.7-2.6-6.7-7.2c0-2.3,0.9-3.4,2.1-3.4 c1.2,0,2,1.1,2,3.2c0,1.2-0.3,2.5-0.6,3.3c0,0,1.2,2,4.4,1.4c0.7-1.5,1-3.5,1-5.2c0-4.6-2.3-7.3-6.6-7.3c-4.4,0-7,3.4-7,7.9 c0,4.4,2.1,8.2,5.5,10c-1.4,2.9-3.3,5.4-5.2,7.3c-3.5-4.2-6.6-9.8-7.9-20.7h-5.1c2.4,18.1,9.4,23.9,11.2,25c1.1,0.6,2,0.6,2.9,0.1 c1.5-0.9,6-5.4,8.6-10.7c1.1,0,2.3-0.1,3.6-0.4V31.9z",
    "mask": "M0,0v64h64V0H0z M38.4,21.5c-1.2,0-2.1,1.2-2.1,3.4c0,4.6,2.9,7.2,6.7,7.2c0.7,0,1.4-0.1,2.2-0.3v3.6 c-1.3,0.3-2.5,0.4-3.6,0.4c-2.5,5.3-7,9.8-8.6,10.7c-1,0.5-1.9,0.6-2.9-0.1c-1.9-1.1-8.9-6.9-11.2-25H24c1.3,10.9,4.4,16.5,7.9,20.7 c1.9-1.9,3.7-4.4,5.2-7.3c-3.4-1.7-5.5-5.5-5.5-10c0-4.5,2.6-7.9,7-7.9c4.3,0,6.6,2.7,6.6,7.3c0,1.7-0.4,3.7-1,5.2 c-3.2,0.6-4.4-1.4-4.4-1.4c0.2-0.8,0.6-2.1,0.6-3.3C40.3,22.6,39.5,21.5,38.4,21.5z",
    "color": "#00BF8F"
  },
  "vsco": {
    "icon": "M32,16c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C34.5,17.1,33.4,16,32,16z M18.5,29.5c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C20.9,30.6,19.8,29.5,18.5,29.5z M25.2,22.8c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C27.7,23.9,26.6,22.8,25.2,22.8z M38.7,27.6c1.4,0,2.5-1.1,2.5-2.5c0-1.4-1.1-2.5-2.5-2.5c-1.4,0-2.5,1.1-2.5,2.5 C36.2,26.5,37.3,27.6,38.7,27.6z M25.1,36.2c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C27.6,37.3,26.5,36.2,25.1,36.2z M31.9,34.4c1.4,0,2.5-1.1,2.5-2.5c0-1.4-1.1-2.5-2.5-2.5c-1.4,0-2.5,1.1-2.5,2.5 C29.5,33.3,30.6,34.4,31.9,34.4z M45.5,29.5c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C48,30.6,46.9,29.5,45.5,29.5z M32,43.1c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C34.5,44.2,33.4,43.1,32,43.1z M38.8,36.3c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5c1.4,0,2.5-1.1,2.5-2.5 C41.2,37.4,40.1,36.3,38.8,36.3z",
    "mask": "M0,0v64h64V0H0z M18.5,34.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C20.9,33.4,19.8,34.5,18.5,34.5z M25.1,41.1c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C27.6,40,26.5,41.1,25.1,41.1z M25.2,27.7c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C27.7,26.6,26.6,27.7,25.2,27.7z M32,48c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C34.5,46.9,33.4,48,32,48z M29.5,31.9c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5c0,1.4-1.1,2.5-2.5,2.5 C30.6,34.4,29.5,33.3,29.5,31.9z M32,20.9c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C34.5,19.8,33.4,20.9,32,20.9z M38.7,22.7c1.4,0,2.5,1.1,2.5,2.5c0,1.4-1.1,2.5-2.5,2.5c-1.4,0-2.5-1.1-2.5-2.5 C36.2,23.8,37.3,22.7,38.7,22.7z M38.8,41.2c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C41.2,40.1,40.1,41.2,38.8,41.2z M45.5,34.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5 C48,33.4,46.9,34.5,45.5,34.5z",
    "color": "#83878A"
  },
  "yelp": {
    "icon": "M29.5,35.7c0.5-0.1,0.9-0.6,0.9-1.2c0-0.6-0.3-1.2-0.8-1.4c0,0-1.5-0.6-1.5-0.6 c-5-2.1-5.2-2.1-5.5-2.1c-0.4,0-0.7,0.2-1,0.6c-0.5,0.8-0.7,3.3-0.5,5c0.1,0.6,0.2,1,0.3,1.3c0.2,0.4,0.5,0.6,0.9,0.6 c0.2,0,0.4,0,5.1-1.5C27.5,36.4,29.5,35.7,29.5,35.7z M32.2,37.6c-0.6-0.2-1.2-0.1-1.5,0.4c0,0-1,1.2-1,1.2 c-3.5,4.1-3.7,4.3-3.7,4.5c-0.1,0.1-0.1,0.3-0.1,0.4c0,0.2,0.1,0.4,0.3,0.6c0.8,1,4.7,2.4,6,2.2c0.4-0.1,0.7-0.3,0.9-0.7 C33,46.1,33,45.9,33,41c0,0,0-2.2,0-2.2C33.1,38.3,32.7,37.8,32.2,37.6z M32.3,16.8c-0.1-0.4-0.4-0.7-0.9-0.8 c-1.3-0.3-6.5,1.1-7.5,2.1c-0.3,0.3-0.4,0.7-0.3,1.1c0.2,0.3,6.5,10.4,6.5,10.4c0.9,1.5,1.7,1.3,2,1.2c0.3-0.1,1-0.3,0.9-2.1 C33,26.6,32.4,17.3,32.3,16.8z M36.9,33.4C36.9,33.4,36.8,33.5,36.9,33.4c0.2-0.1,0.7-0.2,1.5-0.4c5.3-1.3,5.5-1.3,5.7-1.5 c0.3-0.2,0.5-0.6,0.5-1c0,0,0,0,0,0c-0.1-1.3-2.4-4.7-3.5-5.2c-0.4-0.2-0.8-0.2-1.1,0c-0.2,0.1-0.4,0.3-3.2,4.2c0,0-1.3,1.7-1.3,1.8 c-0.3,0.4-0.3,1,0,1.5C35.8,33.3,36.3,33.6,36.9,33.4z M44.4,38.6c-0.2-0.1-0.3-0.2-5-1.7c0,0-2-0.7-2.1-0.7c-0.5-0.2-1.1,0-1.4,0.5 c-0.4,0.5-0.5,1.1-0.1,1.6l0.8,1.3c2.8,4.5,3,4.8,3.2,5c0.3,0.2,0.7,0.3,1.1,0.1c1.2-0.5,3.7-3.7,3.9-5 C44.8,39.2,44.7,38.8,44.4,38.6z",
    "mask": "M0,0v64h64V0H0z M22.4,37.9c-0.4,0-0.7-0.2-0.9-0.6c-0.1-0.3-0.2-0.7-0.3-1.3c-0.2-1.7,0-4.2,0.5-5 c0.2-0.4,0.6-0.6,1-0.6c0.3,0,0.5,0.1,5.5,2.1c0,0,1.5,0.6,1.5,0.6c0.5,0.2,0.9,0.7,0.8,1.4c0,0.6-0.4,1.1-0.9,1.2 c0,0-2.1,0.7-2.1,0.7C22.8,37.9,22.7,37.9,22.4,37.9z M33,41c0,4.9,0,5-0.1,5.3c-0.1,0.4-0.4,0.6-0.9,0.7c-1.2,0.2-5.1-1.2-6-2.2 c-0.2-0.2-0.3-0.4-0.3-0.6c0-0.2,0-0.3,0.1-0.4c0.1-0.2,0.2-0.4,3.7-4.5c0,0,1-1.2,1-1.2c0.3-0.4,1-0.6,1.5-0.4 c0.6,0.2,0.9,0.7,0.9,1.2C33,38.8,33,41,33,41z M32.2,30.8c-0.3,0.1-1,0.3-2-1.2c0,0-6.4-10.1-6.5-10.4c-0.1-0.3,0-0.7,0.3-1.1 c1-1,6.1-2.4,7.5-2.1c0.4,0.1,0.7,0.4,0.9,0.8c0.1,0.4,0.7,9.8,0.8,11.9C33.2,30.5,32.4,30.7,32.2,30.8z M35.4,31.3 c0,0,1.3-1.8,1.3-1.8c2.8-3.9,3-4.1,3.2-4.2c0.3-0.2,0.7-0.2,1.1,0c1.1,0.5,3.4,3.9,3.5,5.2c0,0,0,0,0,0c0,0.4-0.1,0.8-0.5,1 c-0.2,0.1-0.4,0.2-5.7,1.5c-0.8,0.2-1.3,0.3-1.6,0.4c0,0,0,0,0,0c-0.5,0.1-1.1-0.1-1.4-0.6C35.1,32.3,35.1,31.7,35.4,31.3z  M44.7,39.6c-0.2,1.3-2.7,4.5-3.9,5c-0.4,0.2-0.8,0.1-1.1-0.1c-0.2-0.2-0.4-0.5-3.2-5l-0.8-1.3c-0.3-0.5-0.3-1.1,0.1-1.6 c0.4-0.5,0.9-0.6,1.4-0.5c0,0,2.1,0.7,2.1,0.7c4.6,1.5,4.8,1.6,5,1.7C44.7,38.8,44.8,39.2,44.7,39.6z",
    "color": "#B90C04"
  },
  "youtube": {
    "icon": "M46.7,26c0,0-0.3-2.1-1.2-3c-1.1-1.2-2.4-1.2-3-1.3C38.3,21.4,32,21.4,32,21.4h0 c0,0-6.3,0-10.5,0.3c-0.6,0.1-1.9,0.1-3,1.3c-0.9,0.9-1.2,3-1.2,3S17,28.4,17,30.9v2.3c0,2.4,0.3,4.9,0.3,4.9s0.3,2.1,1.2,3 c1.1,1.2,2.6,1.2,3.3,1.3c2.4,0.2,10.2,0.3,10.2,0.3s6.3,0,10.5-0.3c0.6-0.1,1.9-0.1,3-1.3c0.9-0.9,1.2-3,1.2-3s0.3-2.4,0.3-4.9 v-2.3C47,28.4,46.7,26,46.7,26z M28.9,35.9l0-8.4l8.1,4.2L28.9,35.9z",
    "mask": "M0,0v64h64V0H0z M47,33.1c0,2.4-0.3,4.9-0.3,4.9s-0.3,2.1-1.2,3c-1.1,1.2-2.4,1.2-3,1.3 C38.3,42.5,32,42.6,32,42.6s-7.8-0.1-10.2-0.3c-0.7-0.1-2.2-0.1-3.3-1.3c-0.9-0.9-1.2-3-1.2-3S17,35.6,17,33.1v-2.3 c0-2.4,0.3-4.9,0.3-4.9s0.3-2.1,1.2-3c1.1-1.2,2.4-1.2,3-1.3c4.2-0.3,10.5-0.3,10.5-0.3h0c0,0,6.3,0,10.5,0.3c0.6,0.1,1.9,0.1,3,1.3 c0.9,0.9,1.2,3,1.2,3s0.3,2.4,0.3,4.9V33.1z M28.9,35.9l8.1-4.2l-8.1-4.2L28.9,35.9z",
    "color": "#ff3333"
  }
}

},{}],52:[function(require,module,exports){
module.exports={
  "version": "0.0.1"
}
},{}],53:[function(require,module,exports){
var AppView, CloudFileManager, CloudFileManagerClient, CloudFileManagerUIMenu, getHashParam;

AppView = React.createFactory(require('./views/app-view'));

CloudFileManagerUIMenu = (require('./ui')).CloudFileManagerUIMenu;

CloudFileManagerClient = (require('./client')).CloudFileManagerClient;

getHashParam = require('./utils/get-hash-param');

CloudFileManager = (function() {
  function CloudFileManager(options) {
    this.DefaultMenu = CloudFileManagerUIMenu.DefaultMenu;
    this.client = new CloudFileManagerClient();
    this.appOptions = {};
  }

  CloudFileManager.prototype.init = function(appOptions) {
    this.appOptions = appOptions;
    this.appOptions.hashParams = {
      sharedContentId: getHashParam("shared"),
      fileParams: getHashParam("file"),
      copyParams: getHashParam("copy"),
      newInFolderParams: getHashParam("newInFolder")
    };
    return this.client.setAppOptions(this.appOptions);
  };

  CloudFileManager.prototype.createFrame = function(appOptions, appElemId, eventCallback) {
    this.appOptions = appOptions;
    if (eventCallback == null) {
      eventCallback = null;
    }
    this.appOptions.usingIframe = true;
    this.appOptions.appOrMenuElemId = appElemId;
    this.init(this.appOptions);
    this.client.listen(eventCallback);
    return this._renderApp(document.getElementById(appElemId));
  };

  CloudFileManager.prototype.clientConnect = function(eventCallback) {
    var e;
    try {
      if (this.appOptions.appOrMenuElemId != null) {
        this._renderApp(document.getElementById(this.appOptions.appOrMenuElemId));
      } else {
        this._createHiddenApp();
      }
    } catch (error) {
      e = error;
      console.error("Unable render app: " + e);
    }
    this.client.listen(eventCallback);
    this.client.connect();
    this.client.processUrlParams();
    if (window.parent) {
      return window.parent.postMessage({
        type: "cfm::iframedClientConnected"
      }, "*");
    }
  };

  CloudFileManager.prototype._createHiddenApp = function() {
    var anchor;
    anchor = document.createElement("div");
    document.body.appendChild(anchor);
    return this._renderApp(anchor);
  };

  CloudFileManager.prototype._renderApp = function(anchor) {
    this.appOptions.client = this.client;
    ReactDOM.render(AppView(this.appOptions), anchor);
    this.client.iframe = anchor.getElementsByTagName('iframe')[0];
    return this.client.rendered();
  };

  return CloudFileManager;

})();

module.exports = new CloudFileManager();


},{"./client":54,"./ui":68,"./utils/get-hash-param":69,"./views/app-view":83}],54:[function(require,module,exports){
var CloudContent, CloudFileManagerClient, CloudFileManagerClientEvent, CloudFileManagerUI, CloudMetadata, DocumentStoreProvider, DocumentStoreShareProvider, GoogleDriveProvider, LaraProvider, LocalFileProvider, LocalStorageProvider, PostMessageProvider, ProviderInterface, ReadOnlyProvider, URLProvider, base64Array, cloudContentFactory, getQueryParam, isString, tr,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  hasProp = {}.hasOwnProperty;

tr = require('./utils/translate');

isString = require('./utils/is-string');

base64Array = require('base64-js');

getQueryParam = require('./utils/get-query-param');

CloudFileManagerUI = (require('./ui')).CloudFileManagerUI;

LocalStorageProvider = require('./providers/localstorage-provider');

ReadOnlyProvider = require('./providers/readonly-provider');

GoogleDriveProvider = require('./providers/google-drive-provider');

LaraProvider = require('./providers/lara-provider');

DocumentStoreProvider = require('./providers/document-store-provider');

DocumentStoreShareProvider = require('./providers/document-store-share-provider');

LocalFileProvider = require('./providers/local-file-provider');

PostMessageProvider = require('./providers/post-message-provider');

URLProvider = require('./providers/url-provider');

ProviderInterface = (require('./providers/provider-interface')).ProviderInterface;

cloudContentFactory = (require('./providers/provider-interface')).cloudContentFactory;

CloudContent = (require('./providers/provider-interface')).CloudContent;

CloudMetadata = (require('./providers/provider-interface')).CloudMetadata;

CloudFileManagerClientEvent = (function() {
  CloudFileManagerClientEvent.id = 0;

  CloudFileManagerClientEvent.events = {};

  function CloudFileManagerClientEvent(type1, data1, callback1, state1) {
    this.type = type1;
    this.data = data1 != null ? data1 : {};
    this.callback = callback1 != null ? callback1 : null;
    this.state = state1 != null ? state1 : {};
    CloudFileManagerClientEvent.id++;
    this.id = CloudFileManagerClientEvent.id;
  }

  CloudFileManagerClientEvent.prototype.postMessage = function(iframe) {
    var eventData, message;
    if (this.callback) {
      CloudFileManagerClientEvent.events[this.id] = this;
    }
    eventData = _.clone(this.data);
    delete eventData.client;
    message = {
      type: "cfm::event",
      eventId: this.id,
      eventType: this.type,
      eventData: eventData
    };
    return iframe.postMessage(message, "*");
  };

  return CloudFileManagerClientEvent;

})();

CloudFileManagerClient = (function() {
  function CloudFileManagerClient(options) {
    this.shouldAutoSave = bind(this.shouldAutoSave, this);
    this.state = {
      availableProviders: []
    };
    this._listeners = [];
    this._resetState();
    this._ui = new CloudFileManagerUI(this);
    this.providers = {};
    this.urlProvider = new URLProvider();
  }

  CloudFileManagerClient.prototype.setAppOptions = function(appOptions1) {
    var Provider, allProviders, availableProviders, base, base1, base2, base3, i, j, len, len1, provider, providerList, providerName, providerOptions, providerSpec, readableMimetypes, ref, ref1, ref2, requestedProviders, shareProvider;
    this.appOptions = appOptions1 != null ? appOptions1 : {};
    if ((base = this.appOptions).wrapFileContent == null) {
      base.wrapFileContent = true;
    }
    CloudContent.wrapFileContent = this.appOptions.wrapFileContent;
    allProviders = {};
    providerList = [LocalStorageProvider, ReadOnlyProvider, GoogleDriveProvider, LaraProvider, DocumentStoreProvider, LocalFileProvider, PostMessageProvider];
    for (i = 0, len = providerList.length; i < len; i++) {
      Provider = providerList[i];
      if (Provider.Available()) {
        allProviders[Provider.Name] = Provider;
      }
    }
    if (!this.appOptions.providers) {
      this.appOptions.providers = [];
      for (providerName in allProviders) {
        if (!hasProp.call(allProviders, providerName)) continue;
        appOptions.providers.push(providerName);
      }
    }
    CloudMetadata.Extension = this.appOptions.extension;
    CloudMetadata.ReadableExtensions = this.appOptions.readableExtensions || [];
    if (CloudMetadata.Extension) {
      CloudMetadata.ReadableExtensions.push(CloudMetadata.Extension);
    }
    readableMimetypes = this.appOptions.readableMimeTypes || [];
    readableMimetypes.push(this.appOptions.mimeType);
    requestedProviders = this.appOptions.providers.slice();
    if (getQueryParam("saveSecondaryFileViaPostMessage")) {
      requestedProviders.push('postMessage');
    }
    availableProviders = [];
    shareProvider = null;
    for (j = 0, len1 = requestedProviders.length; j < len1; j++) {
      providerSpec = requestedProviders[j];
      ref = isString(providerSpec) ? [providerSpec, {}] : [providerSpec.name, providerSpec], providerName = ref[0], providerOptions = ref[1];
      if (providerOptions.mimeType == null) {
        providerOptions.mimeType = this.appOptions.mimeType;
      }
      providerOptions.readableMimetypes = readableMimetypes;
      if (!providerName) {
        this.alert("Invalid provider spec - must either be string or object with name property");
      } else {
        if (providerSpec.createProvider) {
          allProviders[providerName] = providerSpec.createProvider(ProviderInterface);
        }
        if (allProviders[providerName]) {
          Provider = allProviders[providerName];
          provider = new Provider(providerOptions, this);
          this.providers[providerName] = provider;
          if (providerName === DocumentStoreProvider.Name) {
            shareProvider = new DocumentStoreShareProvider(this, provider);
          }
          if (provider.urlDisplayName) {
            this.providers[provider.urlDisplayName] = provider;
          }
          availableProviders.push(provider);
        } else {
          this.alert("Unknown provider: " + providerName);
        }
      }
    }
    this._setState({
      availableProviders: availableProviders,
      shareProvider: shareProvider
    });
    (base1 = this.appOptions).ui || (base1.ui = {});
    (base2 = this.appOptions.ui).windowTitleSuffix || (base2.windowTitleSuffix = document.title);
    (base3 = this.appOptions.ui).windowTitleSeparator || (base3.windowTitleSeparator = ' - ');
    this._setWindowTitle();
    this._ui.init(this.appOptions.ui);
    if (this.appOptions.autoSaveInterval) {
      this.autoSave(this.appOptions.autoSaveInterval);
    }
    cloudContentFactory.setEnvelopeMetadata({
      cfmVersion: '0.0.1',
      appName: this.appOptions.appName || "",
      appVersion: this.appOptions.appVersion || "",
      appBuildNum: this.appOptions.appBuildNum || ""
    });
    this.newFileOpensInNewTab = ((ref1 = this.appOptions.ui) != null ? ref1.hasOwnProperty('newFileOpensInNewTab') : void 0) ? this.appOptions.ui.newFileOpensInNewTab : true;
    this.newFileAddsNewToQuery = (ref2 = this.appOptions.ui) != null ? ref2.newFileAddsNewToQuery : void 0;
    return this._startPostMessageListener();
  };

  CloudFileManagerClient.prototype.setProviderOptions = function(name, newOptions) {
    var i, key, len, provider, ref, results;
    ref = this.state.availableProviders;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      provider = ref[i];
      if (provider.name === name) {
        if (provider.options == null) {
          provider.options = {};
        }
        for (key in newOptions) {
          provider.options[key] = newOptions[key];
        }
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  CloudFileManagerClient.prototype.connect = function() {
    return this._event('connected', {
      client: this
    });
  };

  CloudFileManagerClient.prototype.processUrlParams = function() {
    var folder, hashParams, i, len, provider, providerName, providerParams, ref, ref1, ref2;
    hashParams = this.appOptions.hashParams;
    if (hashParams.sharedContentId) {
      return this.openSharedContent(hashParams.sharedContentId);
    } else if (hashParams.fileParams) {
      if (hashParams.fileParams.indexOf("http") === 0) {
        return this.openUrlFile(hashParams.fileParams);
      } else {
        ref = hashParams.fileParams.split(':'), providerName = ref[0], providerParams = ref[1];
        return this.openProviderFile(providerName, providerParams);
      }
    } else if (hashParams.copyParams) {
      return this.openCopiedFile(hashParams.copyParams);
    } else if (hashParams.newInFolderParams) {
      ref1 = hashParams.newInFolderParams.split(':'), providerName = ref1[0], folder = ref1[1];
      return this.createNewInFolder(providerName, folder);
    } else {
      ref2 = this.state.availableProviders;
      for (i = 0, len = ref2.length; i < len; i++) {
        provider = ref2[i];
        if (provider.handleUrlParams()) {
          return;
        }
      }
      return this.ready();
    }
  };

  CloudFileManagerClient.prototype.ready = function() {
    return this._event('ready');
  };

  CloudFileManagerClient.prototype.rendered = function() {
    return this._event('rendered', {
      client: this
    });
  };

  CloudFileManagerClient.prototype.listen = function(listener) {
    if (listener) {
      return this._listeners.push(listener);
    }
  };

  CloudFileManagerClient.prototype.log = function(event, eventData) {
    if (this.appOptions.log) {
      return this.appOptions.log(event, eventData);
    }
  };

  CloudFileManagerClient.prototype.autoProvider = function(capability) {
    var i, len, provider, ref;
    ref = this.state.availableProviders;
    for (i = 0, len = ref.length; i < len; i++) {
      provider = ref[i];
      if (provider.canAuto(capability)) {
        return provider;
      }
    }
  };

  CloudFileManagerClient.prototype.appendMenuItem = function(item) {
    this._ui.appendMenuItem(item);
    return this;
  };

  CloudFileManagerClient.prototype.prependMenuItem = function(item) {
    this._ui.prependMenuItem(item);
    return this;
  };

  CloudFileManagerClient.prototype.replaceMenuItem = function(key, item) {
    this._ui.replaceMenuItem(key, item);
    return this;
  };

  CloudFileManagerClient.prototype.insertMenuItemBefore = function(key, item) {
    this._ui.insertMenuItemBefore(key, item);
    return this;
  };

  CloudFileManagerClient.prototype.insertMenuItemAfter = function(key, item) {
    this._ui.insertMenuItemAfter(key, item);
    return this;
  };

  CloudFileManagerClient.prototype.setMenuBarInfo = function(info) {
    return this._ui.setMenuBarInfo(info);
  };

  CloudFileManagerClient.prototype.newFile = function(callback) {
    if (callback == null) {
      callback = null;
    }
    this._closeCurrentFile();
    this._resetState();
    window.location.hash = "";
    return this._event('newedFile', {
      content: ""
    });
  };

  CloudFileManagerClient.prototype.newFileDialog = function(callback) {
    if (callback == null) {
      callback = null;
    }
    if (this.newFileOpensInNewTab) {
      return window.open(this.getCurrentUrl(this.newFileAddsNewToQuery ? "#new" : null), '_blank');
    } else if (this.state.dirty) {
      if (this._autoSaveInterval && this.state.metadata) {
        this.save();
        return this.newFile();
      } else {
        return this.confirm(tr('~CONFIRM.NEW_FILE'), (function(_this) {
          return function() {
            return _this.newFile();
          };
        })(this));
      }
    } else {
      return this.newFile();
    }
  };

  CloudFileManagerClient.prototype.openFile = function(metadata, callback) {
    var ref;
    if (callback == null) {
      callback = null;
    }
    if (metadata != null ? (ref = metadata.provider) != null ? ref.can('load', metadata) : void 0 : void 0) {
      this._event('willOpenFile', {
        op: "openFile"
      });
      return metadata.provider.load(metadata, (function(_this) {
        return function(err, content) {
          if (err) {
            return _this.alert(err, function() {
              return _this.ready();
            });
          }
          _this._closeCurrentFile();
          _this._fileOpened(content, metadata, {
            openedContent: content.clone()
          }, _this._getHashParams(metadata));
          if (typeof callback === "function") {
            callback(content, metadata);
          }
          return metadata.provider.fileOpened(content, metadata);
        };
      })(this));
    } else {
      return this.openFileDialog(callback);
    }
  };

  CloudFileManagerClient.prototype.openFileDialog = function(callback) {
    var showDialog;
    if (callback == null) {
      callback = null;
    }
    showDialog = (function(_this) {
      return function() {
        return _this._ui.openFileDialog(function(metadata) {
          return _this.openFile(metadata, callback);
        });
      };
    })(this);
    if (!this.state.dirty) {
      return showDialog();
    } else {
      return this.confirm(tr('~CONFIRM.OPEN_FILE'), showDialog);
    }
  };

  CloudFileManagerClient.prototype.closeFile = function(callback) {
    if (callback == null) {
      callback = null;
    }
    this._closeCurrentFile();
    this._resetState();
    window.location.hash = "";
    this._event('closedFile', {
      content: ""
    });
    return typeof callback === "function" ? callback() : void 0;
  };

  CloudFileManagerClient.prototype.closeFileDialog = function(callback) {
    if (callback == null) {
      callback = null;
    }
    if (!this.state.dirty) {
      return this.closeFile(callback);
    } else {
      return this.confirm(tr('~CONFIRM.CLOSE_FILE'), (function(_this) {
        return function() {
          return _this.closeFile(callback);
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.importData = function(data, callback) {
    if (callback == null) {
      callback = null;
    }
    this._event('importedData', data);
    return typeof callback === "function" ? callback(data) : void 0;
  };

  CloudFileManagerClient.prototype.importDataDialog = function(callback) {
    if (callback == null) {
      callback = null;
    }
    return this._ui.importDataDialog((function(_this) {
      return function(data) {
        return _this.importData(data, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.readLocalFile = function(file, callback) {
    var reader;
    if (callback == null) {
      callback = null;
    }
    reader = new FileReader();
    reader.onload = function(loaded) {
      return typeof callback === "function" ? callback({
        name: file.name,
        content: loaded.target.result
      }) : void 0;
    };
    return reader.readAsText(file);
  };

  CloudFileManagerClient.prototype.openLocalFile = function(file, callback) {
    if (callback == null) {
      callback = null;
    }
    this._event('willOpenFile', {
      op: "openLocalFile"
    });
    return this.readLocalFile(file, (function(_this) {
      return function(data) {
        var content, metadata;
        content = cloudContentFactory.createEnvelopedCloudContent(data.content);
        metadata = new CloudMetadata({
          name: data.name,
          type: CloudMetadata.File
        });
        _this._fileOpened(content, metadata, {
          openedContent: content.clone()
        });
        return typeof callback === "function" ? callback(content, metadata) : void 0;
      };
    })(this));
  };

  CloudFileManagerClient.prototype.importLocalFile = function(file, callback) {
    if (callback == null) {
      callback = null;
    }
    return this.readLocalFile(file, (function(_this) {
      return function(data) {
        return _this.importData(data, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.openSharedContent = function(id) {
    var ref;
    this._event('willOpenFile', {
      op: "openSharedContent"
    });
    return (ref = this.state.shareProvider) != null ? ref.loadSharedContent(id, (function(_this) {
      return function(err, content, metadata) {
        if (err) {
          return _this.alert(err, function() {
            return _this.ready();
          });
        }
        return _this._fileOpened(content, metadata, {
          overwritable: false,
          openedContent: content.clone()
        });
      };
    })(this)) : void 0;
  };

  CloudFileManagerClient.prototype.parseUrlAuthorizeAndOpen = function() {
    var provider, providerName, providerParams, ref, ref1;
    if (((ref = this.appOptions.hashParams) != null ? ref.fileParams : void 0) != null) {
      ref1 = this.appOptions.hashParams.fileParams.split(':'), providerName = ref1[0], providerParams = ref1[1];
      provider = this.providers[providerName];
      if (provider) {
        return provider.authorize((function(_this) {
          return function() {
            return _this.openProviderFile(providerName(providerParams));
          };
        })(this));
      }
    }
  };

  CloudFileManagerClient.prototype.confirmAuthorizeAndOpen = function(provider, providerParams) {
    return this.confirm(tr("~CONFIRM.AUTHORIZE_OPEN"), (function(_this) {
      return function() {
        return provider.authorize(function() {
          _this._event('willOpenFile', {
            op: "confirmAuthorizeAndOpen"
          });
          return provider.openSaved(providerParams, function(err, content, metadata) {
            if (err) {
              return _this.alert(err);
            }
            _this._fileOpened(content, metadata, {
              openedContent: content.clone()
            }, _this._getHashParams(metadata));
            return provider.fileOpened(content, metadata);
          });
        });
      };
    })(this));
  };

  CloudFileManagerClient.prototype.openProviderFile = function(providerName, providerParams) {
    var provider;
    provider = this.providers[providerName];
    if (provider) {
      return provider.authorized((function(_this) {
        return function(authorized) {
          if (authorized || !provider.isAuthorizationRequired()) {
            _this._event('willOpenFile', {
              op: "openProviderFile"
            });
            return provider.openSaved(providerParams, function(err, content, metadata) {
              if (err) {
                return _this.alert(err, function() {
                  return _this.ready();
                });
              }
              _this._fileOpened(content, metadata, {
                openedContent: content.clone()
              }, _this._getHashParams(metadata));
              return provider.fileOpened(content, metadata);
            });
          } else {
            return _this.confirmAuthorizeAndOpen(provider, providerParams);
          }
        };
      })(this));
    } else {
      return this.alert(tr("~ALERT.NO_PROVIDER"), (function(_this) {
        return function() {
          return _this.ready();
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.openUrlFile = function(url) {
    return this.urlProvider.openFileFromUrl(url, (function(_this) {
      return function(err, content, metadata) {
        _this._event('willOpenFile', {
          op: "openUrlFile"
        });
        if (err) {
          return _this.alert(err, function() {
            return _this.ready();
          });
        }
        return _this._fileOpened(content, metadata, {
          openedContent: content.clone()
        }, _this._getHashParams(metadata));
      };
    })(this));
  };

  CloudFileManagerClient.prototype.createNewInFolder = function(providerName, folder) {
    var provider;
    provider = this.providers[providerName];
    if (provider && provider.can('setFolder', this.state.metadata)) {
      if (this.state.metadata == null) {
        this.state.metadata = new CloudMetadata({
          type: CloudMetadata.File,
          provider: provider
        });
      }
      this.state.metadata.parent = new CloudMetadata({
        type: CloudMetadata.Folder,
        providerData: {
          id: folder
        }
      });
      this._ui.editInitialFilename();
    }
    return this._event('newedFile', {
      content: ""
    });
  };

  CloudFileManagerClient.prototype.setInitialFilename = function(filename) {
    this.state.metadata.rename(filename);
    return this.save();
  };

  CloudFileManagerClient.prototype.isSaveInProgress = function() {
    return this.state.saving != null;
  };

  CloudFileManagerClient.prototype.confirmAuthorizeAndSave = function(stringContent, callback) {
    return this.confirm(tr("~CONFIRM.AUTHORIZE_SAVE"), (function(_this) {
      return function() {
        return _this.state.metadata.provider.authorize(function() {
          return _this.saveFile(stringContent, _this.state.metadata, callback);
        });
      };
    })(this));
  };

  CloudFileManagerClient.prototype.save = function(callback) {
    if (callback == null) {
      callback = null;
    }
    return this._event('getContent', {
      shared: this._sharedMetadata()
    }, (function(_this) {
      return function(stringContent) {
        return _this.saveContent(stringContent, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.saveContent = function(stringContent, callback) {
    var provider, ref;
    if (callback == null) {
      callback = null;
    }
    provider = ((ref = this.state.metadata) != null ? ref.provider : void 0) || this.autoProvider('save');
    if (provider != null) {
      return provider.authorized((function(_this) {
        return function(isAuthorized) {
          if (isAuthorized || !provider.isAuthorizationRequired()) {
            return _this.saveFile(stringContent, _this.state.metadata, callback);
          } else {
            return _this.confirmAuthorizeAndSave(stringContent, callback);
          }
        };
      })(this));
    } else {
      return this.saveFileDialog(stringContent, callback);
    }
  };

  CloudFileManagerClient.prototype.saveFile = function(stringContent, metadata, callback) {
    var ref;
    if (callback == null) {
      callback = null;
    }
    if (metadata != null ? (ref = metadata.provider) != null ? ref.can('resave', metadata) : void 0 : void 0) {
      return this.saveFileNoDialog(stringContent, metadata, callback);
    } else {
      return this.saveFileDialog(stringContent, callback);
    }
  };

  CloudFileManagerClient.prototype.saveFileNoDialog = function(stringContent, metadata, callback) {
    var currentContent;
    if (callback == null) {
      callback = null;
    }
    this._setState({
      saving: metadata
    });
    currentContent = this._createOrUpdateCurrentContent(stringContent, metadata);
    return metadata.provider.save(currentContent, metadata, (function(_this) {
      return function(err, statusCode) {
        if (err) {
          metadata.autoSaveDisabled = true;
          _this._setState({
            metadata: metadata,
            saving: null
          });
          if (statusCode === 403) {
            return _this.confirmAuthorizeAndSave(stringContent, callback);
          } else {
            return _this.alert(err);
          }
        }
        if (_this.state.metadata !== metadata) {
          _this._closeCurrentFile();
        }
        if (metadata.autoSaveDisabled != null) {
          delete metadata.autoSaveDisabled;
        }
        _this._fileChanged('savedFile', currentContent, metadata, {
          saved: true
        }, _this._getHashParams(metadata));
        return typeof callback === "function" ? callback(currentContent, metadata) : void 0;
      };
    })(this));
  };

  CloudFileManagerClient.prototype.saveFileDialog = function(stringContent, callback) {
    if (stringContent == null) {
      stringContent = null;
    }
    if (callback == null) {
      callback = null;
    }
    return this._ui.saveFileDialog((function(_this) {
      return function(metadata) {
        return _this._dialogSave(stringContent, metadata, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.saveFileAsDialog = function(stringContent, callback) {
    if (stringContent == null) {
      stringContent = null;
    }
    if (callback == null) {
      callback = null;
    }
    return this._ui.saveFileAsDialog((function(_this) {
      return function(metadata) {
        return _this._dialogSave(stringContent, metadata, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.createCopy = function(stringContent, callback) {
    var saveAndOpenCopy;
    if (stringContent == null) {
      stringContent = null;
    }
    if (callback == null) {
      callback = null;
    }
    saveAndOpenCopy = (function(_this) {
      return function(stringContent) {
        var ref;
        return _this.saveCopiedFile(stringContent, (ref = _this.state.metadata) != null ? ref.name : void 0, function(err, copyParams) {
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          window.open(_this.getCurrentUrl("#copy=" + copyParams));
          return typeof callback === "function" ? callback(copyParams) : void 0;
        });
      };
    })(this);
    if (stringContent === null) {
      return this._event('getContent', {}, function(stringContent) {
        return saveAndOpenCopy(stringContent);
      });
    } else {
      return saveAndOpenCopy(stringContent);
    }
  };

  CloudFileManagerClient.prototype.saveCopiedFile = function(stringContent, name, callback) {
    var copyNumber, e, key, maxCopyNumber, prefix, ref, value;
    try {
      prefix = 'cfm-copy::';
      maxCopyNumber = 0;
      ref = window.localStorage;
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        if (key.substr(0, prefix.length) === prefix) {
          copyNumber = parseInt(key.substr(prefix.length), 10);
          maxCopyNumber = Math.max(maxCopyNumber, copyNumber);
        }
      }
      maxCopyNumber++;
      value = JSON.stringify({
        name: (name != null ? name.length : void 0) > 0 ? "Copy of " + name : "Copy of Untitled Document",
        stringContent: stringContent
      });
      window.localStorage.setItem("" + prefix + maxCopyNumber, value);
      return typeof callback === "function" ? callback(null, maxCopyNumber) : void 0;
    } catch (error) {
      e = error;
      return callback("Unable to temporarily save copied file");
    }
  };

  CloudFileManagerClient.prototype.openCopiedFile = function(copyParams) {
    var content, copied, e, key, metadata;
    this._event('willOpenFile', {
      op: "openCopiedFile"
    });
    try {
      key = "cfm-copy::" + copyParams;
      copied = JSON.parse(window.localStorage.getItem(key));
      content = cloudContentFactory.createEnvelopedCloudContent(copied.stringContent);
      metadata = new CloudMetadata({
        name: copied.name,
        type: CloudMetadata.File
      });
      window.location.hash = "";
      this._fileOpened(content, metadata, {
        dirty: true,
        openedContent: content.clone()
      });
      return window.localStorage.removeItem(key);
    } catch (error) {
      e = error;
      return callback("Unable to load copied file");
    }
  };

  CloudFileManagerClient.prototype._sharedMetadata = function() {
    var ref;
    return ((ref = this.state.currentContent) != null ? ref.getSharedMetadata() : void 0) || {};
  };

  CloudFileManagerClient.prototype.shareGetLink = function() {
    return this._ui.shareDialog(this);
  };

  CloudFileManagerClient.prototype.shareUpdate = function() {
    return this.share((function(_this) {
      return function() {
        return _this.alert(tr("~SHARE_UPDATE.MESSAGE"), tr("~SHARE_UPDATE.TITLE"));
      };
    })(this));
  };

  CloudFileManagerClient.prototype.toggleShare = function(callback) {
    if (this.isShared()) {
      return this.unshare(callback);
    } else {
      return this.share(callback);
    }
  };

  CloudFileManagerClient.prototype.isShared = function() {
    var ref, ref1;
    return ((ref = this.state.currentContent) != null ? ref.get("sharedDocumentId") : void 0) && !((ref1 = this.state.currentContent) != null ? ref1.get("isUnshared") : void 0);
  };

  CloudFileManagerClient.prototype.canEditShared = function() {
    var accessKeys, ref, ref1, ref2, shareEditKey;
    accessKeys = ((ref = this.state.currentContent) != null ? ref.get("accessKeys") : void 0) || {};
    shareEditKey = (ref1 = this.state.currentContent) != null ? ref1.get("shareEditKey") : void 0;
    return (shareEditKey || accessKeys.readWrite) && !((ref2 = this.state.currentContent) != null ? ref2.get("isUnshared") : void 0);
  };

  CloudFileManagerClient.prototype.setShareState = function(shared, callback) {
    var sharingMetadata;
    if (this.state.shareProvider) {
      sharingMetadata = this.state.shareProvider.getSharingMetadata(shared);
      return this._event('getContent', {
        shared: sharingMetadata
      }, (function(_this) {
        return function(stringContent) {
          var currentContent, sharedContent;
          _this._setState({
            sharing: shared
          });
          sharedContent = cloudContentFactory.createEnvelopedCloudContent(stringContent);
          sharedContent.addMetadata(sharingMetadata);
          currentContent = _this._createOrUpdateCurrentContent(stringContent, _this.state.metadata);
          sharedContent.set('docName', currentContent.get('docName'));
          if (shared) {
            currentContent.remove('isUnshared');
          } else {
            currentContent.set('isUnshared', true);
          }
          return _this.state.shareProvider.share(shared, currentContent, sharedContent, _this.state.metadata, function(err, sharedContentId) {
            if (err) {
              return _this.alert(err);
            }
            return typeof callback === "function" ? callback(null, sharedContentId, currentContent) : void 0;
          });
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.share = function(callback) {
    return this.setShareState(true, (function(_this) {
      return function(err, sharedContentId, currentContent) {
        _this._fileChanged('sharedFile', currentContent, _this.state.metadata);
        return typeof callback === "function" ? callback(null, sharedContentId) : void 0;
      };
    })(this));
  };

  CloudFileManagerClient.prototype.unshare = function(callback) {
    return this.setShareState(false, (function(_this) {
      return function(err, sharedContentId, currentContent) {
        _this._fileChanged('unsharedFile', currentContent, _this.state.metadata);
        return typeof callback === "function" ? callback(null) : void 0;
      };
    })(this));
  };

  CloudFileManagerClient.prototype.revertToShared = function(callback) {
    var id, ref;
    if (callback == null) {
      callback = null;
    }
    id = (ref = this.state.currentContent) != null ? ref.get("sharedDocumentId") : void 0;
    if (id && (this.state.shareProvider != null)) {
      return this.state.shareProvider.loadSharedContent(id, (function(_this) {
        return function(err, content, metadata) {
          var docName;
          if (err) {
            return _this.alert(err);
          }
          _this.state.currentContent.copyMetadataTo(content);
          if (!metadata.name && (docName = content.get('docName'))) {
            metadata.name = docName;
          }
          _this._fileOpened(content, metadata, {
            dirty: true,
            openedContent: content.clone()
          });
          return typeof callback === "function" ? callback(null) : void 0;
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.revertToSharedDialog = function(callback) {
    var ref;
    if (callback == null) {
      callback = null;
    }
    if (((ref = this.state.currentContent) != null ? ref.get("sharedDocumentId") : void 0) && (this.state.shareProvider != null)) {
      return this.confirm(tr("~CONFIRM.REVERT_TO_SHARED_VIEW"), (function(_this) {
        return function() {
          return _this.revertToShared(callback);
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.downloadDialog = function(callback) {
    if (callback == null) {
      callback = null;
    }
    return this._event('getContent', {
      shared: this._sharedMetadata()
    }, (function(_this) {
      return function(content) {
        var envelopedContent, ref, ref1;
        envelopedContent = cloudContentFactory.createEnvelopedCloudContent(content);
        if ((ref = _this.state.currentContent) != null) {
          ref.copyMetadataTo(envelopedContent);
        }
        return _this._ui.downloadDialog((ref1 = _this.state.metadata) != null ? ref1.name : void 0, envelopedContent, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.getDownloadBlob = function(content, includeShareInfo, mimeType) {
    var contentToSave, json, ref;
    if (mimeType == null) {
      mimeType = 'text/plain';
    }
    if (typeof content === "string") {
      if (mimeType.indexOf("image") >= 0) {
        contentToSave = base64Array.toByteArray(content);
      } else {
        contentToSave = content;
      }
    } else if (includeShareInfo) {
      contentToSave = JSON.stringify(content.getContent());
    } else {
      json = content.clone().getContent();
      delete json.sharedDocumentId;
      delete json.shareEditKey;
      delete json.isUnshared;
      delete json.accessKeys;
      if (((ref = json.metadata) != null ? ref.shared : void 0) != null) {
        delete json.metadata.shared;
      }
      contentToSave = JSON.stringify(json);
    }
    return new Blob([contentToSave], {
      type: mimeType
    });
  };

  CloudFileManagerClient.prototype.getDownloadUrl = function(content, includeShareInfo, mimeType) {
    var wURL;
    if (mimeType == null) {
      mimeType = 'text/plain';
    }
    wURL = window.URL || window.webkitURL;
    if (wURL) {
      return wURL.createObjectURL(this.getDownloadBlob(content, includeShareInfo, mimeType));
    }
  };

  CloudFileManagerClient.prototype.rename = function(metadata, newName, callback) {
    var _rename, dirty, ref, ref1, ref2;
    dirty = this.state.dirty;
    _rename = (function(_this) {
      return function(metadata) {
        var ref;
        if ((ref = _this.state.currentContent) != null) {
          ref.addMetadata({
            docName: metadata.name
          });
        }
        _this._fileChanged('renamedFile', _this.state.currentContent, metadata, {
          dirty: dirty
        }, _this._getHashParams(metadata));
        return typeof callback === "function" ? callback(newName) : void 0;
      };
    })(this);
    if (newName !== ((ref = this.state.metadata) != null ? ref.name : void 0)) {
      if ((ref1 = this.state.metadata) != null ? (ref2 = ref1.provider) != null ? ref2.can('rename', metadata) : void 0 : void 0) {
        return this.state.metadata.provider.rename(this.state.metadata, newName, (function(_this) {
          return function(err, metadata) {
            if (err) {
              return _this.alert(err);
            }
            return _rename(metadata);
          };
        })(this));
      } else {
        if (metadata) {
          metadata.name = newName;
          metadata.filename = newName;
        } else {
          metadata = new CloudMetadata({
            name: newName,
            type: CloudMetadata.File
          });
        }
        return _rename(metadata);
      }
    }
  };

  CloudFileManagerClient.prototype.renameDialog = function(callback) {
    var ref;
    if (callback == null) {
      callback = null;
    }
    return this._ui.renameDialog((ref = this.state.metadata) != null ? ref.name : void 0, (function(_this) {
      return function(newName) {
        return _this.rename(_this.state.metadata, newName, callback);
      };
    })(this));
  };

  CloudFileManagerClient.prototype.revertToLastOpened = function(callback) {
    if (callback == null) {
      callback = null;
    }
    this._event('willOpenFile', {
      op: "revertToLastOpened"
    });
    if ((this.state.openedContent != null) && this.state.metadata) {
      return this._fileOpened(this.state.openedContent, this.state.metadata, {
        openedContent: this.state.openedContent.clone()
      });
    }
  };

  CloudFileManagerClient.prototype.revertToLastOpenedDialog = function(callback) {
    if (callback == null) {
      callback = null;
    }
    if ((this.state.openedContent != null) && this.state.metadata) {
      return this.confirm(tr('~CONFIRM.REVERT_TO_LAST_OPENED'), (function(_this) {
        return function() {
          return _this.revertToLastOpened(callback);
        };
      })(this));
    } else {
      return typeof callback === "function" ? callback('No initial opened version was found for the currently active file') : void 0;
    }
  };

  CloudFileManagerClient.prototype.saveSecondaryFileAsDialog = function(stringContent, extension, mimeType, callback) {
    var data, metadata, provider;
    if ((provider = this.autoProvider('export'))) {
      metadata = {
        provider: provider,
        extension: extension,
        mimeType: mimeType
      };
      return this.saveSecondaryFile(stringContent, metadata, callback);
    } else {
      data = {
        content: stringContent,
        extension: extension,
        mimeType: mimeType
      };
      return this._ui.saveSecondaryFileAsDialog(data, (function(_this) {
        return function(metadata) {
          if (extension) {
            metadata.filename = CloudMetadata.newExtension(metadata.filename, extension);
          }
          if (mimeType) {
            metadata.mimeType = mimeType;
          }
          return _this.saveSecondaryFile(stringContent, metadata, callback);
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.saveSecondaryFile = function(stringContent, metadata, callback) {
    var ref;
    if (callback == null) {
      callback = null;
    }
    if (metadata != null ? (ref = metadata.provider) != null ? ref.can('export', metadata) : void 0 : void 0) {
      return metadata.provider.saveAsExport(stringContent, metadata, (function(_this) {
        return function(err, statusCode) {
          if (err) {
            return _this.alert(err);
          }
          return typeof callback === "function" ? callback(stringContent, metadata) : void 0;
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype.dirty = function(isDirty) {
    if (isDirty == null) {
      isDirty = true;
    }
    this._setState({
      dirty: isDirty,
      saved: this.state.saved && !isDirty
    });
    if (window.self !== window.top) {
      return window.parent.postMessage({
        type: "cfm::setDirty",
        isDirty: isDirty
      }, "*");
    }
  };

  CloudFileManagerClient.prototype.shouldAutoSave = function() {
    var ref, ref1, ref2;
    return this.state.dirty && !((ref = this.state.metadata) != null ? ref.autoSaveDisabled : void 0) && !this.isSaveInProgress() && ((ref1 = this.state.metadata) != null ? (ref2 = ref1.provider) != null ? ref2.can('resave', this.state.metadata) : void 0 : void 0);
  };

  CloudFileManagerClient.prototype.autoSave = function(interval) {
    if (this._autoSaveInterval) {
      clearInterval(this._autoSaveInterval);
    }
    if (interval > 1000) {
      interval = Math.round(interval / 1000);
    }
    if (interval > 0) {
      return this._autoSaveInterval = setInterval(((function(_this) {
        return function() {
          if (_this.shouldAutoSave()) {
            return _this.save();
          }
        };
      })(this)), interval * 1000);
    }
  };

  CloudFileManagerClient.prototype.isAutoSaving = function() {
    return this._autoSaveInterval != null;
  };

  CloudFileManagerClient.prototype.changeLanguage = function(newLangCode, callback) {
    if (callback) {
      if (!this.state.dirty) {
        return callback(newLangCode);
      } else {
        return this.confirm(tr('~CONFIRM.CHANGE_LANGUAGE'), function() {
          return callback(newLangCode);
        });
      }
    }
  };

  CloudFileManagerClient.prototype.showBlockingModal = function(modalProps) {
    return this._ui.showBlockingModal(modalProps);
  };

  CloudFileManagerClient.prototype.hideBlockingModal = function() {
    return this._ui.hideBlockingModal();
  };

  CloudFileManagerClient.prototype.getCurrentUrl = function(queryString) {
    var suffix;
    if (queryString == null) {
      queryString = null;
    }
    suffix = queryString != null ? "?" + queryString : "";
    return "" + document.location.origin + document.location.pathname + suffix;
  };

  CloudFileManagerClient.prototype.removeQueryParams = function(params) {
    var hash, i, key, len, re, url;
    url = window.location.href;
    hash = url.split('#');
    for (i = 0, len = params.length; i < len; i++) {
      key = params[i];
      re = new RegExp("([?&])" + key + "=.*?(&|#|$)(.*)", "g");
      if (re.test(url)) {
        hash[0] = hash[0].replace(re, '$1$3').replace(/(&|\?)$/, '');
      }
    }
    url = hash[0] + (hash[1] != null ? '#' + hash[1] : '');
    if (url !== window.location.href) {
      return history.pushState({
        originalUrl: window.location.href
      }, '', url);
    }
  };

  CloudFileManagerClient.prototype.confirm = function(message, callback) {
    return this.confirmDialog({
      message: message,
      callback: callback
    });
  };

  CloudFileManagerClient.prototype.confirmDialog = function(params) {
    return this._ui.confirmDialog(params);
  };

  CloudFileManagerClient.prototype.alert = function(message, titleOrCallback, callback) {
    if (_.isFunction(titleOrCallback)) {
      callback = titleOrCallback;
      titleOrCallback = null;
    }
    return this._ui.alertDialog(message, titleOrCallback || tr("~CLIENT_ERROR.TITLE"), callback);
  };

  CloudFileManagerClient.prototype._dialogSave = function(stringContent, metadata, callback) {
    if (stringContent !== null) {
      return this.saveFileNoDialog(stringContent, metadata, callback);
    } else {
      return this._event('getContent', {
        shared: this._sharedMetadata()
      }, (function(_this) {
        return function(stringContent) {
          return _this.saveFileNoDialog(stringContent, metadata, callback);
        };
      })(this));
    }
  };

  CloudFileManagerClient.prototype._fileChanged = function(type, content, metadata, additionalState, hashParams) {
    if (additionalState == null) {
      additionalState = {};
    }
    if (hashParams == null) {
      hashParams = null;
    }
    if (metadata != null) {
      if (metadata.overwritable == null) {
        metadata.overwritable = true;
      }
    }
    this._updateState(content, metadata, additionalState, hashParams);
    return this._event(type, {
      content: content != null ? content.getClientContent() : void 0,
      shared: this._sharedMetadata()
    });
  };

  CloudFileManagerClient.prototype._fileOpened = function(content, metadata, additionalState, hashParams) {
    var contentType, eventData;
    if (additionalState == null) {
      additionalState = {};
    }
    if (hashParams == null) {
      hashParams = null;
    }
    eventData = {
      content: content != null ? content.getClientContent() : void 0
    };
    this._updateState(content, metadata, additionalState, hashParams);
    contentType = metadata.mimeType || metadata.contentType;
    if (contentType) {
      eventData.metadata = {
        contentType: contentType
      };
    }
    return this._event('openedFile', eventData, (function(_this) {
      return function(iError, iSharedMetadata) {
        if (iError) {
          return _this.alert(iError, function() {
            return _this.ready();
          });
        }
        if (metadata != null) {
          if (metadata.overwritable == null) {
            metadata.overwritable = true;
          }
        }
        if (!_this.appOptions.wrapFileContent) {
          content.addMetadata(iSharedMetadata);
        }
        _this._updateState(content, metadata, additionalState, hashParams);
        return _this.ready();
      };
    })(this));
  };

  CloudFileManagerClient.prototype._updateState = function(content, metadata, additionalState, hashParams) {
    var key, state, value;
    if (additionalState == null) {
      additionalState = {};
    }
    if (hashParams == null) {
      hashParams = null;
    }
    state = {
      currentContent: content,
      metadata: metadata,
      saving: null,
      saved: false,
      dirty: !additionalState.saved && (content != null ? content.requiresConversion() : void 0)
    };
    for (key in additionalState) {
      if (!hasProp.call(additionalState, key)) continue;
      value = additionalState[key];
      state[key] = value;
    }
    this._setWindowTitle(metadata != null ? metadata.name : void 0);
    if (hashParams !== null) {
      window.location.hash = hashParams;
    }
    return this._setState(state);
  };

  CloudFileManagerClient.prototype._event = function(type, data, eventCallback) {
    var event, i, len, listener, ref, ref1, skipPostMessage;
    if (data == null) {
      data = {};
    }
    if (eventCallback == null) {
      eventCallback = null;
    }
    event = new CloudFileManagerClientEvent(type, data, eventCallback, this.state);
    ref = this._listeners;
    for (i = 0, len = ref.length; i < len; i++) {
      listener = ref[i];
      listener(event);
    }
    skipPostMessage = type === "renamedFile";
    if (((ref1 = this.appOptions) != null ? ref1.sendPostMessageClientEvents : void 0) && this.iframe && !skipPostMessage) {
      return event.postMessage(this.iframe.contentWindow);
    }
  };

  CloudFileManagerClient.prototype._setState = function(options) {
    var key, value;
    for (key in options) {
      if (!hasProp.call(options, key)) continue;
      value = options[key];
      this.state[key] = value;
    }
    return this._event('stateChanged');
  };

  CloudFileManagerClient.prototype._resetState = function() {
    return this._setState({
      openedContent: null,
      currentContent: null,
      metadata: null,
      dirty: false,
      saving: null,
      saved: false
    });
  };

  CloudFileManagerClient.prototype._closeCurrentFile = function() {
    var ref, ref1;
    if ((ref = this.state.metadata) != null ? (ref1 = ref.provider) != null ? ref1.can('close', this.state.metadata) : void 0 : void 0) {
      return this.state.metadata.provider.close(this.state.metadata);
    }
  };

  CloudFileManagerClient.prototype._createOrUpdateCurrentContent = function(stringContent, metadata) {
    var currentContent;
    if (metadata == null) {
      metadata = null;
    }
    if (this.state.currentContent != null) {
      currentContent = this.state.currentContent;
      currentContent.setText(stringContent);
    } else {
      currentContent = cloudContentFactory.createEnvelopedCloudContent(stringContent);
    }
    if (metadata != null) {
      currentContent.addMetadata({
        docName: metadata.name
      });
    }
    return currentContent;
  };

  CloudFileManagerClient.prototype._setWindowTitle = function(name) {
    var ref, ref1;
    if ((ref = this.appOptions) != null ? (ref1 = ref.ui) != null ? ref1.windowTitleSuffix : void 0 : void 0) {
      return document.title = "" + ((name != null ? name.length : void 0) > 0 ? name : tr("~MENUBAR.UNTITLED_DOCUMENT")) + this.appOptions.ui.windowTitleSeparator + this.appOptions.ui.windowTitleSuffix;
    }
  };

  CloudFileManagerClient.prototype._getHashParams = function(metadata) {
    var openSavedParams, ref, ref1;
    if ((metadata != null ? (ref = metadata.provider) != null ? ref.canOpenSaved() : void 0 : void 0) && ((openSavedParams = metadata != null ? (ref1 = metadata.provider) != null ? ref1.getOpenSavedParams(metadata) : void 0 : void 0) != null)) {
      return "#file=" + (metadata.provider.urlDisplayName || metadata.provider.name) + ":" + (encodeURIComponent(openSavedParams));
    } else if ((metadata != null ? metadata.provider : void 0) instanceof URLProvider && window.location.hash.indexOf("#file=http") === 0) {
      return window.location.hash;
    } else {
      return "";
    }
  };

  CloudFileManagerClient.prototype._startPostMessageListener = function() {
    return $(window).on('message', (function(_this) {
      return function(e) {
        var data, event, oe, ref, ref1, reply;
        oe = e.originalEvent;
        data = oe.data || {};
        reply = function(type, params) {
          var message;
          if (params == null) {
            params = {};
          }
          message = _.merge({}, params, {
            type: type
          });
          return oe.source.postMessage(message, oe.origin);
        };
        switch ((ref = oe.data) != null ? ref.type : void 0) {
          case 'cfm::getCommands':
            return reply('cfm::commands', {
              commands: ['cfm::autosave', 'cfm::event', 'cfm::event:reply', 'cfm::setDirty', 'cfm::iframedClientConnected']
            });
          case 'cfm::autosave':
            if (_this.shouldAutoSave()) {
              return _this.save(function() {
                return reply('cfm::autosaved', {
                  saved: true
                });
              });
            } else {
              return reply('cfm::autosaved', {
                saved: false
              });
            }
            break;
          case 'cfm::event':
            return _this._event(data.eventType, data.eventData, function() {
              var callbackArgs;
              callbackArgs = JSON.stringify(Array.prototype.slice.call(arguments));
              return reply('cfm::event:reply', {
                eventId: data.eventId,
                callbackArgs: callbackArgs
              });
            });
          case 'cfm::event:reply':
            event = CloudFileManagerClientEvent.events[data.eventId];
            return event != null ? (ref1 = event.callback) != null ? ref1.apply(_this, JSON.parse(data.callbackArgs)) : void 0 : void 0;
          case 'cfm::setDirty':
            return _this.dirty(data.isDirty);
          case 'cfm::iframedClientConnected':
            return _this.processUrlParams();
        }
      };
    })(this));
  };

  return CloudFileManagerClient;

})();

module.exports = {
  CloudFileManagerClientEvent: CloudFileManagerClientEvent,
  CloudFileManagerClient: CloudFileManagerClient
};


},{"./providers/document-store-provider":56,"./providers/document-store-share-provider":57,"./providers/google-drive-provider":59,"./providers/lara-provider":60,"./providers/local-file-provider":61,"./providers/localstorage-provider":62,"./providers/post-message-provider":64,"./providers/provider-interface":65,"./providers/readonly-provider":66,"./providers/url-provider":67,"./ui":68,"./utils/get-query-param":70,"./utils/is-string":72,"./utils/translate":80,"base64-js":1}],55:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = true  // [CC 2016-12-05] type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("FileSaver.js", function() {
    return saveAs;
  });
}

},{}],56:[function(require,module,exports){
var CloudMetadata, DocumentStoreAuthorizationDialog, DocumentStoreProvider, DocumentStoreUrl, PatchableContent, ProviderInterface, button, cloudContentFactory, div, getHashParam, getQueryParam, isString, jiff, pako, ref, span, tr,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = React.DOM, div = ref.div, button = ref.button, span = ref.span;

getQueryParam = require('../utils/get-query-param');

getHashParam = require('../utils/get-hash-param');

tr = require('../utils/translate');

isString = require('../utils/is-string');

jiff = require('jiff');

pako = require('pako');

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

DocumentStoreUrl = require('./document-store-url');

PatchableContent = require('./patchable-content');

DocumentStoreAuthorizationDialog = React.createFactory(React.createClass({
  displayName: 'DocumentStoreAuthorizationDialog',
  getInitialState: function() {
    return {
      docStoreAvailable: false
    };
  },
  componentWillMount: function() {
    return this.props.provider._onDocStoreLoaded((function(_this) {
      return function() {
        return _this.setState({
          docStoreAvailable: true
        });
      };
    })(this));
  },
  authenticate: function() {
    return this.props.provider.authorize();
  },
  render: function() {
    return div({
      className: 'document-store-auth'
    }, div({
      className: 'document-store-concord-logo'
    }, ''), div({
      className: 'document-store-footer'
    }, this.state.docStoreAvailable ? button({
      onClick: this.authenticate
    }, 'Login to Concord') : 'Trying to log into Concord...'));
  }
}));

DocumentStoreProvider = (function(superClass) {
  extend(DocumentStoreProvider, superClass);

  function DocumentStoreProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    this.options.deprecationPhase = 3;
    DocumentStoreProvider.__super__.constructor.call(this, {
      name: DocumentStoreProvider.Name,
      displayName: this.options.displayName || (tr('~PROVIDER.DOCUMENT_STORE')),
      urlDisplayName: this.options.urlDisplayName,
      capabilities: {
        save: this.isNotDeprecated('save'),
        resave: this.isNotDeprecated('save'),
        "export": false,
        load: this.isNotDeprecated('load'),
        list: this.isNotDeprecated('list'),
        remove: this.isNotDeprecated('remove'),
        rename: this.isNotDeprecated('rename'),
        close: false
      }
    });
    this.urlParams = {
      documentServer: getQueryParam("documentServer"),
      recordid: getQueryParam("recordid"),
      runKey: getQueryParam("runKey"),
      docName: getQueryParam("doc"),
      docOwner: getQueryParam("owner")
    };
    this.removableQueryParams = ['recordid', 'doc', 'owner'];
    this.docStoreUrl = new DocumentStoreUrl(this.urlParams.documentServer);
    this.user = null;
    this.savedContent = new PatchableContent(this.options.patchObjectHash);
  }

  DocumentStoreProvider.Name = 'documentStore';

  DocumentStoreProvider.prototype.can = function(capability, metadata) {
    var ref1;
    if (((capability === 'save') || (capability === 'resave')) && (metadata != null ? (ref1 = metadata.providerData) != null ? ref1.owner : void 0 : void 0)) {
      return false;
    }
    return DocumentStoreProvider.__super__.can.call(this, capability, metadata);
  };

  DocumentStoreProvider.prototype.isAuthorizationRequired = function() {
    return !(this.urlParams.runKey || (this.urlParams.docName && this.urlParams.docOwner));
  };

  DocumentStoreProvider.prototype.authorized = function(authCallback) {
    this.authCallback = authCallback;
    if (this.authCallback) {
      if (this.user) {
        return this.authCallback(true);
      } else {
        return this._checkLogin();
      }
    } else {
      return this.user !== null;
    }
  };

  DocumentStoreProvider.prototype.authorize = function(completionCallback) {
    return this._showLoginWindow(completionCallback);
  };

  DocumentStoreProvider.prototype._onDocStoreLoaded = function(docStoreLoadedCallback) {
    this.docStoreLoadedCallback = docStoreLoadedCallback;
    if (this._docStoreLoaded) {
      return this.docStoreLoadedCallback();
    }
  };

  DocumentStoreProvider.prototype._checkLogin = function() {
    var loggedIn;
    loggedIn = (function(_this) {
      return function(user) {
        var ref1;
        _this.user = user;
        _this._docStoreLoaded = true;
        if (typeof _this.docStoreLoadedCallback === "function") {
          _this.docStoreLoadedCallback();
        }
        if (user) {
          if ((ref1 = _this._loginWindow) != null) {
            ref1.close();
          }
        }
        if (_this.authCallback) {
          return _this.authCallback(user !== null);
        }
      };
    })(this);
    return $.ajax({
      dataType: 'json',
      url: this.docStoreUrl.checkLogin(),
      xhrFields: {
        withCredentials: true
      },
      success: function(data) {
        return loggedIn(data);
      },
      error: function() {
        return loggedIn(null);
      }
    });
  };

  DocumentStoreProvider.prototype._loginWindow = null;

  DocumentStoreProvider.prototype._showLoginWindow = function(completionCallback) {
    var computeScreenLocation, height, poll, pollAction, position, width, windowFeatures;
    if (this._loginWindow && !this._loginWindow.closed) {
      this._loginWindow.focus();
    } else {
      computeScreenLocation = function(w, h) {
        var height, left, screenLeft, screenTop, top, width;
        screenLeft = window.screenLeft || screen.left;
        screenTop = window.screenTop || screen.top;
        width = window.innerWidth || document.documentElement.clientWidth || screen.width;
        height = window.innerHeight || document.documentElement.clientHeight || screen.height;
        left = ((width / 2) - (w / 2)) + screenLeft;
        top = ((height / 2) - (h / 2)) + screenTop;
        return {
          left: left,
          top: top
        };
      };
      width = 1000;
      height = 480;
      position = computeScreenLocation(width, height);
      windowFeatures = ['width=' + width, 'height=' + height, 'top=' + position.top || 200, 'left=' + position.left || 200, 'dependent=yes', 'resizable=no', 'location=no', 'dialog=yes', 'menubar=no'];
      this._loginWindow = window.open(this.docStoreUrl.authorize(), 'auth', windowFeatures.join());
      if (this._loginWindow) {
        pollAction = (function(_this) {
          return function() {
            var e;
            try {
              if (_this._loginWindow.location.host === window.location.host) {
                clearInterval(poll);
                _this._loginWindow.close();
                _this._checkLogin();
                if (completionCallback) {
                  return completionCallback();
                }
              }
            } catch (error) {
              e = error;
            }
          };
        })(this);
        poll = setInterval(pollAction, 200);
      }
    }
    return this._loginWindow;
  };

  DocumentStoreProvider.prototype.renderAuthorizationDialog = function() {
    return DocumentStoreAuthorizationDialog({
      provider: this,
      authCallback: this.authCallback
    });
  };

  DocumentStoreProvider.prototype.renderUser = function() {
    if (this.user) {
      return span({}, span({
        className: 'document-store-icon'
      }), this.user.name);
    } else {
      return null;
    }
  };

  DocumentStoreProvider.prototype.filterTabComponent = function(capability, defaultComponent) {
    if (capability === 'save' && this.disableForNextSave) {
      this.disableForNextSave = false;
      return null;
    } else {
      return defaultComponent;
    }
  };

  DocumentStoreProvider.prototype.isNotDeprecated = function(capability) {
    if (capability === 'save') {
      return this.options.deprecationPhase < 2;
    } else {
      return this.options.deprecationPhase < 3;
    }
  };

  DocumentStoreProvider.prototype.deprecationMessage = function() {
    return "<div style=\"text-align: left\">\n  <p style=\"margin: 10px 0;\">\n    <strong>" + (tr(~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE)) + "</strong>\n  </p>\n  <p style=\"margin: 10px 0;\">\n    " + (tr(~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE)) + "\n  </p>\n</div>";
  };

  DocumentStoreProvider.prototype.onProviderTabSelected = function(capability) {
    if (capability === 'save' && this.deprecationMessage()) {
      return this.client.alert(this.deprecationMessage(), tr('~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE'));
    }
  };

  DocumentStoreProvider.prototype.handleUrlParams = function() {
    if (this.urlParams.recordid) {
      this.client.openProviderFile(this.name, {
        id: this.urlParams.recordid
      });
      return true;
    } else if (this.urlParams.docName && this.urlParams.docOwner) {
      this.client.openProviderFile(this.name, {
        name: this.urlParams.docName,
        owner: this.urlParams.docOwner
      });
      return true;
    } else {
      return false;
    }
  };

  DocumentStoreProvider.prototype.list = function(metadata, callback) {
    return $.ajax({
      dataType: 'json',
      url: this.docStoreUrl.listDocuments(),
      context: this,
      xhrFields: {
        withCredentials: true
      },
      success: function(data) {
        var file, key, list;
        list = [];
        for (key in data) {
          if (!hasProp.call(data, key)) continue;
          file = data[key];
          if (this.matchesExtension(file.name)) {
            list.push(new CloudMetadata({
              name: file.name,
              providerData: {
                id: file.id
              },
              type: CloudMetadata.File,
              provider: this
            }));
          }
        }
        return callback(null, list);
      },
      error: function() {
        return callback(null, []);
      },
      statusCode: {
        403: (function(_this) {
          return function() {
            _this.user = null;
            return _this.authCallback(false);
          };
        })(this)
      }
    });
  };

  DocumentStoreProvider.prototype.load = function(metadata, callback) {
    var recordid, ref1, ref2, ref3, ref4, ref5, requestData, withCredentials;
    withCredentials = !metadata.sharedContentId ? true : false;
    recordid = ((ref1 = metadata.providerData) != null ? ref1.id : void 0) || metadata.sharedContentId;
    requestData = {};
    if (recordid) {
      requestData.recordid = recordid;
    }
    if (this.urlParams.runKey) {
      requestData.runKey = this.urlParams.runKey;
    }
    if (!recordid) {
      if ((ref2 = metadata.providerData) != null ? ref2.name : void 0) {
        requestData.recordname = (ref3 = metadata.providerData) != null ? ref3.name : void 0;
      }
      if ((ref4 = metadata.providerData) != null ? ref4.owner : void 0) {
        requestData.owner = (ref5 = metadata.providerData) != null ? ref5.owner : void 0;
      }
    }
    return $.ajax({
      url: this.docStoreUrl.loadDocument(),
      dataType: 'json',
      data: requestData,
      context: this,
      xhrFields: {
        withCredentials: withCredentials
      },
      success: function(data) {
        var content, ref6;
        content = cloudContentFactory.createEnvelopedCloudContent(data);
        metadata.rename(metadata.name || metadata.providerData.name || data.docName || data.name || ((ref6 = data.content) != null ? ref6.name : void 0));
        if (metadata.name) {
          content.addMetadata({
            docName: metadata.filename
          });
        }
        return callback(null, content);
      },
      statusCode: {
        403: (function(_this) {
          return function() {
            _this.user = null;
            return callback(tr("~DOCSTORE.LOAD_403_ERROR", {
              filename: metadata.name || 'the file'
            }), 403);
          };
        })(this)
      },
      error: function(jqXHR) {
        var message, ref6;
        if (jqXHR.status === 403) {
          return;
        }
        message = metadata.sharedContentId ? tr("~DOCSTORE.LOAD_SHARED_404_ERROR") : tr("~DOCSTORE.LOAD_404_ERROR", {
          filename: metadata.name || ((ref6 = metadata.providerData) != null ? ref6.id : void 0) || 'the file'
        });
        return callback(message);
      }
    });
  };

  DocumentStoreProvider.prototype.save = function(cloudContent, metadata, callback) {
    var content, logData, method, params, patchResults, url;
    content = cloudContent.getContent();
    patchResults = this.savedContent.createPatch(content, this.options.patch && metadata.overwritable);
    if (patchResults.shouldPatch && !patchResults.diffLength) {
      callback(null);
      return;
    }
    params = {};
    if (metadata.providerData.id) {
      params.recordid = metadata.providerData.id;
    }
    if (!patchResults.shouldPatch && metadata.filename) {
      params.recordname = metadata.filename;
    }
    if (this.urlParams.runKey) {
      params.runKey = this.urlParams.runKey;
    }
    method = 'POST';
    url = patchResults.shouldPatch ? this.docStoreUrl.patchDocument(params) : this.docStoreUrl.saveDocument(params);
    logData = {
      operation: 'save',
      provider: 'DocumentStoreProvider',
      shouldPatch: patchResults.shouldPatch,
      method: method,
      url: url,
      params: JSON.stringify(params),
      content: patchResults.sendContent.substr(0, 512)
    };
    this.client.log('save', logData);
    return $.ajax({
      dataType: 'json',
      type: method,
      url: url,
      data: pako.deflate(patchResults.sendContent),
      contentType: patchResults.mimeType,
      processData: false,
      beforeSend: function(xhr) {
        return xhr.setRequestHeader('Content-Encoding', 'deflate');
      },
      context: this,
      xhrFields: {
        withCredentials: true
      },
      success: function(data) {
        this.savedContent.updateContent(this.options.patch ? _.cloneDeep(content) : null);
        if (data.id) {
          metadata.providerData.id = data.id;
        }
        return callback(null, data);
      },
      statusCode: {
        403: (function(_this) {
          return function() {
            _this.user = null;
            return callback(tr("~DOCSTORE.SAVE_403_ERROR", {
              filename: metadata.name
            }), 403);
          };
        })(this)
      },
      error: function(jqXHR) {
        var responseJson;
        try {
          if (jqXHR.status === 403) {
            return;
          }
          responseJson = JSON.parse(jqXHR.responseText);
          if (responseJson.message === 'error.duplicate') {
            return callback(tr("~DOCSTORE.SAVE_DUPLICATE_ERROR", {
              filename: metadata.name
            }));
          } else {
            return callback(tr("~DOCSTORE.SAVE_ERROR_WITH_MESSAGE", {
              filename: metadata.name,
              message: responseJson.message
            }));
          }
        } catch (error) {
          return callback(tr("~DOCSTORE.SAVE_ERROR", {
            filename: metadata.name
          }));
        }
      }
    });
  };

  DocumentStoreProvider.prototype.remove = function(metadata, callback) {
    return $.ajax({
      url: this.docStoreUrl.deleteDocument(),
      data: {
        recordname: metadata.filename
      },
      context: this,
      xhrFields: {
        withCredentials: true
      },
      success: function(data) {
        return callback(null, data);
      },
      statusCode: {
        403: (function(_this) {
          return function() {
            _this.user = null;
            return callback(tr("~DOCSTORE.REMOVE_403_ERROR", {
              filename: metadata.name
            }), 403);
          };
        })(this)
      },
      error: function(jqXHR) {
        if (jqXHR.status === 403) {
          return;
        }
        return callback(tr("~DOCSTORE.REMOVE_ERROR", {
          filename: metadata.name
        }));
      }
    });
  };

  DocumentStoreProvider.prototype.rename = function(metadata, newName, callback) {
    return $.ajax({
      url: this.docStoreUrl.renameDocument(),
      data: {
        recordid: metadata.providerData.id,
        newRecordname: CloudMetadata.withExtension(newName)
      },
      context: this,
      xhrFields: {
        withCredentials: true
      },
      success: function(data) {
        metadata.rename(newName);
        return callback(null, metadata);
      },
      statusCode: {
        403: (function(_this) {
          return function() {
            _this.user = null;
            return callback(tr("~DOCSTORE.RENAME_403_ERROR", {
              filename: metadata.name
            }), 403);
          };
        })(this)
      },
      error: function(jqXHR) {
        if (jqXHR.status === 403) {
          return;
        }
        return callback(tr("~DOCSTORE.RENAME_ERROR", {
          filename: metadata.name
        }));
      }
    });
  };

  DocumentStoreProvider.prototype.canOpenSaved = function() {
    return true;
  };

  DocumentStoreProvider.prototype.openSaved = function(openSavedParams, callback) {
    var metadata, providerData;
    providerData = typeof openSavedParams === "object" ? openSavedParams : {
      id: openSavedParams
    };
    metadata = new CloudMetadata({
      type: CloudMetadata.File,
      provider: this,
      providerData: providerData
    });
    return this.load(metadata, (function(_this) {
      return function(err, content) {
        _this.client.removeQueryParams(_this.removableQueryParams);
        return callback(err, content, metadata);
      };
    })(this));
  };

  DocumentStoreProvider.prototype.getOpenSavedParams = function(metadata) {
    return metadata.providerData.id;
  };

  DocumentStoreProvider.prototype.fileOpened = function(content, metadata) {
    var deprecationPhase, fromLara;
    deprecationPhase = this.options.deprecationPhase || 0;
    fromLara = !!getQueryParam("launchFromLara") || !!getHashParam("lara");
    if (!deprecationPhase || fromLara) {
      return;
    }
    return this.client.confirmDialog({
      title: tr('~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE'),
      message: this.deprecationMessage(),
      yesTitle: tr('~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE'),
      noTitle: tr('~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER'),
      hideNoButton: deprecationPhase >= 3,
      callback: (function(_this) {
        return function() {
          _this.disableForNextSave = true;
          return _this.client.saveFileAsDialog();
        };
      })(this),
      rejectCallback: (function(_this) {
        return function() {
          if (deprecationPhase > 1) {
            return _this.client.appOptions.autoSaveInterval = null;
          }
        };
      })(this)
    });
  };

  return DocumentStoreProvider;

})(ProviderInterface);

module.exports = DocumentStoreProvider;


},{"../utils/get-hash-param":69,"../utils/get-query-param":70,"../utils/is-string":72,"../utils/translate":80,"./document-store-url":58,"./patchable-content":63,"./provider-interface":65,"jiff":20,"pako":35}],57:[function(require,module,exports){
var CloudMetadata, DocumentStoreShareProvider, DocumentStoreUrl, pako;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

DocumentStoreUrl = require('./document-store-url');

pako = require('pako');

DocumentStoreShareProvider = (function() {
  function DocumentStoreShareProvider(client, provider) {
    this.client = client;
    this.provider = provider;
    this.docStoreUrl = this.provider.docStoreUrl;
  }

  DocumentStoreShareProvider.prototype.loadSharedContent = function(id, callback) {
    var sharedMetadata;
    sharedMetadata = new CloudMetadata({
      sharedContentId: id,
      type: CloudMetadata.File,
      overwritable: false
    });
    return this.provider.load(sharedMetadata, function(err, content) {
      return callback(err, content, sharedMetadata);
    });
  };

  DocumentStoreShareProvider.prototype.getSharingMetadata = function(shared) {
    return {
      _permissions: shared ? 1 : 0
    };
  };

  DocumentStoreShareProvider.prototype.share = function(shared, masterContent, sharedContent, metadata, callback) {
    var accessKey, accessKeys, documentID, method, params, ref, ref1, runKey, url;
    documentID = masterContent.get('sharedDocumentId');
    accessKeys = masterContent.get('accessKeys');
    runKey = masterContent.get('shareEditKey');
    accessKey = (accessKeys != null ? accessKeys.readWrite : void 0) || runKey;
    params = {
      shared: shared
    };
    if (accessKey) {
      params.accessKey = 'RW::' + accessKey;
    }
    if (documentID && accessKey) {
      ref = this.docStoreUrl.v2SaveDocument(documentID, params), method = ref.method, url = ref.url;
      return $.ajax({
        dataType: 'json',
        type: method,
        url: url,
        contentType: 'application/json',
        data: pako.deflate(sharedContent.getContentAsJSON()),
        processData: false,
        beforeSend: function(xhr) {
          return xhr.setRequestHeader('Content-Encoding', 'deflate');
        },
        context: this,
        xhrFields: {
          withCredentials: true
        },
        success: function(data) {
          if (runKey && (accessKeys == null)) {
            masterContent.addMetadata({
              accessKeys: {
                readWrite: runKey
              }
            });
          }
          return callback(null, data.id);
        },
        error: function(jqXHR) {
          var docName;
          docName = (metadata != null ? metadata.filename : void 0) || 'document';
          return callback("Unable to update shared '" + docName + "'");
        }
      });
    } else if (shared) {
      params.shared = true;
      ref1 = this.docStoreUrl.v2CreateDocument(params), method = ref1.method, url = ref1.url;
      return $.ajax({
        dataType: 'json',
        type: method,
        url: url,
        contentType: 'application/json',
        data: pako.deflate(sharedContent.getContentAsJSON()),
        processData: false,
        beforeSend: function(xhr) {
          return xhr.setRequestHeader('Content-Encoding', 'deflate');
        },
        context: this,
        xhrFields: {
          withCredentials: true
        },
        success: function(data) {
          masterContent.addMetadata({
            sharedDocumentId: data.id,
            accessKeys: {
              readOnly: data.readAccessKey,
              readWrite: data.readWriteAccessKey
            }
          });
          return callback(null, data.id);
        },
        error: function(jqXHR) {
          var docName;
          docName = (metadata != null ? metadata.filename : void 0) || 'document';
          return callback("Unable to share '" + docName + "'");
        }
      });
    } else {
      return callback("Unable to unshare '" + docName + "'");
    }
  };

  return DocumentStoreShareProvider;

})();

module.exports = DocumentStoreShareProvider;


},{"./document-store-url":58,"./provider-interface":65,"pako":35}],58:[function(require,module,exports){
var DocumentStoreUrl, defaultDocStoreUrl;

defaultDocStoreUrl = "//document-store.concord.org";

DocumentStoreUrl = (function() {
  function DocumentStoreUrl(docStoreUrl) {
    this.docStoreUrl = docStoreUrl || defaultDocStoreUrl;
    this.docStoreUrl = this.docStoreUrl.replace(/\/+$/, '');
  }

  DocumentStoreUrl.prototype.addParams = function(url, params) {
    var key, kvp, value;
    if (!params) {
      return url;
    }
    kvp = [];
    for (key in params) {
      value = params[key];
      kvp.push([key, value].map(encodeURI).join("="));
    }
    return url + "?" + kvp.join("&");
  };

  DocumentStoreUrl.prototype.authorize = function(params) {
    return this.addParams(this.docStoreUrl + "/user/authenticate", params);
  };

  DocumentStoreUrl.prototype.checkLogin = function(params) {
    return this.addParams(this.docStoreUrl + "/user/info", params);
  };

  DocumentStoreUrl.prototype.listDocuments = function(params) {
    return this.addParams(this.docStoreUrl + "/document/all", params);
  };

  DocumentStoreUrl.prototype.loadDocument = function(params) {
    return this.addParams(this.docStoreUrl + "/document/open", params);
  };

  DocumentStoreUrl.prototype.saveDocument = function(params) {
    return this.addParams(this.docStoreUrl + "/document/save", params);
  };

  DocumentStoreUrl.prototype.patchDocument = function(params) {
    return this.addParams(this.docStoreUrl + "/document/patch", params);
  };

  DocumentStoreUrl.prototype.deleteDocument = function(params) {
    return this.addParams(this.docStoreUrl + "/document/delete", params);
  };

  DocumentStoreUrl.prototype.renameDocument = function(params) {
    return this.addParams(this.docStoreUrl + "/document/rename", params);
  };

  DocumentStoreUrl.prototype.v2Document = function(id, params) {
    return this.addParams(this.docStoreUrl + "/v2/documents/" + id, params);
  };

  DocumentStoreUrl.prototype.v2CreateDocument = function(params) {
    return {
      method: 'POST',
      url: this.v2Document('', params)
    };
  };

  DocumentStoreUrl.prototype.v2LoadDocument = function(id, params) {
    return {
      method: 'GET',
      url: this.v2Document(id, params)
    };
  };

  DocumentStoreUrl.prototype.v2SaveDocument = function(id, params) {
    return {
      method: 'PUT',
      url: this.v2Document(id, params)
    };
  };

  DocumentStoreUrl.prototype.v2PatchDocument = function(id, params) {
    return {
      method: 'PATCH',
      url: this.v2Document(id, params)
    };
  };

  return DocumentStoreUrl;

})();

module.exports = DocumentStoreUrl;


},{}],59:[function(require,module,exports){
var CloudMetadata, GoogleDriveAuthorizationDialog, GoogleDriveProvider, ProviderInterface, button, cloudContentFactory, div, isString, jsdiff, ref, span, tr,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = React.DOM, div = ref.div, button = ref.button, span = ref.span;

tr = require('../utils/translate');

isString = require('../utils/is-string');

jsdiff = require('diff');

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

GoogleDriveAuthorizationDialog = React.createFactory(React.createClass({
  displayName: 'GoogleDriveAuthorizationDialog',
  getInitialState: function() {
    return {
      loadedGAPI: window._LoadedGAPIClients
    };
  },
  componentWillMount: function() {
    return this.props.provider._loadedGAPI((function(_this) {
      return function() {
        if (_this._isMounted) {
          return _this.setState({
            loadedGAPI: true
          });
        }
      };
    })(this));
  },
  componentDidMount: function() {
    this._isMounted = true;
    if (this.state.loadedGAPI !== window._LoadedGAPIClients) {
      return this.setState({
        loadedGAPI: window._LoadedGAPIClients
      });
    }
  },
  componentWillUnmount: function() {
    return this._isMounted = false;
  },
  authenticate: function() {
    return this.props.provider.authorize(GoogleDriveProvider.SHOW_POPUP);
  },
  render: function() {
    return div({
      className: 'google-drive-auth'
    }, div({
      className: 'google-drive-concord-logo'
    }, ''), div({
      className: 'google-drive-footer'
    }, window._LoadedGAPIClients || this.state.loadedGAPI ? button({
      onClick: this.authenticate
    }, tr("~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL")) : tr("~GOOGLE_DRIVE.CONNECTING_MESSAGE")));
  }
}));

GoogleDriveProvider = (function(superClass) {
  extend(GoogleDriveProvider, superClass);

  function GoogleDriveProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    GoogleDriveProvider.__super__.constructor.call(this, {
      name: GoogleDriveProvider.Name,
      displayName: this.options.displayName || (tr('~PROVIDER.GOOGLE_DRIVE')),
      urlDisplayName: this.options.urlDisplayName,
      capabilities: {
        save: true,
        resave: true,
        "export": true,
        load: true,
        list: true,
        remove: false,
        rename: true,
        close: true,
        setFolder: true
      }
    });
    this.authToken = null;
    this.user = null;
    this.clientId = this.options.clientId;
    if (!this.clientId) {
      throw new Error(tr("~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID"));
    }
    this.scopes = this.options.scopes || ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.install', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/userinfo.profile'];
    this.mimeType = this.options.mimeType || "text/plain";
    this.readableMimetypes = this.options.readableMimetypes;
    this.useRealTimeAPI = this.options.useRealTimeAPI || false;
    if (this.useRealTimeAPI) {
      this.mimeType += '+cfm_realtime';
    }
    this._loadGAPI();
  }

  GoogleDriveProvider.Name = 'googleDrive';

  GoogleDriveProvider.IMMEDIATE = true;

  GoogleDriveProvider.SHOW_POPUP = false;

  GoogleDriveProvider.prototype.authorized = function(authCallback) {
    if (!(authCallback == null)) {
      this.authCallback = authCallback;
    }
    if (authCallback) {
      if (this.authToken) {
        return authCallback(true);
      } else {
        return this.authorize(GoogleDriveProvider.IMMEDIATE);
      }
    } else {
      return this.authToken !== null;
    }
  };

  GoogleDriveProvider.prototype.authorize = function(immediate) {
    return this._loadedGAPI((function(_this) {
      return function() {
        var args;
        args = {
          client_id: _this.clientId,
          scope: _this.scopes,
          immediate: immediate
        };
        return gapi.auth.authorize(args, function(authToken) {
          _this.authToken = authToken && !authToken.error ? authToken : null;
          _this.user = null;
          _this.autoRenewToken(_this.authToken);
          if (_this.authToken) {
            gapi.client.oauth2.userinfo.get().execute(function(user) {
              return _this.user = user;
            });
          }
          return typeof _this.authCallback === "function" ? _this.authCallback(_this.authToken !== null) : void 0;
        });
      };
    })(this));
  };

  GoogleDriveProvider.prototype.autoRenewToken = function(authToken) {
    if (this._autoRenewTimeout) {
      clearTimeout(this._autoRenewTimeout);
    }
    if (authToken && !authToken.error) {
      return this._autoRenewTimeout = setTimeout(((function(_this) {
        return function() {
          return _this.authorize(GoogleDriveProvider.IMMEDIATE);
        };
      })(this)), (parseInt(authToken.expires_in, 10) * 0.75) * 1000);
    }
  };

  GoogleDriveProvider.prototype.renderAuthorizationDialog = function() {
    return GoogleDriveAuthorizationDialog({
      provider: this
    });
  };

  GoogleDriveProvider.prototype.renderUser = function() {
    if (this.user) {
      return span({}, span({
        className: 'gdrive-icon'
      }), this.user.name);
    } else {
      return null;
    }
  };

  GoogleDriveProvider.prototype.save = function(content, metadata, callback) {
    return this._loadedGAPI((function(_this) {
      return function() {
        if (_this.useRealTimeAPI) {
          return _this._saveRealTimeFile(content, metadata, callback);
        } else {
          return _this._saveFile(content, metadata, callback);
        }
      };
    })(this));
  };

  GoogleDriveProvider.prototype.load = function(metadata, callback) {
    return this._loadedGAPI((function(_this) {
      return function() {
        if (_this.useRealTimeAPI) {
          return _this._loadOrCreateRealTimeFile(metadata, callback);
        } else {
          return _this._loadFile(metadata, callback);
        }
      };
    })(this));
  };

  GoogleDriveProvider.prototype.list = function(metadata, callback) {
    return this._loadedGAPI((function(_this) {
      return function() {
        var mimeType, mimeTypesQuery, query, request;
        mimeTypesQuery = ((function() {
          var i, len, ref1, results;
          ref1 = this.readableMimetypes;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            mimeType = ref1[i];
            results.push("mimeType = '" + mimeType + "'");
          }
          return results;
        }).call(_this)).join(" or ");
        request = gapi.client.drive.files.list({
          q: query = "trashed = false and (" + mimeTypesQuery + " or mimeType = 'application/vnd.google-apps.folder') and '" + (metadata ? metadata.providerData.id : 'root') + "' in parents"
        });
        return request.execute(function(result) {
          var i, item, len, list, ref1, type;
          if (!result || result.error) {
            return callback(_this._apiError(result, 'Unable to list files'));
          }
          list = [];
          ref1 = result != null ? result.items : void 0;
          for (i = 0, len = ref1.length; i < len; i++) {
            item = ref1[i];
            type = item.mimeType === 'application/vnd.google-apps.folder' ? CloudMetadata.Folder : CloudMetadata.File;
            if (type === CloudMetadata.Folder || _this.matchesExtension(item.title)) {
              list.push(new CloudMetadata({
                name: item.title,
                type: type,
                parent: metadata,
                overwritable: item.editable,
                provider: _this,
                providerData: {
                  id: item.id
                }
              }));
            }
          }
          list.sort(function(a, b) {
            var lowerA, lowerB;
            lowerA = a.name.toLowerCase();
            lowerB = b.name.toLowerCase();
            if (lowerA < lowerB) {
              return -1;
            }
            if (lowerA > lowerB) {
              return 1;
            }
            return 0;
          });
          return callback(null, list);
        });
      };
    })(this));
  };

  GoogleDriveProvider.prototype.remove = function(metadata, callback) {
    return this._loadedGAPI(function() {
      var request;
      request = gapi.client.drive.files["delete"]({
        fileId: metadata.providerData.id
      });
      return request.execute(function(result) {
        return typeof callback === "function" ? callback((result != null ? result.error : void 0) || null) : void 0;
      });
    });
  };

  GoogleDriveProvider.prototype.rename = function(metadata, newName, callback) {
    return this._loadedGAPI(function() {
      var request;
      request = gapi.client.drive.files.patch({
        fileId: metadata.providerData.id,
        resource: {
          title: CloudMetadata.withExtension(newName)
        }
      });
      return request.execute(function(result) {
        if (result != null ? result.error : void 0) {
          return typeof callback === "function" ? callback(result.error) : void 0;
        } else {
          metadata.rename(newName);
          return callback(null, metadata);
        }
      });
    });
  };

  GoogleDriveProvider.prototype.close = function(metadata, callback) {
    var ref1, ref2;
    if (((ref1 = metadata.providerData) != null ? (ref2 = ref1.realTime) != null ? ref2.doc : void 0 : void 0) != null) {
      return metadata.providerData.realTime.doc.close();
    }
  };

  GoogleDriveProvider.prototype.canOpenSaved = function() {
    return true;
  };

  GoogleDriveProvider.prototype.openSaved = function(openSavedParams, callback) {
    var metadata;
    metadata = new CloudMetadata({
      type: CloudMetadata.File,
      provider: this,
      providerData: {
        id: openSavedParams
      }
    });
    return this.load(metadata, function(err, content) {
      return callback(err, content, metadata);
    });
  };

  GoogleDriveProvider.prototype.getOpenSavedParams = function(metadata) {
    return metadata.providerData.id;
  };

  GoogleDriveProvider.prototype.isAuthorizationRequired = function() {
    return true;
  };

  GoogleDriveProvider.prototype._loadGAPI = function() {
    var script;
    if (!window._LoadingGAPI) {
      window._LoadingGAPI = true;
      window._GAPIOnLoad = (function(_this) {
        return function() {
          window._LoadedGAPI = true;
          return _this._loadedGAPI(function() {});
        };
      })(this);
      script = document.createElement('script');
      script.src = 'https://apis.google.com/js/client.js?onload=_GAPIOnLoad';
      return document.head.appendChild(script);
    }
  };

  GoogleDriveProvider.prototype._loadedGAPI = function(callback) {
    var check, self;
    if (window._LoadedGAPIClients) {
      return callback();
    } else {
      self = this;
      check = function() {
        if (window._LoadedGAPI) {
          return gapi.client.load('drive', 'v2', function() {
            return gapi.client.load('oauth2', 'v2', function() {
              return gapi.load('drive-realtime', function() {
                window._LoadedGAPIClients = true;
                return callback.call(self);
              });
            });
          });
        } else {
          return setTimeout(check, 10);
        }
      };
      return setTimeout(check, 10);
    }
  };

  GoogleDriveProvider.prototype._loadFile = function(metadata, callback) {
    var request;
    request = gapi.client.drive.files.get({
      fileId: metadata.providerData.id
    });
    return request.execute((function(_this) {
      return function(file) {
        var ref1, url, xhr;
        if (file != null ? file.downloadUrl : void 0) {
          metadata.rename(file.title);
          metadata.overwritable = file.editable;
          metadata.providerData = {
            id: file.id
          };
          metadata.mimeType = file.mimeType;
          if ((metadata.parent == null) && ((ref1 = file.parents) != null ? ref1.length : void 0) > 0) {
            metadata.parent = new CloudMetadata({
              type: CloudMetadata.Folder,
              provider: _this,
              providerData: {
                id: file.parents[0].id
              }
            });
          }
          url = file.downloadUrl;
          url += (url.indexOf("?") === -1 ? "?" : "&") + "access_token=" + (encodeURIComponent(_this.authToken.access_token));
          xhr = new XMLHttpRequest();
          xhr.open('GET', url);
          xhr.onload = function() {
            return callback(null, cloudContentFactory.createEnvelopedCloudContent(xhr.responseText));
          };
          xhr.onerror = function() {
            return callback("Unable to download file content");
          };
          return xhr.send();
        } else {
          return callback(_this._apiError(file, 'Unable to get download url'));
        }
      };
    })(this));
  };

  GoogleDriveProvider.prototype._saveFile = function(content, metadata, callback) {
    var body, boundary, header, method, mimeType, path, ref1, ref2, ref3, ref4, request, transferEncoding;
    boundary = '-------314159265358979323846';
    mimeType = metadata.mimeType || this.mimeType;
    header = JSON.stringify({
      title: metadata.filename,
      mimeType: mimeType,
      parents: [
        {
          id: ((ref1 = metadata.parent) != null ? (ref2 = ref1.providerData) != null ? ref2.id : void 0 : void 0) != null ? metadata.parent.providerData.id : 'root'
        }
      ]
    });
    ref4 = ((ref3 = metadata.providerData) != null ? ref3.id : void 0) ? ['PUT', "/upload/drive/v2/files/" + metadata.providerData.id] : ['POST', '/upload/drive/v2/files'], method = ref4[0], path = ref4[1];
    transferEncoding = "";
    if (mimeType.indexOf("image/") === 0) {
      transferEncoding = "\r\nContent-Transfer-Encoding: base64";
    }
    body = ["\r\n--" + boundary + "\r\nContent-Type: application/json\r\n\r\n" + header, "\r\n--" + boundary + "\r\nContent-Type: " + mimeType + transferEncoding + "\r\n\r\n" + ((typeof content.getContentAsJSON === "function" ? content.getContentAsJSON() : void 0) || content), "\r\n--" + boundary + "--"].join('');
    request = gapi.client.request({
      path: path,
      method: method,
      params: {
        uploadType: 'multipart'
      },
      headers: {
        'Content-Type': 'multipart/related; boundary="' + boundary + '"'
      },
      body: body
    });
    return request.execute((function(_this) {
      return function(file) {
        if (callback) {
          if (file != null ? file.error : void 0) {
            return callback("Unabled to upload file: " + file.error.message);
          } else if (file) {
            metadata.providerData = {
              id: file.id
            };
            return callback(null, file);
          } else {
            return callback(_this._apiError(file, 'Unabled to upload file'));
          }
        }
      };
    })(this));
  };

  GoogleDriveProvider.prototype._loadOrCreateRealTimeFile = function(metadata, callback) {
    var error, fileLoaded, init, ref1, ref2, ref3, request, self;
    self = this;
    fileLoaded = function(doc) {
      var collaborator, content, i, len, ref1, sessionId, throwError;
      content = doc.getModel().getRoot().get('content');
      if (metadata.overwritable) {
        throwError = function(e) {
          if (!e.isLocal && e.sessionId !== metadata.providerData.realTime.sessionId) {
            return self.client.showBlockingModal({
              title: 'Concurrent Edit Lock',
              message: 'An edit was made to this file from another browser window. This app is now locked for input.'
            });
          }
        };
        content.addEventListener(gapi.drive.realtime.EventType.TEXT_INSERTED, throwError);
        content.addEventListener(gapi.drive.realtime.EventType.TEXT_DELETED, throwError);
      }
      ref1 = doc.getCollaborators();
      for (i = 0, len = ref1.length; i < len; i++) {
        collaborator = ref1[i];
        if (collaborator.isMe) {
          sessionId = collaborator.sessionId;
        }
      }
      metadata.providerData.realTime = {
        doc: doc,
        content: content,
        sessionId: sessionId
      };
      return callback(null, cloudContentFactory.createEnvelopedCloudContent(content.getText()));
    };
    init = function(model) {
      var content;
      content = model.createString('');
      return model.getRoot().set('content', content);
    };
    error = (function(_this) {
      return function(err) {
        if (err.type === 'TOKEN_REFRESH_REQUIRED') {
          return _this.authorize(GoogleDriveProvider.IMMEDIATE);
        } else {
          return _this.client.alert(err.message);
        }
      };
    })(this);
    if ((ref1 = metadata.providerData) != null ? ref1.id : void 0) {
      request = gapi.client.drive.files.get({
        fileId: metadata.providerData.id
      });
    } else {
      request = gapi.client.drive.files.insert({
        title: metadata.filename,
        mimeType: this.mimeType,
        parents: [
          {
            id: ((ref2 = metadata.parent) != null ? (ref3 = ref2.providerData) != null ? ref3.id : void 0 : void 0) != null ? metadata.parent.providerData.id : 'root'
          }
        ]
      });
    }
    return request.execute((function(_this) {
      return function(file) {
        if (file != null ? file.id : void 0) {
          metadata.rename(file.title);
          metadata.overwritable = file.editable;
          metadata.providerData = {
            id: file.id
          };
          return gapi.drive.realtime.load(file.id, fileLoaded, init, error);
        } else {
          return callback(_this._apiError(file, 'Unable to load file'));
        }
      };
    })(this));
  };

  GoogleDriveProvider.prototype._saveRealTimeFile = function(content, metadata, callback) {
    var ref1;
    if ((ref1 = metadata.providerData) != null ? ref1.model : void 0) {
      return this._diffAndUpdateRealTimeModel(content, metadata, callback);
    } else {
      return this._loadOrCreateRealTimeFile(metadata, (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this._diffAndUpdateRealTimeModel(content, metadata, callback);
        };
      })(this));
    }
  };

  GoogleDriveProvider.prototype._diffAndUpdateRealTimeModel = function(content, metadata, callback) {
    var diff, diffs, i, index, len, realTimeContent;
    index = 0;
    realTimeContent = metadata.providerData.realTime.content;
    diffs = jsdiff.diffChars(realTimeContent.getText(), content.getContentAsJSON());
    for (i = 0, len = diffs.length; i < len; i++) {
      diff = diffs[i];
      if (diff.removed) {
        realTimeContent.removeRange(index, index + diff.value.length);
      } else {
        if (diff.added) {
          realTimeContent.insertString(index, diff.value);
        }
        index += diff.count;
      }
    }
    return callback(null);
  };

  GoogleDriveProvider.prototype._apiError = function(result, prefix) {
    if ((result != null ? result.message : void 0) != null) {
      return prefix + ": " + result.message;
    } else {
      return prefix;
    }
  };

  return GoogleDriveProvider;

})(ProviderInterface);

module.exports = GoogleDriveProvider;


},{"../utils/is-string":72,"../utils/translate":80,"./provider-interface":65,"diff":12}],60:[function(require,module,exports){
var CloudMetadata, DocumentStoreUrl, LaraProvider, PatchableContent, ProviderInterface, base64, cloudContentFactory, getQueryParam, pako,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

DocumentStoreUrl = require('./document-store-url');

PatchableContent = require('./patchable-content');

getQueryParam = require('../utils/get-query-param');

base64 = (require('js-base64')).Base64;

pako = require('pako');

LaraProvider = (function(superClass) {
  extend(LaraProvider, superClass);

  LaraProvider.Name = 'lara';

  function LaraProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    LaraProvider.__super__.constructor.call(this, {
      name: LaraProvider.Name,
      capabilities: {
        save: true,
        resave: true,
        "export": false,
        load: true,
        list: false,
        remove: false,
        rename: false,
        close: false
      }
    });
    this.urlParams = {
      documentServer: getQueryParam("documentServer"),
      launchFromLara: getQueryParam("launchFromLara")
    };
    this.removableQueryParams = ['launchFromLara', 'runAsGuest'];
    this.laraParams = this.urlParams.launchFromLara ? this.decodeParams(this.urlParams.launchFromLara) : null;
    this.openSavedParams = null;
    this.collaboratorUrls = [];
    this.docStoreUrl = new DocumentStoreUrl(this.urlParams.documentServer);
    this.savedContent = new PatchableContent(this.options.patchObjectHash);
  }

  LaraProvider.prototype.encodeParams = function(params) {
    return base64.encodeURI(JSON.stringify(params));
  };

  LaraProvider.prototype.decodeParams = function(params) {
    var decoded, e;
    try {
      decoded = JSON.parse(base64.decode(params));
    } catch (error1) {
      e = error1;
      decoded = null;
    }
    return decoded;
  };

  LaraProvider.prototype.handleUrlParams = function() {
    if (this.laraParams) {
      this.client.openProviderFile(this.name, this.laraParams);
      return true;
    } else {
      return false;
    }
  };

  LaraProvider.prototype.logLaraData = function(laraData) {
    var ref;
    if ((ref = this.collaboratorUrls) != null ? ref.length : void 0) {
      laraData.collaboratorUrls = this.collaboratorUrls;
    }
    if (this.options.logLaraData) {
      this.options.logLaraData(laraData);
    }
    return this.client.log('logLaraData', laraData);
  };

  LaraProvider.prototype.filterTabComponent = function(capability, defaultComponent) {
    return null;
  };

  LaraProvider.prototype.extractRawDataFromRunState = function(runState) {
    var e, rawData;
    rawData = (runState != null ? runState.raw_data : void 0) || {};
    if (typeof rawData === "string") {
      try {
        rawData = JSON.parse(rawData);
      } catch (error1) {
        e = error1;
        rawData = {};
      }
    }
    return rawData;
  };

  LaraProvider.prototype.can = function(capability, metadata) {
    var hasReadOnlyAccess, ref, ref1, ref2, ref3, requiresWriteAccess;
    hasReadOnlyAccess = ((metadata != null ? (ref = metadata.providerData) != null ? (ref1 = ref.accessKeys) != null ? ref1.readOnly : void 0 : void 0 : void 0) != null) && ((metadata != null ? (ref2 = metadata.providerData) != null ? (ref3 = ref2.accessKeys) != null ? ref3.readWrite : void 0 : void 0 : void 0) == null);
    requiresWriteAccess = ['save', 'resave', 'remove', 'rename'].indexOf(capability) >= 0;
    return LaraProvider.__super__.can.call(this, capability, metadata) && !(requiresWriteAccess && hasReadOnlyAccess);
  };

  LaraProvider.prototype.load = function(metadata, callback) {
    var accessKey, method, ref, ref1, ref2, ref3, ref4, ref5, url;
    ref1 = this.docStoreUrl.v2LoadDocument((ref = metadata.providerData) != null ? ref.recordid : void 0), method = ref1.method, url = ref1.url;
    if ((ref2 = metadata.providerData) != null ? (ref3 = ref2.accessKeys) != null ? ref3.readOnly : void 0 : void 0) {
      accessKey = 'RO::' + metadata.providerData.accessKeys.readOnly;
    } else if ((ref4 = metadata.providerData) != null ? (ref5 = ref4.accessKeys) != null ? ref5.readWrite : void 0 : void 0) {
      accessKey = 'RW::' + metadata.providerData.accessKeys.readWrite;
    }
    return $.ajax({
      type: method,
      url: url,
      dataType: 'json',
      data: {
        accessKey: accessKey
      },
      context: this,
      success: (function(_this) {
        return function(data) {
          var content, ref6, ref7;
          _this.logLaraData({
            operation: 'open',
            documentID: (ref6 = metadata.providerData) != null ? ref6.recordid : void 0,
            documentUrl: url
          });
          content = cloudContentFactory.createEnvelopedCloudContent(data);
          metadata.rename(metadata.name || data.docName || data.name || ((ref7 = data.content) != null ? ref7.name : void 0));
          if (metadata.name) {
            content.addMetadata({
              docName: metadata.filename
            });
          }
          return callback(null, content);
        };
      })(this),
      error: function(jqXHR) {
        var ref6;
        return callback("Unable to load " + (metadata.name || ((ref6 = metadata.providerData) != null ? ref6.recordid : void 0) || 'file'));
      }
    });
  };

  LaraProvider.prototype.save = function(cloudContent, metadata, callback, disablePatch) {
    var canPatch, content, logData, method, params, patchResults, ref, ref1, ref2, url;
    content = cloudContent.getContent();
    canPatch = this.options.patch && metadata.overwritable && !disablePatch;
    patchResults = this.savedContent.createPatch(content, canPatch);
    if (patchResults.shouldPatch && !patchResults.diffLength) {
      callback(null);
      return;
    }
    params = {};
    if (!patchResults.shouldPatch && metadata.filename) {
      params.recordname = metadata.filename;
    }
    if (((metadata != null ? (ref = metadata.providerData) != null ? (ref1 = ref.accessKeys) != null ? ref1.readWrite : void 0 : void 0 : void 0) != null)) {
      params.accessKey = 'RW::' + metadata.providerData.accessKeys.readWrite;
    }
    ref2 = patchResults.shouldPatch ? this.docStoreUrl.v2PatchDocument(metadata.providerData.recordid, params) : this.docStoreUrl.v2SaveDocument(metadata.providerData.recordid, params), method = ref2.method, url = ref2.url;
    logData = {
      operation: 'save',
      provider: 'LaraProvider',
      shouldPatch: patchResults.shouldPatch,
      method: method,
      url: url.substr(0, url.indexOf('accessKey') + 16) + '...',
      params: JSON.stringify({
        recordname: params.recordname
      }),
      content: patchResults.sendContent.substr(0, 512)
    };
    this.client.log('save', logData);
    return $.ajax({
      dataType: 'json',
      type: method,
      url: url,
      data: pako.deflate(patchResults.sendContent),
      contentType: patchResults.mimeType,
      processData: false,
      beforeSend: function(xhr) {
        return xhr.setRequestHeader('Content-Encoding', 'deflate');
      },
      context: this,
      success: function(data) {
        this.savedContent.updateContent(this.options.patch ? _.cloneDeep(content) : null);
        if (data.recordid) {
          metadata.providerData.recordid = data.recordid;
        }
        return callback(null, data);
      },
      error: function(jqXHR) {
        var responseJson;
        if (patchResults.shouldPatch) {
          return this.save(cloudContent, metadata, callback, true);
        } else {
          try {
            responseJson = JSON.parse(jqXHR.responseText);
            if (responseJson.message === 'error.duplicate') {
              return callback("Unable to create " + metadata.name + ". File already exists.");
            } else {
              return callback("Unable to save " + metadata.name + ": [" + responseJson.message + "]");
            }
          } catch (error1) {
            return callback("Unable to save " + metadata.name);
          }
        }
      }
    });
  };

  LaraProvider.prototype.canOpenSaved = function() {
    return true;
  };

  LaraProvider.prototype.openSaved = function(openSavedParams, callback) {
    var loadProviderFile, metadata, processInitialRunState, ref;
    metadata = new CloudMetadata({
      type: CloudMetadata.File,
      provider: this
    });
    if (typeof openSavedParams === "string") {
      openSavedParams = this.decodeParams(openSavedParams);
    }
    this.openSavedParams = openSavedParams;
    this.collaboratorUrls = (openSavedParams != null ? (ref = openSavedParams.collaboratorUrls) != null ? ref.length : void 0 : void 0) > 0 ? openSavedParams.collaboratorUrls : [];
    loadProviderFile = (function(_this) {
      return function(providerData, callback) {
        metadata.providerData = providerData;
        return _this.load(metadata, function(err, content) {
          _this.client.removeQueryParams(_this.removableQueryParams);
          return callback(err, content, metadata);
        });
      };
    })(this);
    if (openSavedParams != null ? openSavedParams.recordid : void 0) {
      return loadProviderFile(openSavedParams, callback);
    }
    processInitialRunState = (function(_this) {
      return function(runStateUrl, sourceID, readOnlyKey, runState) {
        var becomeLeader, cloneDoc, createParams, docStore, existingRunState, finished, haveCollaborators, method, processCreateResponse, ref1, ref2, ref3, removeCollaborator, setFollowers, updateInteractiveRunStates, url;
        existingRunState = _this.extractRawDataFromRunState(runState);
        docStore = existingRunState.docStore;
        haveCollaborators = _this.collaboratorUrls.length > 0;
        updateInteractiveRunStates = function(urls, newDocStore, callback) {
          var learnerParam, learnerUrl, newRunState, processQueue, rawData, updateRunState, urlQueue;
          newRunState = _.cloneDeep(existingRunState);
          newRunState.docStore = newDocStore;
          rawData = JSON.stringify(newRunState);
          learnerUrl = (newRunState.learner_url != null) && typeof newRunState.learner_url === "string" ? newRunState.learner_url : null;
          learnerParam = learnerUrl ? "&learner_url=" + (encodeURIComponent(learnerUrl)) : "";
          updateRunState = function(url, done) {
            return $.ajax({
              type: 'PUT',
              url: url + "?raw_data=" + (encodeURIComponent(rawData)) + learnerParam,
              dataType: 'json',
              xhrFields: {
                withCredentials: true
              }
            }).done(function(data, status, jqXHR) {
              if ((data != null ? data.success : void 0) === false) {
                return done("Could not open the specified document because an error occurred [updateState] (" + data.message + ")");
              } else {
                return done(null);
              }
            }).fail(function(jqXHR, status, error) {
              return done("Could not open the specified document because an error occurred [updateState]");
            });
          };
          urlQueue = urls.slice();
          processQueue = function() {
            var url;
            if (urlQueue.length === 0) {
              return callback(null);
            } else {
              url = urlQueue.shift();
              return updateRunState(url, function(err) {
                if (err) {
                  return callback(err);
                } else {
                  return processQueue();
                }
              });
            }
          };
          return processQueue();
        };
        processCreateResponse = function(createResponse) {
          var codapUrl, encodedLaraParams, reportUrlLaraParams;
          docStore = {
            recordid: createResponse.id,
            accessKeys: {
              readOnly: createResponse.readAccessKey,
              readWrite: createResponse.readWriteAccessKey
            }
          };
          codapUrl = window.location.origin ? "" + window.location.origin + window.location.pathname : window.location.protocol + "//" + window.location.host + window.location.pathname;
          reportUrlLaraParams = {
            recordid: createResponse.id,
            accessKeys: {
              readOnly: createResponse.readAccessKey
            }
          };
          encodedLaraParams = _this.encodeParams(reportUrlLaraParams);
          if (existingRunState.lara_options == null) {
            existingRunState.lara_options = {};
          }
          return existingRunState.lara_options.reporting_url = codapUrl + "?launchFromLara=" + encodedLaraParams;
        };
        if (((docStore != null ? docStore.recordid : void 0) != null) && ((((ref1 = docStore.accessKeys) != null ? ref1.readOnly : void 0) != null) || (((ref2 = docStore.accessKeys) != null ? ref2.readWrite : void 0) != null))) {
          cloneDoc = function(callback) {
            var createParams, method, ref3, url;
            createParams = {
              source: docStore.recordid,
              accessKey: "RO::" + docStore.accessKeys.readOnly
            };
            ref3 = _this.docStoreUrl.v2CreateDocument(createParams), method = ref3.method, url = ref3.url;
            return $.ajax({
              type: method,
              url: url,
              dataType: 'json'
            }).done(function(createResponse, status, jqXHR) {
              var laraData;
              laraData = {
                operation: 'clone',
                documentID: docStore.recordid,
                documentUrl: url
              };
              if ((existingRunState != null ? existingRunState.run_remote_endpoint : void 0) != null) {
                laraData.run_remote_endpoint = existingRunState.run_remote_endpoint;
              }
              _this.logLaraData(laraData);
              processCreateResponse(createResponse);
              return callback(null);
            }).fail(function(jqXHR, status, error) {
              return callback("Could not open the specified document because an error occurred [createCopy]");
            });
          };
          setFollowers = function(err, callback) {
            var collaboratorParams;
            if (err) {
              return callback(err);
            } else {
              collaboratorParams = _.cloneDeep(docStore);
              collaboratorParams.collaborator = 'follower';
              return updateInteractiveRunStates(_this.collaboratorUrls, collaboratorParams, callback);
            }
          };
          becomeLeader = function(err, callback) {
            if (err) {
              return callback(err);
            } else {
              docStore.collaborator = 'leader';
              return updateInteractiveRunStates([runStateUrl], docStore, callback);
            }
          };
          removeCollaborator = function(err, callback) {
            if (err) {
              return callback(err);
            } else {
              delete docStore.collaborator;
              return updateInteractiveRunStates([runStateUrl], docStore, callback);
            }
          };
          finished = function(err) {
            if (err) {
              return callback(err);
            } else {
              return loadProviderFile(_.cloneDeep(docStore), callback);
            }
          };
          if (docStore.collaborator) {
            if (docStore.collaborator === 'leader') {
              if (haveCollaborators) {
                return setFollowers(null, finished);
              } else {
                return cloneDoc(function(err) {
                  return removeCollaborator(err, finished);
                });
              }
            } else {
              if (haveCollaborators) {
                return cloneDoc(function(err) {
                  return becomeLeader(err, (function(err) {
                    return setFollowers(err, finished);
                  }));
                });
              } else {
                return cloneDoc(function(err) {
                  return removeCollaborator(err, finished);
                });
              }
            }
          } else {
            if (haveCollaborators) {
              return becomeLeader(null, function(err) {
                return setFollowers(err, finished);
              });
            } else {
              return finished();
            }
          }
        }
        if (!sourceID) {
          callback("Could not open the specified document because an error occurred [noSource]");
          return;
        }
        createParams = {
          source: sourceID
        };
        if (readOnlyKey) {
          createParams.accessKey = "RO::" + readOnlyKey;
        }
        ref3 = _this.docStoreUrl.v2CreateDocument(createParams), method = ref3.method, url = ref3.url;
        return $.ajax({
          type: method,
          url: url,
          dataType: 'json'
        }).done(function(createResponse, status, jqXHR) {
          var providerData, updateFinished;
          processCreateResponse(createResponse);
          if (haveCollaborators) {
            docStore.collaborator = 'leader';
          }
          providerData = _.merge({}, docStore, {
            url: runStateUrl
          });
          updateFinished = function() {
            return loadProviderFile(providerData, callback);
          };
          return updateInteractiveRunStates([runStateUrl], docStore, function(err) {
            if (err) {
              return callback(err);
            } else if (haveCollaborators) {
              docStore.collaborator = 'follower';
              return updateInteractiveRunStates(_this.collaboratorUrls, docStore, function(err) {
                if (err) {
                  return callback(err);
                } else {
                  return updateFinished();
                }
              });
            } else {
              return updateFinished();
            }
          });
        }).fail(function(jqXHR, status, error) {
          return callback("Could not open the specified document because an error occurred [createCopy]");
        });
      };
    })(this);
    if (openSavedParams && openSavedParams.url) {
      $.ajax({
        type: 'GET',
        url: openSavedParams.url,
        dataType: 'json',
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(data, status, jqXHR) {
          var laraData;
          laraData = {
            operation: 'open',
            runStateUrl: openSavedParams.url,
            documentID: openSavedParams.source
          };
          if ((data != null ? data.run_remote_endpoint : void 0) != null) {
            laraData.run_remote_endpoint = data.run_remote_endpoint;
          }
          _this.logLaraData(laraData);
          return processInitialRunState(openSavedParams.url, openSavedParams.source, openSavedParams.readOnlyKey, data);
        };
      })(this)).fail(function(jqXHR, status, error) {
        return callback("Could not open the specified document because an error occurred [getState]");
      });
      return;
    }
    return callback("Cannot open the specified document");
  };

  LaraProvider.prototype.getOpenSavedParams = function(metadata) {
    var params;
    params = this.openSavedParams ? this.openSavedParams : this.laraParams ? {
      url: this.laraParams.url,
      source: this.laraParams.source
    } : metadata;
    return this.encodeParams(params);
  };

  return LaraProvider;

})(ProviderInterface);

module.exports = LaraProvider;


},{"../utils/get-query-param":70,"./document-store-url":58,"./patchable-content":63,"./provider-interface":65,"js-base64":34,"pako":35}],61:[function(require,module,exports){
var LocalFileListTab, LocalFileProvider, LocalFileSaveTab, ProviderInterface, button, cloudContentFactory, div, input, ref, tr,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = React.DOM, div = ref.div, input = ref.input, button = ref.button;

tr = require('../utils/translate');

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

LocalFileListTab = React.createFactory(require('../views/local-file-tab-list-view'));

LocalFileSaveTab = React.createFactory(require('../views/local-file-tab-save-view'));

LocalFileProvider = (function(superClass) {
  extend(LocalFileProvider, superClass);

  function LocalFileProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    LocalFileProvider.__super__.constructor.call(this, {
      name: LocalFileProvider.Name,
      displayName: this.options.displayName || (tr('~PROVIDER.LOCAL_FILE')),
      capabilities: {
        save: true,
        resave: false,
        "export": true,
        load: true,
        list: true,
        remove: false,
        rename: false,
        close: false
      }
    });
  }

  LocalFileProvider.Name = 'localFile';

  LocalFileProvider.prototype.filterTabComponent = function(capability, defaultComponent) {
    if (capability === 'list') {
      return LocalFileListTab;
    } else if ((capability === 'save') || (capability === 'export')) {
      return LocalFileSaveTab;
    } else {
      return defaultComponent;
    }
  };

  LocalFileProvider.prototype.list = function(metadata, callback) {};

  LocalFileProvider.prototype.save = function(content, metadata, callback) {
    return typeof callback === "function" ? callback(null) : void 0;
  };

  LocalFileProvider.prototype.load = function(metadata, callback) {
    var reader;
    reader = new FileReader();
    reader.onload = function(loaded) {
      return callback(null, cloudContentFactory.createEnvelopedCloudContent(loaded.target.result));
    };
    return reader.readAsText(metadata.providerData.file);
  };

  LocalFileProvider.prototype.canOpenSaved = function() {
    return false;
  };

  return LocalFileProvider;

})(ProviderInterface);

module.exports = LocalFileProvider;


},{"../utils/translate":80,"../views/local-file-tab-list-view":92,"../views/local-file-tab-save-view":93,"./provider-interface":65}],62:[function(require,module,exports){
var CloudMetadata, LocalStorageProvider, ProviderInterface, cloudContentFactory, tr,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

tr = require('../utils/translate');

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

LocalStorageProvider = (function(superClass) {
  extend(LocalStorageProvider, superClass);

  function LocalStorageProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    LocalStorageProvider.__super__.constructor.call(this, {
      name: LocalStorageProvider.Name,
      displayName: this.options.displayName || (tr('~PROVIDER.LOCAL_STORAGE')),
      urlDisplayName: this.options.urlDisplayName,
      capabilities: {
        save: true,
        resave: true,
        "export": true,
        load: true,
        list: true,
        remove: true,
        rename: true,
        close: false
      }
    });
  }

  LocalStorageProvider.Name = 'localStorage';

  LocalStorageProvider.Available = function() {
    var result, test;
    return result = (function() {
      try {
        test = 'LocalStorageProvider::auth';
        window.localStorage.setItem(test, test);
        window.localStorage.removeItem(test);
        return true;
      } catch (error) {
        return false;
      }
    })();
  };

  LocalStorageProvider.prototype.save = function(content, metadata, callback) {
    var e, fileKey;
    try {
      fileKey = this._getKey(metadata.filename);
      window.localStorage.setItem(fileKey, (typeof content.getContentAsJSON === "function" ? content.getContentAsJSON() : void 0) || content);
      return typeof callback === "function" ? callback(null) : void 0;
    } catch (error) {
      e = error;
      return callback("Unable to save: " + e.message);
    }
  };

  LocalStorageProvider.prototype.load = function(metadata, callback) {
    var content, e;
    try {
      content = window.localStorage.getItem(this._getKey(metadata.filename));
      return callback(null, cloudContentFactory.createEnvelopedCloudContent(content));
    } catch (error) {
      e = error;
      return callback("Unable to load '" + metadata.name + "': " + e.message);
    }
  };

  LocalStorageProvider.prototype.list = function(metadata, callback) {
    var filename, key, list, name, prefix, ref, ref1, remainder;
    list = [];
    prefix = this._getKey(((metadata != null ? metadata.path() : void 0) || []).join('/'));
    ref = window.localStorage;
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      if (key.substr(0, prefix.length) === prefix) {
        ref1 = key.substr(prefix.length).split('/'), filename = ref1[0], remainder = 2 <= ref1.length ? slice.call(ref1, 1) : [];
        name = key.substr(prefix.length);
        if (this.matchesExtension(name)) {
          list.push(new CloudMetadata({
            name: name,
            type: remainder.length > 0 ? CloudMetadata.Folder : CloudMetadata.File,
            parent: metadata,
            provider: this
          }));
        }
      }
    }
    return callback(null, list);
  };

  LocalStorageProvider.prototype.remove = function(metadata, callback) {
    try {
      window.localStorage.removeItem(this._getKey(metadata.filename));
      return typeof callback === "function" ? callback(null) : void 0;
    } catch (error) {
      return typeof callback === "function" ? callback('Unable to delete') : void 0;
    }
  };

  LocalStorageProvider.prototype.rename = function(metadata, newName, callback) {
    var content;
    try {
      content = window.localStorage.getItem(this._getKey(metadata.filename));
      window.localStorage.setItem(this._getKey(CloudMetadata.withExtension(newName)), content);
      window.localStorage.removeItem(this._getKey(metadata.filename));
      metadata.rename(newName);
      return callback(null, metadata);
    } catch (error) {
      return typeof callback === "function" ? callback('Unable to rename') : void 0;
    }
  };

  LocalStorageProvider.prototype.canOpenSaved = function() {
    return true;
  };

  LocalStorageProvider.prototype.openSaved = function(openSavedParams, callback) {
    var metadata;
    metadata = new CloudMetadata({
      name: openSavedParams,
      type: CloudMetadata.File,
      parent: null,
      provider: this
    });
    return this.load(metadata, function(err, content) {
      return callback(err, content, metadata);
    });
  };

  LocalStorageProvider.prototype.getOpenSavedParams = function(metadata) {
    return metadata.name;
  };

  LocalStorageProvider.prototype._getKey = function(name) {
    if (name == null) {
      name = '';
    }
    return "cfm::" + (name.replace(/\t/g, ' '));
  };

  return LocalStorageProvider;

})(ProviderInterface);

module.exports = LocalStorageProvider;


},{"../utils/translate":80,"./provider-interface":65}],63:[function(require,module,exports){
var PatchableContent, jiff;

jiff = require('jiff');

PatchableContent = (function() {
  function PatchableContent(patchObjectHash, savedContent) {
    this.patchObjectHash = patchObjectHash;
    this.savedContent = savedContent;
  }

  PatchableContent.prototype.createPatch = function(content, canPatch) {
    var diff, result;
    diff = canPatch && this.savedContent ? this._createDiff(this.savedContent, content) : void 0;
    result = {
      shouldPatch: false,
      mimeType: 'application/json',
      contentJson: JSON.stringify(content),
      diffLength: diff && diff.length,
      diffJson: diff && JSON.stringify(diff)
    };
    if (canPatch && (result.diffJson != null) && result.diffJson.length < result.contentJson.length) {
      result.shouldPatch = true;
      result.sendContent = result.diffJson;
      result.mimeType = 'application/json-patch+json';
    } else {
      result.sendContent = result.contentJson;
    }
    return result;
  };

  PatchableContent.prototype.updateContent = function(content) {
    return this.savedContent = content;
  };

  PatchableContent.prototype._createDiff = function(obj1, obj2) {
    var cleanedObj1, cleanedObj2, diff, opts;
    try {
      opts = {
        hash: typeof this.patchObjectHash === "function" ? this.patchObjectHash : void 0,
        invertible: false
      };
      cleanedObj1 = JSON.parse(JSON.stringify(obj1));
      cleanedObj2 = JSON.parse(JSON.stringify(obj2));
      diff = jiff.diff(cleanedObj1, cleanedObj2, opts);
      return diff;
    } catch (error) {
      return null;
    }
  };

  return PatchableContent;

})();

module.exports = PatchableContent;


},{"jiff":20}],64:[function(require,module,exports){
var PostMessageProvider, ProviderInterface, getQueryParam,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ProviderInterface = (require('./provider-interface')).ProviderInterface;

getQueryParam = require('../utils/get-query-param');

PostMessageProvider = (function(superClass) {
  extend(PostMessageProvider, superClass);

  PostMessageProvider.Name = 'postMessage';

  function PostMessageProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    PostMessageProvider.__super__.constructor.call(this, {
      capabilities: {
        save: false,
        resave: false,
        "export": getQueryParam("saveSecondaryFileViaPostMessage") ? 'auto' : false,
        load: false,
        list: false,
        remove: false,
        rename: false,
        close: false
      }
    });
  }

  PostMessageProvider.prototype.canOpenSaved = function() {
    return false;
  };

  PostMessageProvider.prototype.saveAsExport = function(content, metadata, callback) {
    window.parent.postMessage({
      action: "saveSecondaryFile",
      extension: metadata.extension,
      mimeType: metadata.mimeType,
      content: content
    }, "*");
    return typeof callback === "function" ? callback(null) : void 0;
  };

  return PostMessageProvider;

})(ProviderInterface);

module.exports = PostMessageProvider;


},{"../utils/get-query-param":70,"./provider-interface":65}],65:[function(require,module,exports){
var CloudContent, CloudContentFactory, CloudFile, CloudMetadata, ProviderInterface, div, isString,
  hasProp = {}.hasOwnProperty;

div = React.DOM.div;

isString = require('../utils/is-string');

CloudFile = (function() {
  function CloudFile(options) {
    this.content = options.content, this.metadata = options.metadata;
  }

  return CloudFile;

})();

CloudMetadata = (function() {
  function CloudMetadata(options) {
    var ref, ref1, ref2;
    this.name = options.name, this.type = options.type, this.description = options.description, this.content = options.content, this.url = options.url, this.provider = (ref = options.provider) != null ? ref : null, this.parent = (ref1 = options.parent) != null ? ref1 : null, this.providerData = (ref2 = options.providerData) != null ? ref2 : {}, this.overwritable = options.overwritable, this.sharedContentId = options.sharedContentId, this.sharedContentSecretKey = options.sharedContentSecretKey, this.mimeType = options.mimeType;
    this._updateFilename();
  }

  CloudMetadata.Folder = 'folder';

  CloudMetadata.File = 'file';

  CloudMetadata.Label = 'label';

  CloudMetadata.Extension = null;

  CloudMetadata.mapTypeToCloudMetadataType = function(iType) {
    return iType || this.File;
  };

  CloudMetadata.withExtension = function(name, defaultExtension, keepOriginalExtension) {
    var extension;
    if (keepOriginalExtension && ~name.indexOf(".")) {
      return name;
    }
    extension = CloudMetadata.Extension || defaultExtension;
    if (extension) {
      return this.newExtension(name, extension);
    } else {
      return name;
    }
  };

  CloudMetadata.newExtension = function(name, extension) {
    name = name.substr(0, name.lastIndexOf('.')) || name;
    return name + "." + extension;
  };

  CloudMetadata.prototype.path = function() {
    var _path, parent;
    _path = [];
    parent = this.parent;
    while (parent !== null) {
      _path.unshift(parent);
      parent = parent.parent;
    }
    return _path;
  };

  CloudMetadata.prototype.rename = function(newName) {
    this.name = newName;
    return this._updateFilename();
  };

  CloudMetadata.prototype._updateFilename = function() {
    var extLen, ref;
    this.filename = this.name;
    if ((((ref = this.name) != null ? ref.substr : void 0) != null) && (CloudMetadata.Extension != null) && this.type === CloudMetadata.File) {
      extLen = CloudMetadata.Extension.length;
      if (this.name.substr(-extLen + 1) === ("." + CloudMetadata.Extension)) {
        this.name = this.name.substr(0, this.name.length - (extLen + 1));
      }
      return this.filename = CloudMetadata.withExtension(this.name, null, true);
    }
  };

  return CloudMetadata;

})();

CloudContentFactory = (function() {
  function CloudContentFactory() {
    this.envelopeMetadata = {};
  }

  CloudContentFactory.prototype.setEnvelopeMetadata = function(envelopeMetadata) {
    var key, results;
    results = [];
    for (key in envelopeMetadata) {
      results.push(this.envelopeMetadata[key] = envelopeMetadata[key]);
    }
    return results;
  };

  CloudContentFactory.prototype.createEnvelopedCloudContent = function(content) {
    return new CloudContent(this.envelopContent(content), this._identifyContentFormat(content));
  };

  CloudContentFactory.prototype.envelopContent = function(content) {
    var envelopedCloudContent, key;
    envelopedCloudContent = this._wrapIfNeeded(content);
    for (key in this.envelopeMetadata) {
      if (envelopedCloudContent[key] == null) {
        envelopedCloudContent[key] = this.envelopeMetadata[key];
      }
    }
    return envelopedCloudContent;
  };

  CloudContentFactory.prototype._identifyContentFormat = function(content) {
    var result;
    if (content == null) {
      return;
    }
    result = {
      isCfmWrapped: false,
      isPreCfmFormat: false
    };
    if (isString(content)) {
      try {
        content = JSON.parse(content);
      } catch (error) {}
    }
    if (content.metadata) {
      return result;
    }
    if ((content.cfmVersion != null) || (content.content != null)) {
      result.isCfmWrapped = true;
    } else {
      result.isPreCfmFormat = true;
    }
    return result;
  };

  CloudContentFactory.prototype._wrapIfNeeded = function(content) {
    if (isString(content)) {
      try {
        content = JSON.parse(content);
      } catch (error) {}
    }
    if (content.content != null) {
      return content;
    } else {
      return {
        content: content
      };
    }
  };

  return CloudContentFactory;

})();

CloudContent = (function() {
  CloudContent.wrapFileContent = true;

  function CloudContent(_1, _contentFormat) {
    this._ = _1 != null ? _1 : {};
    this._contentFormat = _contentFormat;
  }

  CloudContent.prototype.getContent = function() {
    if (CloudContent.wrapFileContent) {
      return this._;
    } else {
      return this._.content;
    }
  };

  CloudContent.prototype.getContentAsJSON = function() {
    return JSON.stringify(CloudContent.wrapFileContent ? this._ : this._.content);
  };

  CloudContent.prototype.getClientContent = function() {
    return this._.content;
  };

  CloudContent.prototype.requiresConversion = function() {
    var ref, ref1;
    return (CloudContent.wrapFileContent !== ((ref = this._contentFormat) != null ? ref.isCfmWrapped : void 0)) || ((ref1 = this._contentFormat) != null ? ref1.isPreCfmFormat : void 0);
  };

  CloudContent.prototype.clone = function() {
    return new CloudContent(_.cloneDeep(this._), _.cloneDeep(this._contentFormat));
  };

  CloudContent.prototype.setText = function(text) {
    return this._.content = text;
  };

  CloudContent.prototype.getText = function() {
    if (this._.content === null) {
      return '';
    } else if (isString(this._.content)) {
      return this._.content;
    } else {
      return JSON.stringify(this._.content);
    }
  };

  CloudContent.prototype.addMetadata = function(metadata) {
    var key, results;
    results = [];
    for (key in metadata) {
      results.push(this._[key] = metadata[key]);
    }
    return results;
  };

  CloudContent.prototype.get = function(prop) {
    return this._[prop];
  };

  CloudContent.prototype.set = function(prop, value) {
    return this._[prop] = value;
  };

  CloudContent.prototype.remove = function(prop) {
    return delete this._[prop];
  };

  CloudContent.prototype.getSharedMetadata = function() {
    var shared;
    shared = {};
    if (this._._permissions != null) {
      shared._permissions = this._._permissions;
    }
    if (this._.shareEditKey != null) {
      shared.shareEditKey = this._.shareEditKey;
    }
    if (this._.sharedDocumentId != null) {
      shared.sharedDocumentId = this._.sharedDocumentId;
    }
    if (this._.accessKeys != null) {
      shared.accessKeys = this._.accessKeys;
    }
    return shared;
  };

  CloudContent.prototype.copyMetadataTo = function(to) {
    var key, metadata, ref, value;
    metadata = {};
    ref = this._;
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      value = ref[key];
      if (key !== 'content') {
        metadata[key] = value;
      }
    }
    return to.addMetadata(metadata);
  };

  return CloudContent;

})();

ProviderInterface = (function() {
  function ProviderInterface(options) {
    this.name = options.name, this.displayName = options.displayName, this.urlDisplayName = options.urlDisplayName, this.capabilities = options.capabilities;
  }

  ProviderInterface.Available = function() {
    return true;
  };

  ProviderInterface.prototype.can = function(capability) {
    return !!this.capabilities[capability];
  };

  ProviderInterface.prototype.canAuto = function(capability) {
    return this.capabilities[capability] === 'auto';
  };

  ProviderInterface.prototype.isAuthorizationRequired = function() {
    return false;
  };

  ProviderInterface.prototype.authorized = function(callback) {
    if (callback) {
      return callback(true);
    } else {
      return true;
    }
  };

  ProviderInterface.prototype.renderAuthorizationDialog = function() {
    return AuthorizationNotImplementedDialog({
      provider: this
    });
  };

  ProviderInterface.prototype.renderUser = function() {
    return null;
  };

  ProviderInterface.prototype.filterTabComponent = function(capability, defaultComponent) {
    return defaultComponent;
  };

  ProviderInterface.prototype.matchesExtension = function(name) {
    var extension, i, len, ref;
    if (!name) {
      return false;
    }
    if ((CloudMetadata.ReadableExtensions != null) && CloudMetadata.ReadableExtensions.length > 0) {
      ref = CloudMetadata.ReadableExtensions;
      for (i = 0, len = ref.length; i < len; i++) {
        extension = ref[i];
        if (name.substr(-extension.length) === extension) {
          return true;
        }
        if (extension === "") {
          if (!~name.indexOf(".")) {
            return true;
          }
        }
      }
      return false;
    } else {
      return true;
    }
  };

  ProviderInterface.prototype.handleUrlParams = function() {
    return false;
  };

  ProviderInterface.prototype.dialog = function(callback) {
    return this._notImplemented('dialog');
  };

  ProviderInterface.prototype.save = function(content, metadata, callback) {
    return this._notImplemented('save');
  };

  ProviderInterface.prototype.saveAsExport = function(content, metadata, callback) {
    if (this.can('save', metadata)) {
      return this.save(content, metadata, callback);
    } else {
      return this._notImplemented('saveAsExport');
    }
  };

  ProviderInterface.prototype.load = function(callback) {
    return this._notImplemented('load');
  };

  ProviderInterface.prototype.list = function(metadata, callback) {
    return this._notImplemented('list');
  };

  ProviderInterface.prototype.remove = function(metadata, callback) {
    return this._notImplemented('remove');
  };

  ProviderInterface.prototype.rename = function(metadata, newName, callback) {
    return this._notImplemented('rename');
  };

  ProviderInterface.prototype.close = function(metadata, callback) {
    return this._notImplemented('close');
  };

  ProviderInterface.prototype.setFolder = function(metadata) {
    return this._notImplemented('setFolder');
  };

  ProviderInterface.prototype.canOpenSaved = function() {
    return false;
  };

  ProviderInterface.prototype.openSaved = function(openSavedParams, callback) {
    return this._notImplemented('openSaved');
  };

  ProviderInterface.prototype.getOpenSavedParams = function(metadata) {
    return this._notImplemented('getOpenSavedParams');
  };

  ProviderInterface.prototype.fileOpened = function() {};

  ProviderInterface.prototype._notImplemented = function(methodName) {
    return alert(methodName + " not implemented for " + this.name + " provider");
  };

  return ProviderInterface;

})();

module.exports = {
  CloudFile: CloudFile,
  CloudMetadata: CloudMetadata,
  CloudContent: CloudContent,
  cloudContentFactory: new CloudContentFactory(),
  ProviderInterface: ProviderInterface
};


},{"../utils/is-string":72}],66:[function(require,module,exports){
var CloudMetadata, ProviderInterface, ReadOnlyProvider, cloudContentFactory, isArray, isString, tr,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

tr = require('../utils/translate');

isString = require('../utils/is-string');

isArray = require('../utils/is-array');

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

ReadOnlyProvider = (function(superClass) {
  extend(ReadOnlyProvider, superClass);

  function ReadOnlyProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    ReadOnlyProvider.__super__.constructor.call(this, {
      name: ReadOnlyProvider.Name,
      displayName: this.options.displayName || (tr('~PROVIDER.READ_ONLY')),
      urlDisplayName: this.options.urlDisplayName,
      capabilities: {
        save: false,
        resave: false,
        "export": false,
        load: true,
        list: true,
        remove: false,
        rename: false,
        close: false
      }
    });
    this.tree = null;
    this.promises = [];
  }

  ReadOnlyProvider.Name = 'readOnly';

  ReadOnlyProvider.prototype.load = function(metadata, callback) {
    if (metadata && !isArray(metadata && metadata.type === CloudMetadata.File)) {
      if (metadata.content != null) {
        callback(null, metadata.content);
      } else if (metadata.url != null) {
        $.ajax({
          dataType: 'json',
          url: metadata.url,
          success: function(data) {
            return callback(null, cloudContentFactory.createEnvelopedCloudContent(data));
          },
          error: function() {
            return callback("Unable to load '" + metadata.name + "'");
          }
        });
      } else if ((metadata != null ? metadata.name : void 0) != null) {
        return this._loadTree((function(_this) {
          return function(err, tree) {
            var file;
            if (err) {
              return callback(err);
            }
            file = _this._findFile(tree, metadata.name);
            if (file != null) {
              _this.load(file, callback);
            } else {
              callback("Unable to load '" + metadata.name + "'");
            }
          };
        })(this));
      }
    } else {
      return callback("Unable to load specified content");
    }
  };

  ReadOnlyProvider.prototype.list = function(metadata, callback) {
    return this._loadTree((function(_this) {
      return function(err, tree) {
        var items;
        if (err) {
          return callback(err);
        }
        items = (metadata != null ? metadata.type : void 0) === CloudMetadata.Folder ? metadata.providerData.children : _this.tree;
        return callback(null, _.map(items, function(metadataItem) {
          return new CloudMetadata(metadataItem);
        }));
      };
    })(this));
  };

  ReadOnlyProvider.prototype.canOpenSaved = function() {
    return true;
  };

  ReadOnlyProvider.prototype.openSaved = function(openSavedParams, callback) {
    var metadata;
    metadata = new CloudMetadata({
      name: unescape(openSavedParams),
      type: CloudMetadata.File,
      parent: null,
      provider: this
    });
    return this.load(metadata, function(err, content) {
      return callback(err, content, metadata);
    });
  };

  ReadOnlyProvider.prototype.getOpenSavedParams = function(metadata) {
    return metadata.name;
  };

  ReadOnlyProvider.prototype._loadTree = function(callback) {
    var complete;
    complete = (function(_this) {
      return function(iTree) {
        return Promise.all(_this.promises).then((function() {
          if (iTree != null) {
            return callback(null, iTree);
          } else {
            if (typeof console.error === "function") {
              console.error("No contents found for " + this.displayName + " provider");
            }
            return callback(null, {});
          }
        }), (function() {
          return callback("No contents found for " + this.displayName + " provider");
        }));
      };
    })(this);
    if (this.tree !== null) {
      return complete(this.tree);
    } else if (this.options.json) {
      this.tree = this._convertJSONToMetadataTree(this.options.json);
      return complete(this.tree);
    } else if (this.options.jsonCallback) {
      return this.options.jsonCallback((function(_this) {
        return function(err, json) {
          if (err) {
            return callback(err);
          } else {
            _this.tree = _this._convertJSONToMetadataTree(_this.options.json);
            return complete(_this.tree);
          }
        };
      })(this));
    } else if (this.options.src) {
      return $.ajax({
        dataType: 'json',
        url: this.options.src,
        success: (function(_this) {
          return function(iResponse) {
            _this.tree = _this._convertJSONToMetadataTree(iResponse);
            if (_this.options.alphabetize) {
              _this.tree.sort(function(iMeta1, iMeta2) {
                if (iMeta1.name < iMeta2.name) {
                  return -1;
                }
                if (iMeta1.name > iMeta2.name) {
                  return 1;
                }
                return 0;
              });
            }
            return complete(_this.tree);
          };
        })(this),
        error: (function(_this) {
          return function(jqXHR, textStatus, errorThrown) {
            var errorMetadata;
            errorMetadata = _this._createErrorMetadata(null);
            _this.tree = [errorMetadata];
            return complete(_this.tree);
          };
        })(this)
      });
    } else {
      return complete(null);
    }
  };

  ReadOnlyProvider.prototype._convertJSONToMetadataTree = function(json, parent) {
    var filename, i, item, itemContent, len, metadata, newFolderPromise, tree, type;
    if (parent == null) {
      parent = null;
    }
    tree = [];
    if (isArray(json)) {
      for (i = 0, len = json.length; i < len; i++) {
        item = json[i];
        type = CloudMetadata.mapTypeToCloudMetadataType(item.type);
        metadata = new CloudMetadata({
          name: item.name,
          type: type,
          description: item.description,
          mimeType: item.mimeType,
          content: item.content != null ? cloudContentFactory.createEnvelopedCloudContent(item.content) : void 0,
          url: item.url || item.location,
          parent: parent,
          provider: this,
          providerData: {
            children: null
          }
        });
        if (type === CloudMetadata.Folder) {
          newFolderPromise = (function(_this) {
            return function(iItem, iMetadata) {
              return new Promise(function(resolve, reject) {
                if (iItem.children != null) {
                  iMetadata.providerData.children = _this._convertJSONToMetadataTree(iItem.children, iMetadata);
                  return resolve(iMetadata);
                } else if (iItem.url != null) {
                  return $.ajax({
                    dataType: 'json',
                    url: iItem.url,
                    success: function(iResponse) {
                      iMetadata.providerData.children = _this._convertJSONToMetadataTree(iResponse, iMetadata);
                      if (_this.options.alphabetize || iItem.alphabetize) {
                        iMetadata.providerData.children.sort(function(iMeta1, iMeta2) {
                          if (iMeta1.name < iMeta2.name) {
                            return -1;
                          }
                          if (iMeta1.name > iMeta2.name) {
                            return 1;
                          }
                          return 0;
                        });
                      }
                      return resolve(iMetadata);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                      var errorMetadata;
                      errorMetadata = _this._createErrorMetadata(iMetadata);
                      iMetadata.providerData.children = [errorMetadata];
                      return resolve(iMetadata);
                    }
                  });
                }
              });
            };
          })(this);
          this.promises.push(newFolderPromise(item, metadata));
        }
        tree.push(metadata);
      }
    } else {
      for (filename in json) {
        if (!hasProp.call(json, filename)) continue;
        itemContent = json[filename];
        type = isString(itemContent) ? CloudMetadata.File : CloudMetadata.Folder;
        metadata = new CloudMetadata({
          name: filename,
          type: type,
          content: cloudContentFactory.createEnvelopedCloudContent(itemContent),
          parent: parent,
          provider: this,
          providerData: {
            children: null
          }
        });
        if (type === CloudMetadata.Folder) {
          metadata.providerData.children = this._convertJSONToMetadataTree(itemContent, metadata);
        }
        tree.push(metadata);
      }
    }
    return tree;
  };

  ReadOnlyProvider.prototype._findFile = function(arr, filename) {
    var foundChild, i, item, len, ref, ref1;
    for (i = 0, len = arr.length; i < len; i++) {
      item = arr[i];
      if (item.type === CloudMetadata.File) {
        if ((item != null ? item.name : void 0) === filename) {
          return item;
        }
      } else if ((ref = item.providerData) != null ? (ref1 = ref.children) != null ? ref1.length : void 0 : void 0) {
        foundChild = this._findFile(item.providerData.children, filename);
        if (foundChild != null) {
          return foundChild;
        }
      }
    }
    return null;
  };

  ReadOnlyProvider.prototype._createErrorMetadata = function(iParent) {
    return new CloudMetadata({
      name: tr("~FILE_DIALOG.LOAD_FOLDER_ERROR"),
      type: CloudMetadata.Label,
      content: "",
      parent: iParent,
      provider: this,
      providerData: {
        children: null
      }
    });
  };

  return ReadOnlyProvider;

})(ProviderInterface);

module.exports = ReadOnlyProvider;


},{"../utils/is-array":71,"../utils/is-string":72,"../utils/translate":80,"./provider-interface":65}],67:[function(require,module,exports){
var CloudMetadata, ProviderInterface, URLProvider, cloudContentFactory,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ProviderInterface = (require('./provider-interface')).ProviderInterface;

cloudContentFactory = (require('./provider-interface')).cloudContentFactory;

CloudMetadata = (require('./provider-interface')).CloudMetadata;

URLProvider = (function(superClass) {
  extend(URLProvider, superClass);

  function URLProvider(options, client) {
    this.options = options != null ? options : {};
    this.client = client;
    URLProvider.__super__.constructor.call(this, {
      capabilities: {
        save: false,
        resave: false,
        "export": false,
        load: false,
        list: false,
        remove: false,
        rename: false,
        close: false
      }
    });
  }

  URLProvider.prototype.canOpenSaved = function() {
    return false;
  };

  URLProvider.prototype.openFileFromUrl = function(url, callback) {
    var metadata;
    metadata = new CloudMetadata({
      type: CloudMetadata.File,
      url: url,
      parent: null,
      provider: this
    });
    return $.ajax({
      dataType: 'json',
      url: metadata.url,
      success: function(data) {
        return callback(null, cloudContentFactory.createEnvelopedCloudContent(data), metadata);
      },
      error: function() {
        return callback("Unable to load document from '" + metadata.url + "'");
      }
    });
  };

  return URLProvider;

})(ProviderInterface);

module.exports = URLProvider;


},{"./provider-interface":65}],68:[function(require,module,exports){
var CloudFileManagerUI, CloudFileManagerUIEvent, CloudFileManagerUIMenu, isString, tr;

tr = require('./utils/translate');

isString = require('./utils/is-string');

CloudFileManagerUIEvent = (function() {
  function CloudFileManagerUIEvent(type, data1) {
    this.type = type;
    this.data = data1 != null ? data1 : {};
  }

  return CloudFileManagerUIEvent;

})();

CloudFileManagerUIMenu = (function() {
  CloudFileManagerUIMenu.DefaultMenu = ['newFileDialog', 'openFileDialog', 'revertSubMenu', 'separator', 'save', 'createCopy', 'shareSubMenu', 'renameDialog'];

  function CloudFileManagerUIMenu(options, client) {
    this.options = options;
    this.items = this.parseMenuItems(options.menu, client);
  }

  CloudFileManagerUIMenu.prototype.parseMenuItems = function(menuItems, client) {
    var getItems, i, item, items, j, len, menuItem, names, ref, setAction, setEnabled, subMenus;
    setAction = function(action) {
      var ref;
      return ((ref = client[action]) != null ? ref.bind(client) : void 0) || (function() {
        return client.alert("No " + action + " action is available in the client");
      });
    };
    setEnabled = function(action) {
      switch (action) {
        case 'revertSubMenu':
          return function() {
            return ((client.state.openedContent != null) && (client.state.metadata != null)) || client.canEditShared();
          };
        case 'revertToLastOpenedDialog':
          return function() {
            return (client.state.openedContent != null) && (client.state.metadata != null);
          };
        case 'shareGetLink':
        case 'shareSubMenu':
          return function() {
            return client.state.shareProvider != null;
          };
        case 'revertToSharedDialog':
          return function() {
            return client.isShared();
          };
        case 'shareUpdate':
          return function() {
            return client.canEditShared();
          };
        default:
          return true;
      }
    };
    getItems = (function(_this) {
      return function(subMenuItems) {
        if (subMenuItems) {
          return _this.parseMenuItems(subMenuItems, client);
        } else {
          return null;
        }
      };
    })(this);
    names = {
      newFileDialog: tr("~MENU.NEW"),
      openFileDialog: tr("~MENU.OPEN"),
      closeFileDialog: tr("~MENU.CLOSE"),
      revertToLastOpenedDialog: tr("~MENU.REVERT_TO_LAST_OPENED"),
      revertToSharedDialog: tr("~MENU.REVERT_TO_SHARED_VIEW"),
      save: tr("~MENU.SAVE"),
      saveFileAsDialog: tr("~MENU.SAVE_AS"),
      saveSecondaryFileAsDialog: tr("~MENU.EXPORT_AS"),
      createCopy: tr("~MENU.CREATE_COPY"),
      shareGetLink: tr("~MENU.SHARE_GET_LINK"),
      shareUpdate: tr("~MENU.SHARE_UPDATE"),
      downloadDialog: tr("~MENU.DOWNLOAD"),
      renameDialog: tr("~MENU.RENAME"),
      revertSubMenu: tr("~MENU.REVERT_TO"),
      shareSubMenu: tr("~MENU.SHARE")
    };
    subMenus = {
      revertSubMenu: ['revertToLastOpenedDialog', 'revertToSharedDialog'],
      shareSubMenu: ['shareGetLink', 'shareUpdate']
    };
    items = [];
    for (i = j = 0, len = menuItems.length; j < len; i = ++j) {
      item = menuItems[i];
      if (item === 'separator') {
        menuItem = {
          key: "seperator" + i,
          separator: true
        };
      } else if (isString(item)) {
        menuItem = {
          key: item,
          name: ((ref = this.options.menuNames) != null ? ref[item] : void 0) || names[item] || ("Unknown item: " + item),
          enabled: setEnabled(item),
          items: getItems(subMenus[item]),
          action: setAction(item)
        };
      } else {
        menuItem = item;
        if (isString(item.action)) {
          menuItem.key = item.action;
          menuItem.enabled = setEnabled(item.action);
          menuItem.action = setAction(item.action);
        } else {
          menuItem.enabled || (menuItem.enabled = true);
        }
        if (item.items) {
          menuItem.items = getItems(item.items);
        }
      }
      items.push(menuItem);
    }
    return items;
  };

  return CloudFileManagerUIMenu;

})();

CloudFileManagerUI = (function() {
  function CloudFileManagerUI(client1) {
    this.client = client1;
    this.menu = null;
    this.listenerCallbacks = [];
  }

  CloudFileManagerUI.prototype.init = function(options) {
    options = options || {};
    if (options.menu !== null) {
      if (typeof options.menu === 'undefined') {
        options.menu = CloudFileManagerUIMenu.DefaultMenu;
      }
      return this.menu = new CloudFileManagerUIMenu(options, this.client);
    }
  };

  CloudFileManagerUI.prototype.listen = function(callback) {
    return this.listenerCallbacks.push(callback);
  };

  CloudFileManagerUI.prototype.listenerCallback = function(evt) {
    var callback, j, len, ref, results;
    ref = this.listenerCallbacks;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      callback = ref[j];
      results.push(callback(evt));
    }
    return results;
  };

  CloudFileManagerUI.prototype.appendMenuItem = function(item) {
    return this.listenerCallback(new CloudFileManagerUIEvent('appendMenuItem', item));
  };

  CloudFileManagerUI.prototype.prependMenuItem = function(item) {
    return this.listenerCallback(new CloudFileManagerUIEvent('prependMenuItem', item));
  };

  CloudFileManagerUI.prototype.replaceMenuItem = function(key, item) {
    return this.listenerCallback(new CloudFileManagerUIEvent('replaceMenuItem', {
      key: key,
      item: item
    }));
  };

  CloudFileManagerUI.prototype.insertMenuItemBefore = function(key, item) {
    return this.listenerCallback(new CloudFileManagerUIEvent('insertMenuItemBefore', {
      key: key,
      item: item
    }));
  };

  CloudFileManagerUI.prototype.insertMenuItemAfter = function(key, item) {
    return this.listenerCallback(new CloudFileManagerUIEvent('insertMenuItemAfter', {
      key: key,
      item: item
    }));
  };

  CloudFileManagerUI.prototype.setMenuBarInfo = function(info) {
    return this.listenerCallback(new CloudFileManagerUIEvent('setMenuBarInfo', info));
  };

  CloudFileManagerUI.prototype.saveFileDialog = function(callback) {
    return this._showProviderDialog('saveFile', tr('~DIALOG.SAVE'), callback);
  };

  CloudFileManagerUI.prototype.saveFileAsDialog = function(callback) {
    return this._showProviderDialog('saveFileAs', tr('~DIALOG.SAVE_AS'), callback);
  };

  CloudFileManagerUI.prototype.saveSecondaryFileAsDialog = function(data, callback) {
    return this._showProviderDialog('saveSecondaryFileAs', tr('~DIALOG.EXPORT_AS'), callback, data);
  };

  CloudFileManagerUI.prototype.openFileDialog = function(callback) {
    return this._showProviderDialog('openFile', tr('~DIALOG.OPEN'), callback);
  };

  CloudFileManagerUI.prototype.importDataDialog = function(callback) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showImportDialog', {
      callback: callback
    }));
  };

  CloudFileManagerUI.prototype.downloadDialog = function(filename, content, callback) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showDownloadDialog', {
      filename: filename,
      content: content,
      callback: callback
    }));
  };

  CloudFileManagerUI.prototype.renameDialog = function(filename, callback) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showRenameDialog', {
      filename: filename,
      callback: callback
    }));
  };

  CloudFileManagerUI.prototype.shareDialog = function(client, enableLaraSharing) {
    if (enableLaraSharing == null) {
      enableLaraSharing = false;
    }
    return this.listenerCallback(new CloudFileManagerUIEvent('showShareDialog', {
      client: client,
      enableLaraSharing: enableLaraSharing
    }));
  };

  CloudFileManagerUI.prototype.showBlockingModal = function(modalProps) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showBlockingModal', modalProps));
  };

  CloudFileManagerUI.prototype.hideBlockingModal = function() {
    return this.listenerCallback(new CloudFileManagerUIEvent('hideBlockingModal'));
  };

  CloudFileManagerUI.prototype.editInitialFilename = function() {
    return this.listenerCallback(new CloudFileManagerUIEvent('editInitialFilename'));
  };

  CloudFileManagerUI.prototype.alertDialog = function(message, title, callback) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showAlertDialog', {
      title: title,
      message: message,
      callback: callback
    }));
  };

  CloudFileManagerUI.prototype.confirmDialog = function(params) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showConfirmDialog', params));
  };

  CloudFileManagerUI.prototype._showProviderDialog = function(action, title, callback, data) {
    return this.listenerCallback(new CloudFileManagerUIEvent('showProviderDialog', {
      action: action,
      title: title,
      callback: callback,
      data: data
    }));
  };

  return CloudFileManagerUI;

})();

module.exports = {
  CloudFileManagerUIEvent: CloudFileManagerUIEvent,
  CloudFileManagerUI: CloudFileManagerUI,
  CloudFileManagerUIMenu: CloudFileManagerUIMenu
};


},{"./utils/is-string":72,"./utils/translate":80}],69:[function(require,module,exports){
module.exports = function(param) {
  var ret;
  ret = null;
  location.hash.substr(1).split("&").some(function(pair) {
    var key, value;
    key = pair.split("=")[0];
    if (key === param) {
      value = pair.split("=")[1];
      while (true) {
        value = decodeURIComponent(value);
        if (!/%20|%25/.test(value)) {
          break;
        }
      }
      return ret = value;
    }
  });
  return ret;
};


},{}],70:[function(require,module,exports){
module.exports = function(param) {
  var regex, regexS, results;
  param = param.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  regexS = "[\\?&]" + param + "=([^&#]*)";
  regex = new RegExp(regexS);
  results = regex.exec(window.location.href);
  if ((results != null ? results.length : void 0) > 1) {
    return decodeURIComponent(results[1]);
  } else {
    return null;
  }
};


},{}],71:[function(require,module,exports){
module.exports = function(value) {
  return Array.isArray(value || {}.toString.call(value === '[object Array]'));
};


},{}],72:[function(require,module,exports){
module.exports = function(param) {
  return Object.prototype.toString.call(param) === '[object String]';
};


},{}],73:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "Dokument1",
    "~MENU.NEW": "Neu",
    "~MENU.OPEN": "Öffnen",
    "~MENU.CLOSE": "Schließen",
    "~MENU.IMPORT_DATA": "Daten importieren ...",
    "~MENU.SAVE": "Speichern",
    "~MENU.SAVE_AS": "Speichern unter ...",
    "~MENU.EXPORT_AS": "Datei exportieren als ...",
    "~MENU.CREATE_COPY": "Kopie erstellen",
    "~MENU.SHARE": "Teilen ...",
    "~MENU.SHARE_GET_LINK": "Link erhalten für geteilte Ansicht",
    "~MENU.SHARE_UPDATE": "Geteilte Ansicht aktualisieren",
    "~MENU.DOWNLOAD": "Download",
    "~MENU.RENAME": "Umbenennen",
    "~MENU.REVERT_TO": "Zurückkehren ...",
    "~MENU.REVERT_TO_LAST_OPENED": "Kürzlich geöffnete Fassung",
    "~MENU.REVERT_TO_SHARED_VIEW": "Geteilte Ansicht",
    "~DIALOG.SAVE": "Speichern",
    "~DIALOG.SAVE_AS": "Speichern unter ...",
    "~DIALOG.EXPORT_AS": "Datei exportieren als ...",
    "~DIALOG.CREATE_COPY": "Kopie erstellen ...",
    "~DIALOG.OPEN": "Öffnen",
    "~DIALOG.DOWNLOAD": "Download",
    "~DIALOG.RENAME": "Umbenennen",
    "~DIALOG.SHARED": "Teilen",
    "~DIALOG.IMPORT_DATA": "Daten importieren",
    "~PROVIDER.LOCAL_STORAGE": "Lokaler Speicher",
    "~PROVIDER.READ_ONLY": "Leseansicht",
    "~PROVIDER.GOOGLE_DRIVE": "Google Drive",
    "~PROVIDER.DOCUMENT_STORE": "Concord Cloud",
    "~PROVIDER.LOCAL_FILE": "Lokale Datei",
    "~FILE_STATUS.SAVING": "Speichern",
    "~FILE_STATUS.SAVED": "Gespeichert",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "Alle Änderungen gespeichert %{providerName}",
    "~FILE_STATUS.UNSAVED": "Ungespeichert",
    "~FILE_DIALOG.FILENAME": "Dateiname",
    "~FILE_DIALOG.OPEN": "Öffnen",
    "~FILE_DIALOG.SAVE": "Speichern",
    "~FILE_DIALOG.CANCEL": "Abbrechen",
    "~FILE_DIALOG.REMOVE": "Löschen",
    "~FILE_DIALOG.REMOVE_CONFIRM": "Sind Sie sicher, dass %{filename} gelöscht werden soll?",
    "~FILE_DIALOG.REMOVED_TITLE": "Datei löschen",
    "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} wurde gelöscht",
    "~FILE_DIALOG.LOADING": "Laden...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** Fehler beim Laden der Ordnerinhalte ***",
    "~FILE_DIALOG.DOWNLOAD": "Download",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "Achtung: Bei Safari könnte diese Datei \"unbekannt\" heißen und sollte manuell mit der .codap Erweiterung versehen werden.",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "Download",
    "~DOWNLOAD_DIALOG.CANCEL": "Abbrechen",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "Information über Teilen im Dokument ",
    "~RENAME_DIALOG.RENAME": "Umbenennen",
    "~RENAME_DIALOG.CANCEL": "Abbrechen",
    "~SHARE_DIALOG.COPY": "Kopieren",
    "~SHARE_DIALOG.VIEW": "Ansicht",
    "~SHARE_DIALOG.CLOSE": "Schließen",
    "~SHARE_DIALOG.COPY_SUCCESS": "Die Information wurde kopiert.",
    "~SHARE_DIALOG.COPY_ERROR": "Entschuldigung, diese Information konnte nicht kopiert werden.",
    "~SHARE_DIALOG.COPY_TITLE": "Ergebnis kopieren",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "Die geteilte Kopie des Dokuments wird aufbewahrt, bis ein Jahr lang niemand mehr darauf zugreift.",
    "~SHARE_UPDATE.TITLE": "Geteilte Anschicht aktualisiert",
    "~SHARE_UPDATE.MESSAGE": "Die geteilte Ansicht wurde erfolgreich aktualisiert.",
    "~CONFIRM.OPEN_FILE": "Es gibt ungesicherte Änderungen. Wollen Sie wirklich ein neues Dokument öffnen?",
    "~CONFIRM.NEW_FILE": "Es gibt ungesicherte Änderungen. Wollen Sie wirklich ein neues Dokument erstellen?",
    "~CONFIRM.AUTHORIZE_OPEN": "Um dieses Dokument zu öffnen, müssen Sie sich authorisieren. Wollen Sie fortfahren?",
    "~CONFIRM.AUTHORIZE_SAVE": "Um dieses Dokument zu speichern, müssen Sie sich authorisieren. Wollen Sie fortfahren?",
    "~CONFIRM.CLOSE_FILE": "Es gibt ungesicherte Änderungen. Wollen Sie das Dokument wirklich schließen?",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "Sind Sie sicher, dass Sie das Dokument in den zuletzt geöffneten Zustand zurückversetzen möchten?",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "Sind Sie sicher, dass Sie das Dokument in den zuletzt geteilten Zustand zurückversetzen möchten?",
    "~CONFIRM_DIALOG.TITLE": "Sind Sie sicher?",
    "~CONFIRM_DIALOG.YES": "Ja",
    "~CONFIRM_DIALOG.NO": "Nein",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "Datei hierher ziehen oder klicken, um eine Datei auszuwählen",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "Es kann nur eine Datei ausgewählt werden.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "Sie können nur eine Datei hierher ziehen.",
    "~IMPORT.LOCAL_FILE": "Lokale Datei",
    "~IMPORT.URL": "URL",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "Es kann nur eine URL verwendet werden.",
    "~IMPORT_URL.PLEASE_ENTER_URL": "Adresse zum Importieren eingeben.",
    "~URL_TAB.DROP_URL_HERE": "Ziehen Sie die URL hierher oder geben Sie die URL unten ein",
    "~URL_TAB.IMPORT": "Importieren",
    "~CLIENT_ERROR.TITLE": "Fehler",
    "~ALERT_DIALOG.TITLE": "Alarm",
    "~ALERT_DIALOG.CLOSE": "Schließen",
    "~ALERT.NO_PROVIDER": "Das angegebene Dokument konnte nicht geöffnet werden, da kein geeigneter Anbieter verfügbar ist.",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "Login für Google",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "Verbinde zu Google...",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "Fehlende erforderliche ClientId in den GoogleDrive Optionen",
    "~DOCSTORE.LOAD_403_ERROR": "Sie haben keine Erlaubnis, um %{filename}.<br><br> zu laden. Falls Sie ein geteiltes Dokument nutzen, könnte es ungeteilt worden sein.",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "Das angeforderte geteilte Dokument konnte nicht geladen werden. <br><br> Möglicherweise wurde die Datei nicht geteilt?",
    "~DOCSTORE.LOAD_404_ERROR": "%{filename} kann nicht geladen werden",
    "~DOCSTORE.SAVE_403_ERROR": "Sie haben keine Berechtigung, um '%{filename}'.<br><br> zu speichern. Loggen Sie sich erneut ein.",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "%{filename} kann nicht erstellt werden. Das Dokument existiert bereits.",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "Kann nicht gespeichert werden: %{filename}: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "Kann nicht gespeichert werden: %{filename}",
    "~DOCSTORE.REMOVE_403_ERROR": "Sie haben keine Berechtigung, um '%{filename}'.<br><br> zu löschen. Loggen Sie sich erneut ein.",
    "~DOCSTORE.REMOVE_ERROR": "Kann nicht gelöscht werden: %{filename}",
    "~DOCSTORE.RENAME_403_ERROR": "Sie haben keine Berechtigung, um %{filename} umzubenennen.<br><br> Loggin Sie sich erneut ein.",
    "~DOCSTORE.RENAME_ERROR": "Kann nicht umbenannt werden: %{filename}",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Concord Cloud Alarm",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Concord Cloud Alarm",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "An anderer Stelle speichern",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "Ich werde es später tun",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "Die Concord Cloud ist nicht erreichbar.",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Bitte speichern Sie Ihre Dokumente an anderer Stelle.",
    "~SHARE_DIALOG.SHARE_STATE": "Geteilte Ansicht:␣",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "aktiviert",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "deaktiviert",
    "~SHARE_DIALOG.ENABLE_SHARING": "Teilen aktivieren",
    "~SHARE_DIALOG.STOP_SHARING": "Teilen stoppen",
    "~SHARE_DIALOG.UPDATE_SHARING": "Geteilte Ansicht aktualisieren",
    "~SHARE_DIALOG.PREVIEW_SHARING": "Vorschau zu geteilter Ansicht",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "When Teilen aktiviert ist, wird eine Kopie der aktuellen Ansicht erstellt. Diese Kopie kann geteilt werden.",
    "~SHARE_DIALOG.LINK_TAB": "Link",
    "~SHARE_DIALOG.LINK_MESSAGE": "In eine Email oder Nachricht einfügen␣",
    "~SHARE_DIALOG.EMBED_TAB": "Einbetten",
    "~SHARE_DIALOG.EMBED_MESSAGE": "Code einbetten für Webseiten oder andere Inhalte",
    "~SHARE_DIALOG.LARA_MESSAGE": "Diesen Link verwenden, um eine Aktivität in LARA zu erstellen",
    "~SHARE_DIALOG.LARA_CODAP_URL": "CODAP Server URL:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Autolaunch Seite",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Vollbild und Skalieren",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Textbutton",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Datensichtbarkeit in Graphen anzeigen",
    "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?"
}
},{}],74:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "Κείμενο Χωρίς Όνομα",
    "~MENU.NEW": "Νέο",
    "~MENU.OPEN": "Άνοιγμα ...",
    "~MENU.CLOSE": "Κλείσιμο",
    "~MENU.IMPORT_DATA": "Εισαγωγή δεδομένων ...",
    "~MENU.SAVE": "Αποθήκευση",
    "~MENU.SAVE_AS": "Αποθήκευση Ως ...",
    "~MENU.EXPORT_AS": "Εξαγωγή Αρχείου Ως ...",
    "~MENU.CREATE_COPY": "Δημιουργία αντιγράφου",
    "~MENU.SHARE": "Κοινοποίηση",
    "~MENU.SHARE_GET_LINK": "Λήψη συνδέσμου κοινόχρηστης προβολής",
    "~MENU.SHARE_UPDATE": "Επικαιροποίηση κοινόχρηστης προβολής",
    "~MENU.DOWNLOAD": "Λήψη",
    "~MENU.RENAME": "Μετονομασία",
    "~MENU.REVERT_TO": "Επιστροφή στο ...",
    "~MENU.REVERT_TO_LAST_OPENED": "Κατάσταση πρόσφατου ανοίγματος",
    "~MENU.REVERT_TO_SHARED_VIEW": "Κοινόχρηστη προβολή",
    "~DIALOG.SAVE": "Αποθήκευση",
    "~DIALOG.SAVE_AS": "Αποθήκευση Ως ...",
    "~DIALOG.EXPORT_AS": "Εξαγωγή Αρχείου Ως ...",
    "~DIALOG.CREATE_COPY": "Δημιουργία Αντιγράφου ...",
    "~DIALOG.OPEN": "Άνοιγμα",
    "~DIALOG.DOWNLOAD": "Λήψη",
    "~DIALOG.RENAME": "Μετονομασία",
    "~DIALOG.SHARED": "Κοινοποίηση",
    "~DIALOG.IMPORT_DATA": "Εισαγωγή Δεδομένων",
    "~PROVIDER.LOCAL_STORAGE": "Τοπική Αποθήκευση",
    "~PROVIDER.READ_ONLY": "Μόνο Ανάγνωση",
    "~PROVIDER.GOOGLE_DRIVE": "Google Drive",
    "~PROVIDER.DOCUMENT_STORE": "Concord Cloud",
    "~PROVIDER.LOCAL_FILE": "Τοπικό Αρχείο",
    "~FILE_STATUS.SAVING": "Αποθήκευση ...",
    "~FILE_STATUS.SAVED": "Όλες οι αλλαγές αποθηκεύθηκαν",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "Όλες οι αλλαγές αποθηκεύθηκαν στο %{providerName}",
    "~FILE_STATUS.UNSAVED": "Μη Αποθηκευμένο",
    "~FILE_DIALOG.FILENAME": "Όνομα Αρχείου",
    "~FILE_DIALOG.OPEN": "Άνοιγμα",
    "~FILE_DIALOG.SAVE": "Αποθήκευση",
    "~FILE_DIALOG.CANCEL": "Ακύρωση",
    "~FILE_DIALOG.REMOVE": "Διαγραφή",
    "~FILE_DIALOG.REMOVE_CONFIRM": "Θέλετε σίγουρα να διαγράψετε το %{filename};",
    "~FILE_DIALOG.REMOVED_TITLE": "Διαγραφή Αρχείου",
    "~FILE_DIALOG.REMOVED_MESSAGE": "Το %{filename} διαγράφηκε",
    "~FILE_DIALOG.LOADING": "Φόρτωση...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** Σφάλμα φόρτωσης περιεχομένων φακέλου ***",
    "~FILE_DIALOG.DOWNLOAD": "Λήψη",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "ΣΗΜΕΙΩΣΗ: Στο Safari το αρχείο μπορεί να είναι \"Άγνωστο\" και πρέπει να το μετονομάσετε εσείς, προσθέτοντας την κατάληξη .codap",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "Λήψη",
    "~DOWNLOAD_DIALOG.CANCEL": "Ακύρωση",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "Να συμπεριληφθούν πληροφορίες κοινοποίησης στο αρχείο λήψης",
    "~RENAME_DIALOG.RENAME": "Μετονομασία",
    "~RENAME_DIALOG.CANCEL": "Ακύρωση",
    "~SHARE_DIALOG.COPY": "Αντιγραφή",
    "~SHARE_DIALOG.VIEW": "Προβολή",
    "~SHARE_DIALOG.CLOSE": "Κλείσιμο",
    "~SHARE_DIALOG.COPY_SUCCESS": "Η πληροφορίες έχουν αντιγραφεί στο πρόχειρο.",
    "~SHARE_DIALOG.COPY_ERROR": "Λυπούμαστε, οι πληροφορίες δεν ήταν δυνατό να αντιγραφούν στο πρόχειρο.",
    "~SHARE_DIALOG.COPY_TITLE": "Αντιγραφή Αποτελέσματος",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "Το κοινόχρηστο αντίγραφου αυτού του αρχείου θα διατηρηθεί έως ότου δεν έχει προβληθεί για περισσότερο από ένα έτος.",
    "~SHARE_UPDATE.TITLE": "Η Κοινόχρηστη Προβολή Επικαιροποιήθηκε",
    "~SHARE_UPDATE.MESSAGE": "Η κοινόχρηστη προβολή επικαιροποιήθηκε με επιτυχία.",
    "~CONFIRM.OPEN_FILE": "Έχετε μη αποθηκευμένες αλλαγές. Είστε σίγουροι ότι θέλετε να ανοίξετε ένα νέο έγγραφο;",
    "~CONFIRM.NEW_FILE": "Έχετε μη αποθηκευμένες αλλαγές. Είστε σίγουροι ότι θέλετε να δημιουργήσετε ένα νέο έγγραφο;",
    "~CONFIRM.AUTHORIZE_OPEN": "Για το άνοιγμα του εγγράφου απαιτείται έγκριση. Θέλετε να συνεχίσετε με την έγκριση;",
    "~CONFIRM.AUTHORIZE_SAVE": "Για την αποθήκευση του εγγράφου απαιτείται έγκριση. Θέλετε να συνεχίσετε με την έγκριση;",
    "~CONFIRM.CLOSE_FILE": "Έχετε μη αποθηκευμένες αλλαγές. Είστε σίγουροι ότι θέλετε να κλείσετε αυτό το έγγραφο;",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "Είστε σίγουροι ότι θέλετε να επαναφέρετε το έγγραφο στην κατάσταση που το ανοίξατε την τελευταία φορά;",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "Είστε σίγουροι ότι θέλετε να επαναφέρετε το έγγραφο στην κατάσταση που το κοινοποιήσατε την τελευταία φορά;",
    "~CONFIRM_DIALOG.TITLE": "Είστε σίγουροι;",
    "~CONFIRM_DIALOG.YES": "Ναι",
    "~CONFIRM_DIALOG.NO": "Όχι",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "Σύρετε ένα αρχείο εδώ ή πατήστε εδώ για να επιλέξετε ένα αρχείο.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "Λυπούμαστε, μπορείτε να επιλέξετε ένα μόνο αρχείο για να ανοίξετε.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "Λυπούμαστε, δεν μπορείτε να σύρετε περισσότερα από ένα αρχεία.",
    "~IMPORT.LOCAL_FILE": "Τοπικό Αρχείο",
    "~IMPORT.URL": "URL",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "Λυπούμαστε, μπορείτε να επιλέξετε μόνο ένα url για να ανοίξετε.",
    "~IMPORT_URL.PLEASE_ENTER_URL": "Παρακαλούμε πληκτρολογήστε ένα url για εισαγωγή.",
    "~URL_TAB.DROP_URL_HERE": "Σύρετε ένα URL εδώ ή πληκτρολογήστε ένα URL παρακάτω",
    "~URL_TAB.IMPORT": "Εισαγωγή",
    "~CLIENT_ERROR.TITLE": "Σφάλμα",
    "~ALERT_DIALOG.TITLE": "Προειδοποίηση",
    "~ALERT_DIALOG.CLOSE": "Κλείσιμο",
    "~ALERT.NO_PROVIDER": "Αυτο το αρχείο δεν ήταν δυνατό να ανοιχτεί διότι δεν είναι διαθέσιμος ο κατάλληλος πάροχος.",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "Είσοδος στο Google",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "Σύνδεση στο Google...",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "Δεν δόθηκε η απαραίτητη ταυτότητα χρήστη στiς επιλογές παρόχου του googleDrive",
    "~DOCSTORE.LOAD_403_ERROR": "Δεν έχετε δικαίωμα φόρτωσης του %{filename}.<br><br>αν χρησιμοποιείτε κοινόχρηστο έγγραφο κάποιου άλλου, είναι πιθανό να έχει διακοπεί η κοινή χρήση.",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "Δεν ήταν δυνατή η φόρτωση του κοινόχρηστου αρχείου που ζητήσατε.<br><br>Ίσως να μην έγινε κοινή χρήση του αρχείου;",
    "~DOCSTORE.LOAD_404_ERROR": "Δεν ήταν δυνατή η φόρτωση του %{filename}",
    "~DOCSTORE.SAVE_403_ERROR": "Δεν έχετε δικαίωμα αποθήκευσης του '%{filename}'.<br><br>Ίσως χρειάζετε να ξανασυνδεθείτε.",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "Δεν ήταν δυνατή η δημιουργία του %{filename}. Το αρχείο υπάρχει ήδη.",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "Δεν ήταν δυνατή η αποθήκευση του %{filename}: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "Δεν ήταν δυνατή η αποθήκευση του %{filename}",
    "~DOCSTORE.REMOVE_403_ERROR": "Δεν έχετε δικαίωμα διαγραφής του '%{filename}'.<br><br>Ίσως χρειάζετε να ξανασυνδεθείτε. ",
    "~DOCSTORE.REMOVE_ERROR": "Δεν ήταν δυνατή η διαγραφή του %{filename} ",
    "~DOCSTORE.RENAME_403_ERROR": "Δεν έχετε δικαίωμα μετονομασίας του '%{filename}'.<br><br>Ίσως χρειάζετε να ξανασυνδεθείτε. ",
    "~DOCSTORE.RENAME_ERROR": "Δεν ήταν δυνατή η μετονομασία του %{filename} ",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Προειδοποίηση Concord Cloud",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Προειδοποίηση Concord Cloud",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "Αποθήκευση Αλλού",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "Θα το κάνω αργότερα",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "Το Concord Cloud έχει κλείσει!",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Παρακαλούμε αποθηκεύστε τα έγγραφά σας σε άλλη τοποθεσία.",
    "~SHARE_DIALOG.SHARE_STATE": "Κοινόχρηστη προβολή",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "ενεργοποιημένη",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "απενεργοποιημένη",
    "~SHARE_DIALOG.ENABLE_SHARING": "Ενεργοποίηση κοινής χρήσης",
    "~SHARE_DIALOG.STOP_SHARING": "Διακοπή κοινής χρήσης",
    "~SHARE_DIALOG.UPDATE_SHARING": "Επικαιροποίηση κοινόχρηστης προβολής",
    "~SHARE_DIALOG.PREVIEW_SHARING": "Προεπισκόπηση κοινόχρηστης προβολής",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "Όταν ενεργοποιείται η κοινή χρήση, δημιουργείται ένα αντίγραφο της συγκεκριμένης προβολής. Αυτό το αντίγραφο μπορεί να κοινοποιηθεί.",
    "~SHARE_DIALOG.LINK_TAB": "Σύνδεσμος",
    "~SHARE_DIALOG.LINK_MESSAGE": "Επικολλήστε το σε ένα email ή ένα μήνυμα κειμένου",
    "~SHARE_DIALOG.EMBED_TAB": "Ενσωμάτωση",
    "~SHARE_DIALOG.EMBED_MESSAGE": "Κώδικας για ενσωμάτωση σε ιστοσελίδες ή άλλο δικτυακό περιεχόμενο",
    "~SHARE_DIALOG.LARA_MESSAGE": "Χρησιμοποιήστε αυτό το σύνδεσμο όταν δημιουργείτε μια δραστηριότητα στο LARA",
    "~SHARE_DIALOG.LARA_CODAP_URL": "URL του διακομιστή CODAP:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Σελίδα αυτόματης εκτέλεσης",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Πλήκτρο πλήρους οθόνης και κλιμάκωση",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Κείμενο Πλήκτρου Εκτέλεσης",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Η προβολή δεδομένων ενεργοποιεί τα γραφήματα",
    "~CONFIRM.CHANGE_LANGUAGE": "Έχετε μη αποθηκευμένες αλλαγές. Είστε σίγουροι ότι θέλετε να αλλάξετε γλώσσα;"
}
},{}],75:[function(require,module,exports){
module.exports={
  "~MENUBAR.UNTITLED_DOCUMENT": "Untitled Document",

  "~MENU.NEW": "New",
  "~MENU.OPEN": "Open ...",
  "~MENU.CLOSE": "Close",
  "~MENU.IMPORT_DATA": "Import data...",
  "~MENU.SAVE": "Save",
  "~MENU.SAVE_AS": "Save As ...",
  "~MENU.EXPORT_AS": "Export File As ...",
  "~MENU.CREATE_COPY": "Create a copy",
  "~MENU.SHARE": "Share...",
  "~MENU.SHARE_GET_LINK": "Get link to shared view",
  "~MENU.SHARE_UPDATE": "Update shared view",
  "~MENU.DOWNLOAD": "Download",
  "~MENU.RENAME": "Rename",
  "~MENU.REVERT_TO": "Revert to...",
  "~MENU.REVERT_TO_LAST_OPENED": "Recently opened state",
  "~MENU.REVERT_TO_SHARED_VIEW": "Shared view",

  "~DIALOG.SAVE": "Save",
  "~DIALOG.SAVE_AS": "Save As ...",
  "~DIALOG.EXPORT_AS": "Export File As ...",
  "~DIALOG.CREATE_COPY": "Create A Copy ...",
  "~DIALOG.OPEN": "Open",
  "~DIALOG.DOWNLOAD": "Download",
  "~DIALOG.RENAME": "Rename",
  "~DIALOG.SHARED": "Share",
  "~DIALOG.IMPORT_DATA": "Import Data",

  "~PROVIDER.LOCAL_STORAGE": "Local Storage",
  "~PROVIDER.READ_ONLY": "Read Only",
  "~PROVIDER.GOOGLE_DRIVE": "Google Drive",
  "~PROVIDER.DOCUMENT_STORE": "Concord Cloud",
  "~PROVIDER.LOCAL_FILE": "Local File",

  "~FILE_STATUS.SAVING": "Saving...",
  "~FILE_STATUS.SAVED": "All changes saved",
  "~FILE_STATUS.SAVED_TO_PROVIDER": "All changes saved to %{providerName}",
  "~FILE_STATUS.UNSAVED": "Unsaved",

  "~FILE_DIALOG.FILENAME": "Filename",
  "~FILE_DIALOG.OPEN": "Open",
  "~FILE_DIALOG.SAVE": "Save",
  "~FILE_DIALOG.CANCEL": "Cancel",
  "~FILE_DIALOG.REMOVE": "Delete",
  "~FILE_DIALOG.REMOVE_CONFIRM": "Are you sure you want to delete %{filename}?",
  "~FILE_DIALOG.REMOVED_TITLE": "Deleted File",
  "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} was deleted",
  "~FILE_DIALOG.LOADING": "Loading...",
  "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** Error loading folder contents ***",
  "~FILE_DIALOG.DOWNLOAD": "Download",
  "~FILE_DIALOG.DOWNLOAD_NOTE": "NOTE: On Safari file may be \"Unknown\" and should be manually renamed with a .codap extension.",


  "~DOWNLOAD_DIALOG.DOWNLOAD": "Download",
  "~DOWNLOAD_DIALOG.CANCEL": "Cancel",
  "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "Include sharing information in downloaded file",

  "~RENAME_DIALOG.RENAME": "Rename",
  "~RENAME_DIALOG.CANCEL": "Cancel",

  "~SHARE_DIALOG.COPY": "Copy",
  "~SHARE_DIALOG.VIEW": "View",
  "~SHARE_DIALOG.CLOSE": "Close",
  "~SHARE_DIALOG.COPY_SUCCESS": "The info has been copied to the clipboard.",
  "~SHARE_DIALOG.COPY_ERROR": "Sorry, the info was not able to be copied to the clipboard.",
  "~SHARE_DIALOG.COPY_TITLE": "Copy Result",
  "~SHARE_DIALOG.LONGEVITY_WARNING": "The shared copy of this document will be retained until it has not been accessed for over a year.",

  "~SHARE_DIALOG.SHARE_STATE": "Shared view: ",
  "~SHARE_DIALOG.SHARE_STATE_ENABLED": "enabled",
  "~SHARE_DIALOG.SHARE_STATE_DISABLED": "disabled",
  "~SHARE_DIALOG.ENABLE_SHARING": "Enable sharing",
  "~SHARE_DIALOG.STOP_SHARING": "Stop sharing",
  "~SHARE_DIALOG.UPDATE_SHARING": "Update shared view",
  "~SHARE_DIALOG.PREVIEW_SHARING": "Preview shared view",
  "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "When sharing is enabled, a copy of the current view is created.  This copy can be shared.",
  "~SHARE_DIALOG.LINK_TAB": "Link",
  "~SHARE_DIALOG.LINK_MESSAGE": "Paste this into an email or text message ",
  "~SHARE_DIALOG.EMBED_TAB": "Embed",
  "~SHARE_DIALOG.EMBED_MESSAGE": "Embed code for including in webpages or other web-based content",
  "~SHARE_DIALOG.LARA_MESSAGE": "Use this link when creating an activity in LARA",
  "~SHARE_DIALOG.LARA_CODAP_URL": "CODAP Server URL:",
  "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Autolaunch page",
  "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Fullscreen button and scaling",
  "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Launch Button Text:",
  "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Display data visibility toggles on graphs",

  "~SHARE_UPDATE.TITLE": "Shared View Updated",
  "~SHARE_UPDATE.MESSAGE": "The shared view was updated successfully.",

  "~CONFIRM.OPEN_FILE": "You have unsaved changes. Are you sure you want to open a new document?",
  "~CONFIRM.NEW_FILE": "You have unsaved changes. Are you sure you want to create a new document?",
  "~CONFIRM.AUTHORIZE_OPEN": "Authorization is required to open the document. Would you like to proceed with authorization?",
  "~CONFIRM.AUTHORIZE_SAVE": "Authorization is required to save the document. Would you like to proceed with authorization?",
  "~CONFIRM.CLOSE_FILE": "You have unsaved changes. Are you sure you want to close the document?",
  "~CONFIRM.REVERT_TO_LAST_OPENED": "Are you sure you want to revert the document to its most recently opened state?",
  "~CONFIRM.REVERT_TO_SHARED_VIEW": "Are you sure you want to revert the document to its most recently shared state?",
  "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?",

  "~CONFIRM_DIALOG.TITLE": "Are you sure?",
  "~CONFIRM_DIALOG.YES": "Yes",
  "~CONFIRM_DIALOG.NO": "No",

  "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "Drop file here or click here to select a file.",
  "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "Sorry, you can choose only one file to open.",
  "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "Sorry, you can't drop more than one file.",

  "~IMPORT.LOCAL_FILE": "Local File",
  "~IMPORT.URL": "URL",

  "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "Sorry, you can choose only one url to open.",
  "~IMPORT_URL.PLEASE_ENTER_URL": "Please enter a url to import.",

  "~URL_TAB.DROP_URL_HERE": "Drop URL here or enter URL below",
  "~URL_TAB.IMPORT": "Import",

  "~CLIENT_ERROR.TITLE": "Error",

  "~ALERT_DIALOG.TITLE": "Alert",
  "~ALERT_DIALOG.CLOSE": "Close",

  "~ALERT.NO_PROVIDER": "Could not open the specified document because an appropriate provider is not available.",

  "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "Login to Google",
  "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "Connecting to Google...",
  "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "Missing required clientId in googleDrive provider options",

  "~DOCSTORE.LOAD_403_ERROR": "You don't have permission to load %{filename}.<br><br>If you are using some else's shared document it may have been unshared.",
  "~DOCSTORE.LOAD_SHARED_404_ERROR": "Unable to load the requested shared document.<br><br>Perhaps the file was not shared?",
  "~DOCSTORE.LOAD_404_ERROR": "Unable to load %{filename}",
  "~DOCSTORE.SAVE_403_ERROR": "You don't have permission to save '%{filename}'.<br><br>You may need to log in again.",
  "~DOCSTORE.SAVE_DUPLICATE_ERROR": "Unable to create %{filename}.  File already exists.",
  "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "Unable to save %{filename}: [%{message}]",
  "~DOCSTORE.SAVE_ERROR": "Unable to save %{filename}",
  "~DOCSTORE.REMOVE_403_ERROR": "You don't have permission to remove %{filename}.<br><br>You may need to log in again.",
  "~DOCSTORE.REMOVE_ERROR": "Unable to remove %{filename}",
  "~DOCSTORE.RENAME_403_ERROR": "You don't have permission to rename %{filename}.<br><br>You may need to log in again.",
  "~DOCSTORE.RENAME_ERROR": "Unable to rename %{filename}",

  "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Concord Cloud Alert",
  "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Concord Cloud Alert",
  "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "Save Elsewhere",
  "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "I'll do it later",
  "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "The Concord Cloud has been shut down!",
  "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Please save your documents to another location."
}


},{}],76:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "Documento sin título",
    "~MENU.NEW": "Nuevo",
    "~MENU.OPEN": "Abrir ...",
    "~MENU.CLOSE": "Cerrar",
    "~MENU.IMPORT_DATA": "Importar datos...",
    "~MENU.SAVE": "Guardar",
    "~MENU.SAVE_AS": "Guardar como ...",
    "~MENU.EXPORT_AS": "Exportar archivo como ...",
    "~MENU.CREATE_COPY": "Crear una copia",
    "~MENU.SHARE": "Compartir...",
    "~MENU.SHARE_GET_LINK": "Obtener enlace de la vista compartida",
    "~MENU.SHARE_UPDATE": "Actualizar vista compartida",
    "~MENU.DOWNLOAD": "Bajar",
    "~MENU.RENAME": "Renombrar",
    "~MENU.REVERT_TO": "Revertir a...",
    "~MENU.REVERT_TO_LAST_OPENED": "Estado recientemente abierto",
    "~MENU.REVERT_TO_SHARED_VIEW": "Vista compartida",
    "~DIALOG.SAVE": "Guardar",
    "~DIALOG.SAVE_AS": "Guardar como ...",
    "~DIALOG.EXPORT_AS": "Exportar archivo como ...",
    "~DIALOG.CREATE_COPY": "Crear una copia ...",
    "~DIALOG.OPEN": "Abrir",
    "~DIALOG.DOWNLOAD": "Bajar",
    "~DIALOG.RENAME": "Renombrar",
    "~DIALOG.SHARED": "Compartir",
    "~DIALOG.IMPORT_DATA": "Importar datos",
    "~PROVIDER.LOCAL_STORAGE": "Almacenamiento local",
    "~PROVIDER.READ_ONLY": "Sólo lectura",
    "~PROVIDER.GOOGLE_DRIVE": "Google Drive",
    "~PROVIDER.DOCUMENT_STORE": "Concord Cloud",
    "~PROVIDER.LOCAL_FILE": "Archivo local",
    "~FILE_STATUS.SAVING": "Guardando...",
    "~FILE_STATUS.SAVED": "Se guardaron todos los cambios",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "Se guardaron todos los cambios en %{providerName}",
    "~FILE_STATUS.UNSAVED": "Sin guardar",
    "~FILE_DIALOG.FILENAME": "Nombre de archivo",
    "~FILE_DIALOG.OPEN": "Abrir",
    "~FILE_DIALOG.SAVE": "Guardar",
    "~FILE_DIALOG.CANCEL": "Cancelar",
    "~FILE_DIALOG.REMOVE": "Eliminar",
    "~FILE_DIALOG.REMOVE_CONFIRM": "¿Confirma eliminar el archivo %{filename}?",
    "~FILE_DIALOG.REMOVED_TITLE": "Archivo eliminado",
    "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} fue eliminado",
    "~FILE_DIALOG.LOADING": "Cargando...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** Error al cargar contenido de la carpeta ***",
    "~FILE_DIALOG.DOWNLOAD": "Bajar",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "NOTA: En Safari el archivo puede ser \"Desconocido\" y deben ser renombrado de manera manual con extensión .codap",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "Bajar",
    "~DOWNLOAD_DIALOG.CANCEL": "Cancelar",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "Incluir información para compartir en archivo bajado",
    "~RENAME_DIALOG.RENAME": "Renombrar",
    "~RENAME_DIALOG.CANCEL": "Cancelar",
    "~SHARE_DIALOG.COPY": "Copiar",
    "~SHARE_DIALOG.VIEW": "Ver",
    "~SHARE_DIALOG.CLOSE": "Cerrar",
    "~SHARE_DIALOG.COPY_SUCCESS": "La información ha sido copiada al portapapeles",
    "~SHARE_DIALOG.COPY_ERROR": "Disculpas, la información no pudo copiarse al portapapeles",
    "~SHARE_DIALOG.COPY_TITLE": "Resultado de la copia",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "La copia compartida de este documento será retenida hasta que no sea accedida a lo largo de un año.",
    "~SHARE_UPDATE.TITLE": "Se actualizó la vista compartida",
    "~SHARE_UPDATE.MESSAGE": "La vista compartida fue actualizada exitosamente.",
    "~CONFIRM.OPEN_FILE": "Hay cambios sin guardar. ¿Desea igual abrir un nuevo documento?",
    "~CONFIRM.NEW_FILE": "Hay cambios sin guardar. ¿Desea igual crear un nuevo documento?",
    "~CONFIRM.AUTHORIZE_OPEN": "Se requiere autorización para abrir el documento. ¿Desea proceder con la autorización?",
    "~CONFIRM.AUTHORIZE_SAVE": "Se requiere autorización para guardar el documento. ¿Desea proceder con la autorización?",
    "~CONFIRM.CLOSE_FILE": "Hay cambios sin guardar. ¿Desea igual cerrar el documento?",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "¿Confirma que quiere revertir el documento a su estado abierto más reciente?",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "¿Confirma que quiere revertir el documento a su estado compartido más reciente?",
    "~CONFIRM_DIALOG.TITLE": "¿Confirma?",
    "~CONFIRM_DIALOG.YES": "Sí",
    "~CONFIRM_DIALOG.NO": "No",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "Arrastrar archivo acá o clic acá para seleccionar un archivo.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "Disculpas, sólo se puede elegir un archivo para abrir.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "Disculpas, no se pueden soltar más de un archivo.",
    "~IMPORT.LOCAL_FILE": "Archivo local",
    "~IMPORT.URL": "URL",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "Disculpas, sólo se puede elegir una URL para abrir",
    "~IMPORT_URL.PLEASE_ENTER_URL": "Por favor ingresar una URL para importar.",
    "~URL_TAB.DROP_URL_HERE": "Arrastrar URL acá or ingresar URL debajo",
    "~URL_TAB.IMPORT": "Importar",
    "~CLIENT_ERROR.TITLE": "Error",
    "~ALERT_DIALOG.TITLE": "Alerta",
    "~ALERT_DIALOG.CLOSE": "Cerrar",
    "~ALERT.NO_PROVIDER": "No se pudo abrir el documento especificado porque no hay disponible un proveedor apropiado.",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "Loguearse en Google",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "Conectando con Google...",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "Falta el id de cliente requerido en las opciones de proveedor de GoogleDrive",
    "~DOCSTORE.LOAD_403_ERROR": "No tiene permiso para cargar el archivo %{filename}.<br><br>Si está usando un documento compartido por otro quizás no esté más compartido.",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "No se pudo cargar el documento compartido requerido.<br><br>Quizás el archivo no haya sido compartido de modo adecuado",
    "~DOCSTORE.LOAD_404_ERROR": "No se pudo cargar el archivo %{filename}",
    "~DOCSTORE.SAVE_403_ERROR": "No tiene permiso para guardar el archivo '%{filename}'.<br><br>Necesita loguearse de nuevo.\n",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "No se pudo crear %{filename}. Ya existe un archivo con ese nombre.\n",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "No se pudo guardar %{filename}: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "No se pudo guardar %{filename}",
    "~DOCSTORE.REMOVE_403_ERROR": "No tiene permiso para quitar el archivo %{filename}.<br><br>Necesita loguearse de nuevo.",
    "~DOCSTORE.REMOVE_ERROR": "No se pudo remover %{filename}",
    "~DOCSTORE.RENAME_403_ERROR": "No tiene permiso para renombrar el archivo %{filename}.<br><br>Necesita loguearse de nuevo.",
    "~DOCSTORE.RENAME_ERROR": "No se pudo renombrar %{filename}",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Alerta de Concord Cloud",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Alerta de Concord Cloud",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "Guardar en cualquier lugar",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "Lo haré más tarde",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "Concord Cloud ha sido cerrado",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Por favor guardar sus documentos en otra ubicación.",
    "~SHARE_DIALOG.SHARE_STATE": "Shared view: ",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "enabled",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "disabled",
    "~SHARE_DIALOG.ENABLE_SHARING": "Enable sharing",
    "~SHARE_DIALOG.STOP_SHARING": "Stop sharing",
    "~SHARE_DIALOG.UPDATE_SHARING": "Update shared view",
    "~SHARE_DIALOG.PREVIEW_SHARING": "Preview shared view",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "When sharing is enabled, a copy of the current view is created.  This copy can be shared.",
    "~SHARE_DIALOG.LINK_TAB": "Link",
    "~SHARE_DIALOG.LINK_MESSAGE": "Paste this into an email or text message ",
    "~SHARE_DIALOG.EMBED_TAB": "Embed",
    "~SHARE_DIALOG.EMBED_MESSAGE": "Embed code for including in webpages or other web-based content",
    "~SHARE_DIALOG.LARA_MESSAGE": "Use this link when creating an activity in LARA",
    "~SHARE_DIALOG.LARA_CODAP_URL": "CODAP Server URL:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Autolaunch page",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Fullscreen button and scaling",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Launch Button Text:",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Display data visibility toggles on graphs",
    "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?"
}
},{}],77:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "מסמך לא שמור",
    "~MENU.NEW": "חדש",
    "~MENU.OPEN": "פתח",
    "~MENU.CLOSE": "סגור",
    "~MENU.IMPORT_DATA": "יבא נתונים",
    "~MENU.SAVE": "שמור",
    "~MENU.SAVE_AS": "שמור בשם",
    "~MENU.EXPORT_AS": "יצא קובץ",
    "~MENU.CREATE_COPY": "צור עותק",
    "~MENU.SHARE": "שתף",
    "~MENU.SHARE_GET_LINK": "קבל קישור לצפיה שיתופית",
    "~MENU.SHARE_UPDATE": "עדכן צפיה שיתופית",
    "~MENU.DOWNLOAD": "הורד",
    "~MENU.RENAME": "שנה שם",
    "~MENU.REVERT_TO": "החזר ל",
    "~MENU.REVERT_TO_LAST_OPENED": "מצב פתוח לאחרונה",
    "~MENU.REVERT_TO_SHARED_VIEW": "צפיה שיתופית",
    "~DIALOG.SAVE": "שמור",
    "~DIALOG.SAVE_AS": "שמור בשם",
    "~DIALOG.EXPORT_AS": "יצא קובץ כ",
    "~DIALOG.CREATE_COPY": "צור עותק...",
    "~DIALOG.OPEN": "פתח",
    "~DIALOG.DOWNLOAD": "הורד",
    "~DIALOG.RENAME": "שנה שם",
    "~DIALOG.SHARED": "שתף",
    "~DIALOG.IMPORT_DATA": "יבא נתונים",
    "~PROVIDER.LOCAL_STORAGE": "אחסון מקומי",
    "~PROVIDER.READ_ONLY": "קריאה בלבד",
    "~PROVIDER.GOOGLE_DRIVE": "שרת GOOGLE",
    "~PROVIDER.DOCUMENT_STORE": "ענן CONCORD",
    "~PROVIDER.LOCAL_FILE": "קובץ מקומי",
    "~FILE_STATUS.SAVING": "שומר...",
    "~FILE_STATUS.SAVED": "כל השינויים נשמרו",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "כל השינויים נשמרו ל %{providerName}",
    "~FILE_STATUS.UNSAVED": "לא שמור",
    "~FILE_DIALOG.FILENAME": "שם קובץ",
    "~FILE_DIALOG.OPEN": "פתח",
    "~FILE_DIALOG.SAVE": "שמור",
    "~FILE_DIALOG.CANCEL": "בטל",
    "~FILE_DIALOG.REMOVE": "מחק",
    "~FILE_DIALOG.REMOVE_CONFIRM": "האם אתם בטוחים שברצונכם למחוק את %{filename}",
    "~FILE_DIALOG.REMOVED_TITLE": "קובץ מחוק",
    "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} נמחק",
    "~FILE_DIALOG.LOADING": "טוען...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** טעות בעת טעינת תוכן הקובץ ***",
    "~FILE_DIALOG.DOWNLOAD": "הורד",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "שים לב: הקובץ נשמר כ'לא ידוע' וצריך לשנות את השם ידנית עם תוספת .CODAP",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "הורד",
    "~DOWNLOAD_DIALOG.CANCEL": "בטל",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "צרף נתוני שיתוף בקובץ שהורד",
    "~RENAME_DIALOG.RENAME": "שנה שם",
    "~RENAME_DIALOG.CANCEL": "בטל",
    "~SHARE_DIALOG.COPY": "העתק",
    "~SHARE_DIALOG.VIEW": "צפה",
    "~SHARE_DIALOG.CLOSE": "סגור",
    "~SHARE_DIALOG.COPY_SUCCESS": "המידע הועתק ללוח",
    "~SHARE_DIALOG.COPY_ERROR": "סליחה, המידע לא ניתן להעתקה ללוח",
    "~SHARE_DIALOG.COPY_TITLE": "העתק תוצאה",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "העותק השיתופי של מסמך זה ישמר עד שנה ללא שימוש",
    "~SHARE_UPDATE.TITLE": "צפיה שיתופית עודכנה",
    "~SHARE_UPDATE.MESSAGE": "הצפיה השיתופית עודכנה בהצלחה",
    "~CONFIRM.OPEN_FILE": "ישנם שינויים לא שמורים. האם אתם בטוחים שברצונכם לפתוח מסמך חדש?",
    "~CONFIRM.NEW_FILE": "ישנם שינויים לא שמורים. האם אתם בטוחים שברצונכם ליצור מסמך חדש?",
    "~CONFIRM.AUTHORIZE_OPEN": "נדרש אישור לפתיחת המסמך. להמשיך עם אישור?",
    "~CONFIRM.AUTHORIZE_SAVE": "נדרש אישור לשמירת המסמך. להמשיך עם אישור?",
    "~CONFIRM.CLOSE_FILE": "ישנם שינויים לא שמורים. לסגור את המסמך?",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "בטוח שברצונכם להחזיר את המסמך למצב הפתוח האחרון?",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "בטוח שברצונכם להחזיר את המסמך למצב השיתופי האחרון?",
    "~CONFIRM_DIALOG.TITLE": "בטוח?",
    "~CONFIRM_DIALOG.YES": "כן",
    "~CONFIRM_DIALOG.NO": "לא",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "שחרר קובץ כאן או הקלק לבחירת קובץ",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "סליחה, ניתן לבחור רק קובץ אחד לפתיחה.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "סליחה, לא ניתן לשחרר יותר מקובץ אחד.",
    "~IMPORT.LOCAL_FILE": "קובץ מקומי",
    "~IMPORT.URL": "URL",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "סליחה, ניתן לפתוח רק קישור אחד",
    "~IMPORT_URL.PLEASE_ENTER_URL": "הקלידו URL ליבוא",
    "~URL_TAB.DROP_URL_HERE": "שחרר URL פה או הקלד URL מתחת",
    "~URL_TAB.IMPORT": "יבא",
    "~CLIENT_ERROR.TITLE": "טעות",
    "~ALERT_DIALOG.TITLE": "אזהרה",
    "~ALERT_DIALOG.CLOSE": "סגור",
    "~ALERT.NO_PROVIDER": "לא ניתן לפתוח את המסמך מפני שהשרת אינו זמין",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "הכנס לGOOGLE",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "מתחבר לGOOGLE",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "חסרים פרטי לקוח בGOOGLE",
    "~DOCSTORE.LOAD_403_ERROR": "אין אישור לפתוח את %. אם אתם משתמשים במסמך שיתופי של מישהו אחר ייתכן שהקובץ לא נשמר.",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "לא ניתן להעלות את המסמך השיתופי המבוקש. אולי הקובץ לא שותף?",
    "~DOCSTORE.LOAD_404_ERROR": "לא ניתן להעלות את %",
    "~DOCSTORE.SAVE_403_ERROR": "אין אישור לשמירת '%{filename}'.<br><br> ייתכן שתצטרכו להכנס שוב.",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "לא ניתן ליצור את %{filename} הקובץ כבר קיים.",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "לא ניתן לשמור את %{filename}: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "לא ניתן לשמור את %{filename}",
    "~DOCSTORE.REMOVE_403_ERROR": "אין אישור להסרת %{filename}.<br><br> יש צורך להכנס שוב.",
    "~DOCSTORE.REMOVE_ERROR": "לא ניתן להסיר את %{filename}",
    "~DOCSTORE.RENAME_403_ERROR": "אין אישור לשינוי שם %{filename}.<br><br> יש צורך להכנס שוב.",
    "~DOCSTORE.RENAME_ERROR": "לא ניתן לשנות את שם %{filename}",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "אזהרת ענן CONCORD",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "אזהרת ענן CONCORD",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "שמור במקום אחר",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "יותר מאוחר",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "ענן CONCORD נסגר!",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "שמור מסמך במיקום אחר.",
    "~SHARE_DIALOG.SHARE_STATE": "תצוגה שיתופית:␣",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "פעיל",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "לא פעיל",
    "~SHARE_DIALOG.ENABLE_SHARING": "הפעלת שיתוף",
    "~SHARE_DIALOG.STOP_SHARING": "עצירת שיתוף",
    "~SHARE_DIALOG.UPDATE_SHARING": "עדכון תצוגה שיתופית",
    "~SHARE_DIALOG.PREVIEW_SHARING": "צפיה מוקדמת בתצוגה שיתופית",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "כאשר השיתוף פעיל,  נוצר עותק של התצוגה הנוכחית. עותק זה יכול להיות משותף.",
    "~SHARE_DIALOG.LINK_TAB": "קישור",
    "~SHARE_DIALOG.LINK_MESSAGE": "הדביקו את הקישור לאימייל או להודעת טקסט",
    "~SHARE_DIALOG.EMBED_TAB": "שילוב",
    "~SHARE_DIALOG.EMBED_MESSAGE": "שילוב הקוד להוספה בעמודי רשת או תוכן רשתי אחר",
    "~SHARE_DIALOG.LARA_MESSAGE": "השתמשו בקישור זה בעת יצירת פעילות LARA",
    "~SHARE_DIALOG.LARA_CODAP_URL": "URL של שרת CODAP:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "הפעלה אוטומטית של הדף",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "כפתור מסך מלא ומירכוז",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "הפעלת כפתור טקסט:",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "הצגת מידע ויזואלי בגרפים",
    "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?"
}
},{}],78:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "İsimsiz Dosya",
    "~MENU.NEW": "Yeni",
    "~MENU.OPEN": "Aç",
    "~MENU.CLOSE": "Kapat",
    "~MENU.IMPORT_DATA": "Verileri aktar...",
    "~MENU.SAVE": "Kaydet",
    "~MENU.SAVE_AS": "Farklı kaydet...",
    "~MENU.EXPORT_AS": "Dosyayı dışa aktar ...",
    "~MENU.CREATE_COPY": "Yeni bir kopya oluştur",
    "~MENU.SHARE": "Paylaş...",
    "~MENU.SHARE_GET_LINK": "Paylaşılabilir Bağlantıyı Al",
    "~MENU.SHARE_UPDATE": "Paylaşımı Güncelle",
    "~MENU.DOWNLOAD": "İndir",
    "~MENU.RENAME": "Yeniden Adlandır",
    "~MENU.REVERT_TO": "Dönüştür",
    "~MENU.REVERT_TO_LAST_OPENED": "Son Açılan Versiyon",
    "~MENU.REVERT_TO_SHARED_VIEW": "Paylaşımlı görünüm",
    "~DIALOG.SAVE": "Kaydet",
    "~DIALOG.SAVE_AS": "Farklı kaydet",
    "~DIALOG.EXPORT_AS": "Dosyayı Dışa Aktar...",
    "~DIALOG.CREATE_COPY": "Kopyasını Oluştur...",
    "~DIALOG.OPEN": "Aç",
    "~DIALOG.DOWNLOAD": "İndir",
    "~DIALOG.RENAME": "Yeniden Adlandır",
    "~DIALOG.SHARED": "Paylaş",
    "~DIALOG.IMPORT_DATA": "Verileri Aktar",
    "~PROVIDER.LOCAL_STORAGE": "Yerel Depolama",
    "~PROVIDER.READ_ONLY": "Yalnızca Okunabilir",
    "~PROVIDER.GOOGLE_DRIVE": "Google Drive",
    "~PROVIDER.DOCUMENT_STORE": "Concord Bulut Depolama",
    "~PROVIDER.LOCAL_FILE": "Yerel Dosyalar",
    "~FILE_STATUS.SAVING": "Kaydediliyor...",
    "~FILE_STATUS.SAVED": "Tüm değişiklikler kaydedildi",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "Tüm Değişiklikler %{providerName} Olarak Kaydedildi",
    "~FILE_STATUS.UNSAVED": "Kaydedilmemiş",
    "~FILE_DIALOG.FILENAME": "Dosya Adı",
    "~FILE_DIALOG.OPEN": "Aç",
    "~FILE_DIALOG.SAVE": "Kaydet",
    "~FILE_DIALOG.CANCEL": "İptal",
    "~FILE_DIALOG.REMOVE": "Sil",
    "~FILE_DIALOG.REMOVE_CONFIRM": "%{filename} dosyasını silmek istediğinize emin misiniz?",
    "~FILE_DIALOG.REMOVED_TITLE": "Dosya Silindi",
    "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} dosyası silindi",
    "~FILE_DIALOG.LOADING": "Yükleniyor...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "İçerik yüklenirken hata oluştu.",
    "~FILE_DIALOG.DOWNLOAD": "İndir",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "NOT: Safari ile çalışırken dosya \"Bilinmeyen\" olarak görülebilir ve .codap uzantısı olarak el ile yeniden adlandırılması gerekebilir.",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "İndir",
    "~DOWNLOAD_DIALOG.CANCEL": "İptal",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "Paylaşılan bilgileri indirilen dosyaya dahil et.",
    "~RENAME_DIALOG.RENAME": "Yeniden Adlandır",
    "~RENAME_DIALOG.CANCEL": "İptal",
    "~SHARE_DIALOG.COPY": "Kopyala",
    "~SHARE_DIALOG.VIEW": "Görüntüle",
    "~SHARE_DIALOG.CLOSE": "Kapat",
    "~SHARE_DIALOG.COPY_SUCCESS": "İçerik panoya kopyalandı.",
    "~SHARE_DIALOG.COPY_ERROR": "Üzgünüz, bu içerik panoya kopyalanamadı.",
    "~SHARE_DIALOG.COPY_TITLE": "Sonucu Kopyala",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "Bu dosyanın bir örneği bir yıldan fazla bir süre erişilmediği taktirde saklanacaktır.",
    "~SHARE_UPDATE.TITLE": "Paylaşılan görünüm güncellendi",
    "~SHARE_UPDATE.MESSAGE": "Paylaşılan görünüm başarıyla güncellendi.",
    "~CONFIRM.OPEN_FILE": "Değişiklikleri kaydetmediniz. Yeni bir dosya açmak istediğinize emin misiniz?",
    "~CONFIRM.NEW_FILE": "Değişiklikleri kaydetmediniz. Yeni bir dosya oluşturmak istediğinize emin misiniz?",
    "~CONFIRM.AUTHORIZE_OPEN": "Bu dosyayı açmak için yetkili olmanız gerekmektedir. Devam etmek istiyor musunuz?",
    "~CONFIRM.AUTHORIZE_SAVE": "Bu dosyayı kaydetmek için yetkili olmanız gerekmektedir. Devam etmek istiyor musunuz?",
    "~CONFIRM.CLOSE_FILE": "Değişiklikleri kaydetmediniz. Dosyayı kapatmak istediğinize emin misiniz?",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "Dosyayı en son açılan haline geri döndürmek istediğinize emin misiniz?",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "Dosyayı en son paylaşılan haline geri döndürmek istediğinize emin misiniz?",
    "~CONFIRM_DIALOG.TITLE": "Emin misiniz?",
    "~CONFIRM_DIALOG.YES": "Evet",
    "~CONFIRM_DIALOG.NO": "Hayır",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "Dosyayı buraya sürükleyiniz veya bir dosya seçmek için tıklayınız.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "Üzgünüz, açmak için yalnızca bir dosya seçebilirsiniz.",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "Üzgünüz, bir dosyadan daha fazlasını sürükleyemezsiniz.",
    "~IMPORT.LOCAL_FILE": "Yerel Dosya",
    "~IMPORT.URL": "URL",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "Üzgünüz, yalnızca bir dosyayı url ile açabilirsiniz.",
    "~IMPORT_URL.PLEASE_ENTER_URL": "Lütfen içeri aktarmak için url giriniz.",
    "~URL_TAB.DROP_URL_HERE": "URL'yi buraya sürükleyiniz veya URL'yi giriniz.",
    "~URL_TAB.IMPORT": "İçe Aktar",
    "~CLIENT_ERROR.TITLE": "Hata",
    "~ALERT_DIALOG.TITLE": "Uyarı",
    "~ALERT_DIALOG.CLOSE": "Kapat",
    "~ALERT.NO_PROVIDER": "Belirtilen dosya uygun bir sağlayıcı bulunmadığından açılamıyor.",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "Google ile Oturum Aç",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "Google'a bağlanılıyor...",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "Google Kullanıcı Kimliği bulunamadı.",
    "~DOCSTORE.LOAD_403_ERROR": "%{filename} dosyasını açmak için gerekli izinlere sahip değilsiniz.<br><br>Eğer başkasının dosyasını kullanıyorsanız dosya paylaşımda olmayabilir.",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "Paylaşılmak istenen döküman yüklenemiyor.<br><br>Dosya paylaşımda olmayabilir?",
    "~DOCSTORE.LOAD_404_ERROR": "%{filename} dosyası yüklenemiyor",
    "~DOCSTORE.SAVE_403_ERROR": "'%{filename}' dosyasını kaydetmek için gerekli izinlere sahip değilsiniz .<br><br>Tekrar oturum açmanız gerekmektedir.",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "%{filename} dosyası oluşturulamıyor. Dosya zaten mevcut.",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "%{filename} dosyası kaydedilemez.: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "%{filename} dosyası kaydedilemez.",
    "~DOCSTORE.REMOVE_403_ERROR": "%{filename} dosyasını kaldırmak için gerekli izinlere sahip değilsiniz.<br><br>Tekrar oturum açmanız gerekmektedir.",
    "~DOCSTORE.REMOVE_ERROR": "%{filename} dosyası kaldırılamaz",
    "~DOCSTORE.RENAME_403_ERROR": "%{filename} dosyasını yeniden adlandırmak için gerekli izinlere sahip değilsiniz.<br><br>Tekrar oturum açmanız gerekmektedir.",
    "~DOCSTORE.RENAME_ERROR": "%{filename} dosyası yeniden adlandırılamadı",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Concord Bulut Depolama Uyarısı",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Concord Bulut Depolama Uyarısı",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "Farklı bir yere kaydet",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "Bunu sonra yapacağım",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "Concord Bulut Depolama sistemi kapatıldı!",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Lütfen dosyanızı farklı bir yere kaydedin.",
    "~SHARE_DIALOG.SHARE_STATE": "Shared view: ",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "enabled",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "disabled",
    "~SHARE_DIALOG.ENABLE_SHARING": "Enable sharing",
    "~SHARE_DIALOG.STOP_SHARING": "Stop sharing",
    "~SHARE_DIALOG.UPDATE_SHARING": "Update shared view",
    "~SHARE_DIALOG.PREVIEW_SHARING": "Preview shared view",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "When sharing is enabled, a copy of the current view is created.  This copy can be shared.",
    "~SHARE_DIALOG.LINK_TAB": "Link",
    "~SHARE_DIALOG.LINK_MESSAGE": "Paste this into an email or text message ",
    "~SHARE_DIALOG.EMBED_TAB": "Embed",
    "~SHARE_DIALOG.EMBED_MESSAGE": "Embed code for including in webpages or other web-based content",
    "~SHARE_DIALOG.LARA_MESSAGE": "Use this link when creating an activity in LARA",
    "~SHARE_DIALOG.LARA_CODAP_URL": "CODAP Server URL:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Autolaunch page",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Fullscreen button and scaling",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Launch Button Text:",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Display data visibility toggles on graphs",
    "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?"
}
},{}],79:[function(require,module,exports){
module.exports={
    "~MENUBAR.UNTITLED_DOCUMENT": "未命名文件",
    "~MENU.NEW": "新增",
    "~MENU.OPEN": "開啟 ...",
    "~MENU.CLOSE": "關閉",
    "~MENU.IMPORT_DATA": "匯入資料...",
    "~MENU.SAVE": "儲存",
    "~MENU.SAVE_AS": "另存至 ...",
    "~MENU.EXPORT_AS": "匯出文件 ...",
    "~MENU.CREATE_COPY": "建立複本",
    "~MENU.SHARE": "分享...",
    "~MENU.SHARE_GET_LINK": "取得連結",
    "~MENU.SHARE_UPDATE": "更新文件內容",
    "~MENU.DOWNLOAD": "下載",
    "~MENU.RENAME": "重新命名",
    "~MENU.REVERT_TO": "復原至...",
    "~MENU.REVERT_TO_LAST_OPENED": "開啟狀態",
    "~MENU.REVERT_TO_SHARED_VIEW": "分享文件",
    "~DIALOG.SAVE": "儲存",
    "~DIALOG.SAVE_AS": "另存至 ...",
    "~DIALOG.EXPORT_AS": "匯出文件 ...",
    "~DIALOG.CREATE_COPY": "建立複本 ...",
    "~DIALOG.OPEN": "開啟",
    "~DIALOG.DOWNLOAD": "下載",
    "~DIALOG.RENAME": "重新命名",
    "~DIALOG.SHARED": "分享",
    "~DIALOG.IMPORT_DATA": "重要資料",
    "~PROVIDER.LOCAL_STORAGE": "本地儲存",
    "~PROVIDER.READ_ONLY": "唯讀",
    "~PROVIDER.GOOGLE_DRIVE": "Google 雲端硬碟",
    "~PROVIDER.DOCUMENT_STORE": "Concord Cloud",
    "~PROVIDER.LOCAL_FILE": "本地檔案",
    "~FILE_STATUS.SAVING": "儲存...",
    "~FILE_STATUS.SAVED": "已儲存所有更改",
    "~FILE_STATUS.SAVED_TO_PROVIDER": "儲存更改至 %{providerName}",
    "~FILE_STATUS.UNSAVED": "未儲存",
    "~FILE_DIALOG.FILENAME": "檔案名稱",
    "~FILE_DIALOG.OPEN": "開啟",
    "~FILE_DIALOG.SAVE": "儲存",
    "~FILE_DIALOG.CANCEL": "取消",
    "~FILE_DIALOG.REMOVE": "刪除",
    "~FILE_DIALOG.REMOVE_CONFIRM": "您確定要刪除 %{filename}?",
    "~FILE_DIALOG.REMOVED_TITLE": "刪除檔案",
    "~FILE_DIALOG.REMOVED_MESSAGE": "%{filename} 已刪除",
    "~FILE_DIALOG.LOADING": "讀取中...",
    "~FILE_DIALOG.LOAD_FOLDER_ERROR": "*** 載入文件時發生錯誤 ***",
    "~FILE_DIALOG.DOWNLOAD": "下載",
    "~FILE_DIALOG.DOWNLOAD_NOTE": "NOTE: 使用Safari 檔案可能變為 \"Unknown\" 您需要在手動更改副檔名為 .codap",
    "~DOWNLOAD_DIALOG.DOWNLOAD": "下載",
    "~DOWNLOAD_DIALOG.CANCEL": "取消",
    "~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO": "下載的檔案中包含分享的檔案",
    "~RENAME_DIALOG.RENAME": "重新命名",
    "~RENAME_DIALOG.CANCEL": "取消",
    "~SHARE_DIALOG.COPY": "複製",
    "~SHARE_DIALOG.VIEW": "檢視",
    "~SHARE_DIALOG.CLOSE": "關閉",
    "~SHARE_DIALOG.COPY_SUCCESS": "訊息已複製",
    "~SHARE_DIALOG.COPY_ERROR": "抱歉，訊息無法複製",
    "~SHARE_DIALOG.COPY_TITLE": "複製結果",
    "~SHARE_DIALOG.LONGEVITY_WARNING": "若一年沒人使用本文件之複本，則此複本將會被刪除",
    "~SHARE_UPDATE.TITLE": "更新文件內容",
    "~SHARE_UPDATE.MESSAGE": "文件內容已更新",
    "~CONFIRM.OPEN_FILE": "尚未儲存變更，您確定要開啟新的文件?",
    "~CONFIRM.NEW_FILE": "尚未儲存變更，您確定要建立新的文件?",
    "~CONFIRM.AUTHORIZE_OPEN": "本文件需要授權才能開啟，您要前往認證嗎? ",
    "~CONFIRM.AUTHORIZE_SAVE": "本文件需要授權才能儲存，您要前往認證嗎? ",
    "~CONFIRM.CLOSE_FILE": "尚未儲存變更，您確定要關閉文件嗎?",
    "~CONFIRM.REVERT_TO_LAST_OPENED": "您確定要將文件回復至最近開啟的狀態嗎?",
    "~CONFIRM.REVERT_TO_SHARED_VIEW": "您確定要將文件回復至最近分享的狀態嗎?",
    "~CONFIRM_DIALOG.TITLE": "確定?",
    "~CONFIRM_DIALOG.YES": "是",
    "~CONFIRM_DIALOG.NO": "否",
    "~LOCAL_FILE_DIALOG.DROP_FILE_HERE": "將檔案拖曳至此或點擊以選取檔案",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED": "抱歉, 您只能選取一個檔案",
    "~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED": "抱歉, 您無法拖曳超過一個檔案",
    "~IMPORT.LOCAL_FILE": "本地檔案",
    "~IMPORT.URL": "網址",
    "~IMPORT_URL.MULTIPLE_URLS_DROPPED": "抱歉, 您只能選擇一個開啟網址",
    "~IMPORT_URL.PLEASE_ENTER_URL": "請輸入要匯入的網址",
    "~URL_TAB.DROP_URL_HERE": "在下面輸入網址",
    "~URL_TAB.IMPORT": "匯入",
    "~CLIENT_ERROR.TITLE": "錯誤",
    "~ALERT_DIALOG.TITLE": "警告",
    "~ALERT_DIALOG.CLOSE": "關閉",
    "~ALERT.NO_PROVIDER": "無法開啟指定的文件，因為檔案類型不受支援",
    "~GOOGLE_DRIVE.LOGIN_BUTTON_LABEL": "登入Google",
    "~GOOGLE_DRIVE.CONNECTING_MESSAGE": "連結至 Google...",
    "~GOOGLE_DRIVE.ERROR_MISSING_CLIENTID": "在googleDrive程序中缺少帳戶資料",
    "~DOCSTORE.LOAD_403_ERROR": "您沒有權限讀取 %{filename}.<br><br>若您是使用其他人共享的檔案則可能已經取消共享",
    "~DOCSTORE.LOAD_SHARED_404_ERROR": "無法讀取此共享檔案<br><br>可能檔案已取消共享?",
    "~DOCSTORE.LOAD_404_ERROR": "無法讀取 %{filename}",
    "~DOCSTORE.SAVE_403_ERROR": "您沒有權限儲存 '%{filename}'.<br><br>您可能需要再次登入",
    "~DOCSTORE.SAVE_DUPLICATE_ERROR": "無法建立 %{filename}.  檔案已存在",
    "~DOCSTORE.SAVE_ERROR_WITH_MESSAGE": "無法儲存 %{filename}: [%{message}]",
    "~DOCSTORE.SAVE_ERROR": "無法儲存 %{filename}",
    "~DOCSTORE.REMOVE_403_ERROR": "您沒有權限移除 %{filename}.<br><br>您可能需要再次登入",
    "~DOCSTORE.REMOVE_ERROR": "無法移除 %{filename}",
    "~DOCSTORE.RENAME_403_ERROR": "您沒有權限更改名稱 %{filename}.<br><br>您可能需要再次登入",
    "~DOCSTORE.RENAME_ERROR": "無法更改名稱 %{filename}",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_TITLE": "Concord Cloud 警告",
    "~CONCORD_CLOUD_DEPRECATION.ALERT_SAVE_TITLE": "Concord Cloud 警告",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_SAVE_ELSEWHERE": "儲存至其他位置",
    "~CONCORD_CLOUD_DEPRECATION.CONFIRM_DO_IT_LATER": "稍後操作",
    "~CONCORD_CLOUD_DEPRECATION.SHUT_DOWN_MESSAGE": "The Concord Cloud has been shut down!",
    "~CONCORD_CLOUD_DEPRECATION.PLEASE_SAVE_ELSEWHERE": "Please save your documents to another location.",
    "~SHARE_DIALOG.SHARE_STATE": "Shared view: ",
    "~SHARE_DIALOG.SHARE_STATE_ENABLED": "啟用",
    "~SHARE_DIALOG.SHARE_STATE_DISABLED": "中止",
    "~SHARE_DIALOG.ENABLE_SHARING": "Enable sharing",
    "~SHARE_DIALOG.STOP_SHARING": "Stop sharing",
    "~SHARE_DIALOG.UPDATE_SHARING": "更新文件內容",
    "~SHARE_DIALOG.PREVIEW_SHARING": "預習文件內容",
    "~SHARE_DIALOG.ENABLE_SHARING_MESSAGE": "When sharing is enabled, a copy of the current view is created.  This copy can be shared.",
    "~SHARE_DIALOG.LINK_TAB": "文件連結",
    "~SHARE_DIALOG.LINK_MESSAGE": "Paste this into an email or text message ",
    "~SHARE_DIALOG.EMBED_TAB": "Embed",
    "~SHARE_DIALOG.EMBED_MESSAGE": "Embed code for including in webpages or other web-based content",
    "~SHARE_DIALOG.LARA_MESSAGE": "Use this link when creating an activity in LARA",
    "~SHARE_DIALOG.LARA_CODAP_URL": "CODAP Server URL:",
    "~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE": "Autolaunch page",
    "~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING": "Fullscreen button and scaling",
    "~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT": "Launch Button Text:",
    "~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES": "Display data visibility toggles on graphs",
    "~CONFIRM.CHANGE_LANGUAGE": "You have unsaved changes. Are you sure you want to change languages?"
}
},{}],80:[function(require,module,exports){
var defaultLang, languageFiles, translate, translations, urlParams, varRegExp;

urlParams = require('./url-params');

languageFiles = [
  {
    key: 'de',
    contents: require('./lang/de')
  }, {
    key: 'el',
    contents: require('./lang/el')
  }, {
    key: 'en-US',
    contents: require('./lang/en-US')
  }, {
    key: 'es',
    contents: require('./lang/es')
  }, {
    key: 'he',
    contents: require('./lang/he')
  }, {
    key: 'tr',
    contents: require('./lang/tr')
  }, {
    key: 'zh-TW',
    contents: require('./lang/zh-TW')
  }
];

translations = {};

languageFiles.forEach(function(lang) {
  var dashLoc;
  translations[lang.key] = lang.contents;
  if ((dashLoc = lang.key.indexOf('-')) > 0) {
    return translations[lang.key.substring(0, dashLoc)] = lang.contents;
  }
});

defaultLang = null;

if (urlParams.lang && translations[urlParams.lang]) {
  defaultLang = urlParams.lang;
}

if ((defaultLang == null) && document.documentElement.lang && (document.documentElement.lang !== "unknown")) {
  defaultLang = document.documentElement.lang;
}

if (defaultLang == null) {
  defaultLang = 'en';
}

varRegExp = /%\{\s*([^}\s]*)\s*\}/g;

translate = function(key, vars, lang) {
  var ref, translation;
  if (vars == null) {
    vars = {};
  }
  if (lang == null) {
    lang = defaultLang;
  }
  translation = (ref = translations[lang]) != null ? ref[key] : void 0;
  if (translation == null) {
    translation = key;
  }
  return translation.replace(varRegExp, function(match, key) {
    if (vars.hasOwnProperty(key)) {
      return vars[key];
    } else {
      return "'** UKNOWN KEY: " + key + " **";
    }
  });
};

module.exports = translate;


},{"./lang/de":73,"./lang/el":74,"./lang/en-US":75,"./lang/es":76,"./lang/he":77,"./lang/tr":78,"./lang/zh-TW":79,"./url-params":81}],81:[function(require,module,exports){
// http://stackoverflow.com/a/2880929
var urlParams = {};
if (window && window.location && window.location.search) {
  (window.onpopstate = function () {
      var match,
          pl     = /\+/g,  // Regex for replacing addition symbol with a space
          search = /([^&=]+)=?([^&]*)/g,
          decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
          query  = window.location.search.substring(1);

      while ((match = search.exec(query)))
         urlParams[decode(match[1])] = decode(match[2]);
  })();
}

module.exports = urlParams;

},{}],82:[function(require,module,exports){
var ModalDialog, button, div, ref, tr;

ref = React.DOM, div = ref.div, button = ref.button;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'AlertDialogView',
  close: function() {
    var base, base1;
    if (typeof (base = this.props).close === "function") {
      base.close();
    }
    return typeof (base1 = this.props).callback === "function" ? base1.callback() : void 0;
  },
  render: function() {
    return ModalDialog({
      title: this.props.title || (tr('~ALERT_DIALOG.TITLE')),
      close: this.close,
      zIndex: 500
    }, div({
      className: 'alert-dialog'
    }, div({
      className: 'alert-dialog-message',
      dangerouslySetInnerHTML: {
        __html: this.props.message
      }
    }), div({
      className: 'buttons'
    }, button({
      onClick: this.close
    }, tr('~ALERT_DIALOG.CLOSE')))));
  }
});


},{"../utils/translate":80,"./modal-dialog-view":95}],83:[function(require,module,exports){
var AlertDialog, App, BlockingModal, ConfirmDialog, DownloadDialog, ImportTabbedDialog, InnerApp, MenuBar, ProviderTabbedDialog, RenameDialog, ShareDialog, div, iframe, isString, ref, tr;

MenuBar = React.createFactory(require('./menu-bar-view'));

ProviderTabbedDialog = React.createFactory(require('./provider-tabbed-dialog-view'));

DownloadDialog = React.createFactory(require('./download-dialog-view'));

RenameDialog = React.createFactory(require('./rename-dialog-view'));

ShareDialog = React.createFactory(require('./share-dialog-view'));

BlockingModal = React.createFactory(require('./blocking-modal-view'));

AlertDialog = React.createFactory(require('./alert-dialog-view'));

ConfirmDialog = React.createFactory(require('./confirm-dialog-view'));

ImportTabbedDialog = React.createFactory(require('./import-tabbed-dialog-view'));

tr = require('../utils/translate');

isString = require('../utils/is-string');

ref = React.DOM, div = ref.div, iframe = ref.iframe;

InnerApp = React.createFactory(React.createClass({
  displayName: 'CloudFileManagerInnerApp',
  shouldComponentUpdate: function(nextProps) {
    return nextProps.app !== this.props.app;
  },
  render: function() {
    return div({
      className: 'innerApp'
    }, iframe({
      src: this.props.app
    }));
  }
}));

App = React.createClass({
  displayName: 'CloudFileManager',
  getFilename: function(metadata) {
    var ref1;
    if ((metadata != null ? metadata.hasOwnProperty("name") : void 0) && ((ref1 = metadata.name) != null ? ref1.length : void 0) > 0) {
      return metadata.name;
    } else {
      return null;
    }
  },
  getInitialState: function() {
    var ref1, ref2, ref3;
    return {
      filename: this.getFilename(this.props.client.state.metadata),
      provider: (ref1 = this.props.client.state.metadata) != null ? ref1.provider : void 0,
      menuItems: ((ref2 = this.props.client._ui.menu) != null ? ref2.items : void 0) || [],
      menuOptions: ((ref3 = this.props.ui) != null ? ref3.menuBar : void 0) || {},
      providerDialog: null,
      downloadDialog: null,
      renameDialog: null,
      shareDialog: null,
      alertDialog: null,
      confirmDialog: null,
      dirty: false
    };
  },
  componentWillMount: function() {
    this.props.client.listen((function(_this) {
      return function(event) {
        var fileStatus, message, providerName, ref1, ref2, ref3;
        fileStatus = event.state.saving ? {
          message: tr('~FILE_STATUS.SAVING'),
          type: 'info'
        } : event.state.saved ? (providerName = (ref1 = event.state.metadata.provider) != null ? ref1.displayName : void 0, message = providerName ? tr('~FILE_STATUS.SAVED_TO_PROVIDER', {
          providerName: providerName
        }) : tr('~FILE_STATUS.SAVED'), {
          message: message,
          type: 'info'
        }) : event.state.dirty ? {
          message: tr('~FILE_STATUS.UNSAVED'),
          type: 'alert'
        } : null;
        _this.setState({
          filename: _this.getFilename(event.state.metadata),
          provider: (ref2 = event.state.metadata) != null ? ref2.provider : void 0,
          fileStatus: fileStatus
        });
        switch (event.type) {
          case 'connected':
            return _this.setState({
              menuItems: ((ref3 = _this.props.client._ui.menu) != null ? ref3.items : void 0) || []
            });
        }
      };
    })(this));
    return this.props.client._ui.listen((function(_this) {
      return function(event) {
        var index;
        switch (event.type) {
          case 'showProviderDialog':
            return _this.setState({
              providerDialog: event.data
            });
          case 'showDownloadDialog':
            return _this.setState({
              downloadDialog: event.data
            });
          case 'showRenameDialog':
            return _this.setState({
              renameDialog: event.data
            });
          case 'showImportDialog':
            return _this.setState({
              importDialog: event.data
            });
          case 'showShareDialog':
            return _this.setState({
              shareDialog: event.data
            });
          case 'showBlockingModal':
            return _this.setState({
              blockingModalProps: event.data
            });
          case 'hideBlockingModal':
            return _this.setState({
              blockingModalProps: null
            });
          case 'showAlertDialog':
            return _this.setState({
              alertDialog: event.data
            });
          case 'showConfirmDialog':
            return _this.setState({
              confirmDialog: event.data
            });
          case 'appendMenuItem':
            _this.state.menuItems.push(event.data);
            return _this.setState({
              menuItems: _this.state.menuItems
            });
          case 'prependMenuItem':
            _this.state.menuItems.unshift(event.data);
            return _this.setState({
              menuItems: _this.state.menuItems
            });
          case 'replaceMenuItem':
            index = _this._getMenuItemIndex(event.data.key);
            if (index !== -1) {
              _this.state.menuItems[index] = event.data.item;
              return _this.setState({
                menuItems: _this.state.menuItems
              });
            }
            break;
          case 'insertMenuItemBefore':
            index = _this._getMenuItemIndex(event.data.key);
            if (index !== -1) {
              if (index === 0) {
                _this.state.menuItems.unshift(event.data.item);
              } else {
                _this.state.menuItems.splice(index, 0, event.data.item);
              }
              return _this.setState({
                menuItems: _this.state.menuItems
              });
            }
            break;
          case 'insertMenuItemAfter':
            index = _this._getMenuItemIndex(event.data.key);
            if (index !== -1) {
              if (index === _this.state.menuItems.length - 1) {
                _this.state.menuItems.push(event.data.item);
              } else {
                _this.state.menuItems.splice(index + 1, 0, event.data.item);
              }
              return _this.setState({
                menuItems: _this.state.menuItems
              });
            }
            break;
          case 'setMenuBarInfo':
            _this.state.menuOptions.info = event.data;
            return _this.setState({
              menuOptions: _this.state.menuOptions
            });
        }
      };
    })(this));
  },
  _getMenuItemIndex: function(key) {
    var i, index, item, len, ref1;
    if (isString(key)) {
      ref1 = this.state.menuItems;
      for (index = i = 0, len = ref1.length; i < len; index = ++i) {
        item = ref1[index];
        if (item.key === key) {
          return index;
        }
      }
      return -1;
    } else {
      index = parseInt(key, 10);
      if (isNaN(index) || index < 0 || index > this.state.menuItems.length - 1) {
        return -1;
      } else {
        return index;
      }
    }
  },
  closeDialogs: function() {
    return this.setState({
      providerDialog: null,
      downloadDialog: null,
      renameDialog: null,
      shareDialog: null,
      importDialog: null
    });
  },
  closeAlert: function() {
    return this.setState({
      alertDialog: null
    });
  },
  closeConfirm: function() {
    return this.setState({
      confirmDialog: null
    });
  },
  renderDialogs: function() {
    var ref1;
    return div({}, this.state.blockingModalProps ? BlockingModal(this.state.blockingModalProps) : this.state.providerDialog ? ProviderTabbedDialog({
      client: this.props.client,
      dialog: this.state.providerDialog,
      close: this.closeDialogs
    }) : this.state.downloadDialog ? DownloadDialog({
      client: this.props.client,
      filename: this.state.downloadDialog.filename,
      mimeType: this.state.downloadDialog.mimeType,
      content: this.state.downloadDialog.content,
      close: this.closeDialogs
    }) : this.state.renameDialog ? RenameDialog({
      filename: this.state.renameDialog.filename,
      callback: this.state.renameDialog.callback,
      close: this.closeDialogs
    }) : this.state.importDialog ? ImportTabbedDialog({
      client: this.props.client,
      dialog: this.state.importDialog,
      close: this.closeDialogs
    }) : this.state.shareDialog ? ShareDialog({
      client: this.props.client,
      enableLaraSharing: this.props.enableLaraSharing,
      close: this.closeDialogs,
      settings: ((ref1 = this.props.ui) != null ? ref1.shareDialog : void 0) || {}
    }) : void 0, this.state.alertDialog ? AlertDialog({
      title: this.state.alertDialog.title,
      message: this.state.alertDialog.message,
      callback: this.state.alertDialog.callback,
      close: this.closeAlert
    }) : void 0, this.state.confirmDialog ? ConfirmDialog(_.merge({}, this.state.confirmDialog, {
      close: this.closeConfirm
    })) : void 0);
  },
  render: function() {
    var menuItems;
    menuItems = !this.props.hideMenuBar ? this.state.menuItems : [];
    if (this.props.appOrMenuElemId) {
      return div({
        className: this.props.usingIframe ? 'app' : 'view'
      }, MenuBar({
        client: this.props.client,
        filename: this.state.filename,
        provider: this.state.provider,
        fileStatus: this.state.fileStatus,
        items: menuItems,
        options: this.state.menuOptions
      }), this.props.usingIframe ? InnerApp({
        app: this.props.app
      }) : void 0, this.renderDialogs());
    } else if (this.state.providerDialog || this.state.downloadDialog) {
      return div({
        className: 'app'
      }, this.renderDialogs());
    } else {
      return null;
    }
  }
});

module.exports = App;


},{"../utils/is-string":72,"../utils/translate":80,"./alert-dialog-view":82,"./blocking-modal-view":85,"./confirm-dialog-view":86,"./download-dialog-view":87,"./import-tabbed-dialog-view":91,"./menu-bar-view":94,"./provider-tabbed-dialog-view":98,"./rename-dialog-view":99,"./share-dialog-view":101}],84:[function(require,module,exports){
var AuthorizeMixin;

AuthorizeMixin = {
  getInitialState: function() {
    this._isAuthorized = false;
    return {
      authorized: false
    };
  },
  componentWillMount: function() {
    return this.props.provider.authorized((function(_this) {
      return function(authorized) {
        _this._isAuthorized = authorized;
        if (_this._isMounted) {
          return _this.setState({
            authorized: authorized
          });
        }
      };
    })(this));
  },
  componentDidMount: function() {
    this._isMounted = true;
    if (this.state.authorized !== this._isAuthorized) {
      return this.setState({
        authorized: this._isAuthorized
      });
    }
  },
  componentWillUnmount: function() {
    return this._isMounted = false;
  },
  render: function() {
    if (this._isAuthorized || this.state.authorized) {
      return this.renderWhenAuthorized();
    } else {
      return this.props.provider.renderAuthorizationDialog();
    }
  }
};

module.exports = AuthorizeMixin;


},{}],85:[function(require,module,exports){
var Modal, div, i, ref;

Modal = React.createFactory(require('./modal-view'));

ref = React.DOM, div = ref.div, i = ref.i;

module.exports = React.createClass({
  displayName: 'BlockingModal',
  close: function() {
    var base;
    return typeof (base = this.props).close === "function" ? base.close() : void 0;
  },
  drop: function(e) {
    var base;
    return typeof (base = this.props).onDrop === "function" ? base.onDrop(e) : void 0;
  },
  render: function() {
    return Modal({
      close: this.props.close
    }, div({
      className: 'modal-dialog',
      onDrop: this.drop
    }, div({
      className: 'modal-dialog-wrapper'
    }, div({
      className: 'modal-dialog-title'
    }, this.props.title || 'Untitled Dialog'), div({
      className: 'modal-dialog-workspace'
    }, div({
      className: 'modal-dialog-blocking-message'
    }, this.props.message)))));
  }
});


},{"./modal-view":97}],86:[function(require,module,exports){
var ModalDialog, button, div, ref, tr;

ref = React.DOM, div = ref.div, button = ref.button;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'ConfirmDialogView',
  confirm: function() {
    var base, base1;
    if (typeof (base = this.props).callback === "function") {
      base.callback();
    }
    return typeof (base1 = this.props).close === "function" ? base1.close() : void 0;
  },
  reject: function() {
    var base, base1;
    if (typeof (base = this.props).rejectCallback === "function") {
      base.rejectCallback();
    }
    return typeof (base1 = this.props).close === "function" ? base1.close() : void 0;
  },
  render: function() {
    return ModalDialog({
      title: this.props.title || tr('~CONFIRM_DIALOG.TITLE'),
      close: this.reject,
      zIndex: 500
    }, div({
      className: 'confirm-dialog'
    }, div({
      className: 'confirm-dialog-message',
      dangerouslySetInnerHTML: {
        __html: this.props.message
      }
    }), div({
      className: 'buttons'
    }, button({
      onClick: this.confirm
    }, this.props.yesTitle || tr('~CONFIRM_DIALOG.YES')), (!this.props.hideNoButton ? button({
      onClick: this.reject
    }, this.props.noTitle || tr('~CONFIRM_DIALOG.NO')) : void 0))));
  }
});


},{"../utils/translate":80,"./modal-dialog-view":95}],87:[function(require,module,exports){
var CloudMetadata, ModalDialog, a, button, div, input, ref, tr;

ref = React.DOM, div = ref.div, input = ref.input, a = ref.a, button = ref.button;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

CloudMetadata = (require('../providers/provider-interface')).CloudMetadata;

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'DownloadDialogView',
  getInitialState: function() {
    var filename, state;
    filename = CloudMetadata.withExtension(this.props.filename || (tr("~MENUBAR.UNTITLED_DOCUMENT")), 'json');
    return state = {
      filename: filename,
      trimmedFilename: this.trim(filename),
      includeShareInfo: false,
      shared: this.props.client.isShared()
    };
  },
  componentDidMount: function() {
    return this.refs.filename.focus();
  },
  updateFilename: function() {
    var filename;
    filename = this.refs.filename.value;
    return this.setState({
      filename: filename,
      trimmedFilename: this.trim(filename)
    });
  },
  updateIncludeShareInfo: function() {
    return this.setState({
      includeShareInfo: this.refs.includeShareInfo.checked
    });
  },
  trim: function(s) {
    return s.replace(/^\s+|\s+$/, '');
  },
  download: function(e, simulateClick) {
    if (!this.downloadDisabled()) {
      this.refs.download.setAttribute('href', this.props.client.getDownloadUrl(this.props.content, this.state.includeShareInfo));
      if (simulateClick) {
        this.refs.download.click();
      }
      return this.props.close();
    } else {
      if (e != null) {
        e.preventDefault();
      }
      return this.refs.filename.focus();
    }
  },
  downloadDisabled: function() {
    return this.state.trimmedFilename.length === 0;
  },
  watchForEnter: function(e) {
    if (e.keyCode === 13 && !this.downloadDisabled()) {
      e.preventDefault();
      e.stopPropagation();
      return this.download(null, true);
    }
  },
  render: function() {
    return ModalDialog({
      title: tr('~DIALOG.DOWNLOAD'),
      close: this.props.close
    }, div({
      className: 'download-dialog'
    }, input({
      type: 'text',
      ref: 'filename',
      placeholder: 'Filename',
      value: this.state.filename,
      onChange: this.updateFilename,
      onKeyDown: this.watchForEnter
    }), this.state.shared ? div({
      className: 'download-share'
    }, input({
      type: 'checkbox',
      ref: 'includeShareInfo',
      value: this.state.includeShareInfo,
      onChange: this.updateIncludeShareInfo
    }), tr('~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO')) : void 0, div({
      className: 'buttons'
    }, a({
      href: '#',
      ref: 'download',
      className: (this.downloadDisabled() ? 'disabled' : ''),
      download: this.state.trimmedFilename,
      onClick: this.download
    }, tr('~DOWNLOAD_DIALOG.DOWNLOAD')), button({
      onClick: this.props.close
    }, tr('~DOWNLOAD_DIALOG.CANCEL')))));
  }
});


},{"../providers/provider-interface":65,"../utils/translate":80,"./modal-dialog-view":95}],88:[function(require,module,exports){
var DefaultAnchor, TriangleOnlyAnchor, g, polygon, rect, ref, svg;

ref = React.DOM, svg = ref.svg, g = ref.g, rect = ref.rect, polygon = ref.polygon;

DefaultAnchor = svg({
  className: 'default-anchor',
  version: '1.1',
  width: 33,
  height: 18,
  viewBox: '0 0 33 18',
  enableBackground: 'new 0 0 33 18'
}, g({}, rect({
  x: 2,
  y: 3,
  width: 16,
  height: 2
}), rect({
  x: 2,
  y: 8,
  width: 16,
  height: 2
}), rect({
  x: 2,
  y: 13,
  width: 16,
  height: 2
}), polygon({
  points: "21,7 25,13 29,7"
})));

TriangleOnlyAnchor = svg({
  className: 'triangle-only-anchor',
  version: '1.1',
  width: 8,
  height: 18,
  viewBox: '0 0 8 18',
  enableBackground: 'new 0 0 33 18'
}, polygon({
  points: "0,7 4,13 8,7"
}));

module.exports = {
  DefaultAnchor: DefaultAnchor,
  TriangleOnlyAnchor: TriangleOnlyAnchor
};


},{}],89:[function(require,module,exports){
var DefaultAnchor, DropDown, DropdownItem, cfmMenuClass, div, i, li, ref, span, ul;

ref = React.DOM, div = ref.div, i = ref.i, span = ref.span, ul = ref.ul, li = ref.li;

DefaultAnchor = require("./dropdown-anchors").DefaultAnchor;

DropdownItem = React.createFactory(React.createClass({
  displayName: 'DropdownItem',
  clicked: function() {
    if (this.props.item.items) {
      return this.showSubMenu();
    } else {
      return this.props.select(this.props.item);
    }
  },
  mouseEnter: function() {
    return this.showSubMenu();
  },
  showSubMenu: function() {
    var base, menu, menuItem;
    if (this.props.item.items) {
      menuItem = $(ReactDOM.findDOMNode(this.refs.item));
      menu = menuItem.parent().parent();
      return this.props.setSubMenu({
        style: {
          position: 'absolute',
          left: menu.width(),
          top: menuItem.position().top - parseInt(menuItem.css('padding-top'))
        },
        items: this.props.item.items
      });
    } else {
      return typeof (base = this.props).setSubMenu === "function" ? base.setSubMenu(null) : void 0;
    }
  },
  render: function() {
    var classes, content, enabled;
    enabled = this.props.item.hasOwnProperty('enabled') ? typeof this.props.item.enabled === 'function' ? this.props.item.enabled() : this.props.item.enabled : true;
    classes = ['menuItem'];
    if (this.props.item.separator) {
      classes.push('separator');
      return li({
        className: classes.join(' ')
      }, '');
    } else {
      if (!enabled || !(this.props.item.action || this.props.item.items)) {
        classes.push('disabled');
      }
      content = this.props.item.name || this.props.item.content || this.props.item;
      return li({
        ref: 'item',
        className: classes.join(' '),
        onClick: this.clicked,
        onMouseEnter: this.mouseEnter
      }, this.props.item.items ? i({
        className: 'icon-inspectorArrow-collapse'
      }) : void 0, content);
    }
  }
}));

cfmMenuClass = 'cfm-menu dg-wants-touch';

DropDown = React.createClass({
  displayName: 'Dropdown',
  getInitialState: function() {
    return {
      showingMenu: false,
      subMenu: null
    };
  },
  componentWillMount: function() {
    if (window.addEventListener) {
      window.addEventListener('mousedown', this.checkClose, true);
      return window.addEventListener('touchstart', this.checkClose, true);
    }
  },
  componentWillUnmount: function() {
    if (window.removeEventListener) {
      window.removeEventListener('mousedown', this.checkClose, true);
      return window.removeEventListener('touchstart', this.checkClose, true);
    }
  },
  checkClose: function(evt) {
    var elt;
    if (!this.state.showingMenu) {
      return;
    }
    elt = evt.target;
    while (elt != null) {
      if (typeof elt.className === "string" && elt.className.indexOf(cfmMenuClass) >= 0) {
        return;
      }
      elt = elt.parentNode;
    }
    return this.setState({
      showingMenu: false,
      subMenu: false
    });
  },
  setSubMenu: function(subMenu) {
    return this.setState({
      subMenu: subMenu
    });
  },
  select: function(item) {
    var nextState;
    if (item != null ? item.items : void 0) {
      return;
    }
    nextState = !this.state.showingMenu;
    this.setState({
      showingMenu: nextState
    });
    if (!item) {
      return;
    }
    return typeof item.action === "function" ? item.action() : void 0;
  },
  render: function() {
    var dropdownClass, index, item, menuAnchorClass, menuClass, ref1;
    menuClass = cfmMenuClass + " " + (this.state.showingMenu ? 'menu-showing' : 'menu-hidden');
    dropdownClass = "menu " + (this.props.className ? this.props.className : '');
    menuAnchorClass = "menu-anchor " + (this.props.menuAnchorClassName ? this.props.menuAnchorClassName : '');
    return div({
      className: dropdownClass
    }, ((ref1 = this.props.items) != null ? ref1.length : void 0) > 0 ? div({}, div({
      className: cfmMenuClass + " " + menuAnchorClass,
      onClick: (function(_this) {
        return function() {
          return _this.select(null);
        };
      })(this)
    }, this.props.menuAnchor ? this.props.menuAnchor : DefaultAnchor), div({
      className: menuClass
    }, ul({}, (function() {
      var j, len, ref2, results;
      ref2 = this.props.items;
      results = [];
      for (index = j = 0, len = ref2.length; j < len; index = ++j) {
        item = ref2[index];
        results.push(DropdownItem({
          key: index,
          item: item,
          select: this.select,
          setSubMenu: this.setSubMenu
        }));
      }
      return results;
    }).call(this)), this.state.subMenu ? div({
      className: menuClass,
      style: this.state.subMenu.style
    }, ul({}, (function() {
      var j, len, ref2, results;
      ref2 = this.state.subMenu.items;
      results = [];
      for (index = j = 0, len = ref2.length; j < len; index = ++j) {
        item = ref2[index];
        results.push(DropdownItem({
          key: index,
          item: item,
          select: this.select
        }));
      }
      return results;
    }).call(this))) : void 0)) : void 0);
  }
});

module.exports = DropDown;


},{"./dropdown-anchors":88}],90:[function(require,module,exports){
var AuthorizeMixin, CloudMetadata, FileDialogTab, FileList, FileListFile, button, div, i, img, input, ref, span, tr;

AuthorizeMixin = require('./authorize-mixin');

CloudMetadata = (require('../providers/provider-interface')).CloudMetadata;

tr = require('../utils/translate');

ref = React.DOM, div = ref.div, img = ref.img, i = ref.i, span = ref.span, input = ref.input, button = ref.button;

FileListFile = React.createFactory(React.createClass({
  displayName: 'FileListFile',
  componentWillMount: function() {
    return this.lastClick = 0;
  },
  fileSelected: function(e) {
    var now;
    e.preventDefault();
    e.stopPropagation();
    now = (new Date()).getTime();
    this.props.fileSelected(this.props.metadata);
    if (now - this.lastClick <= 250) {
      this.props.fileConfirmed();
    }
    return this.lastClick = now;
  },
  render: function() {
    var selectableClass, selectedClass, subFolderClass;
    selectableClass = this.props.metadata.type !== CloudMetadata.Label ? 'selectable' : '';
    selectedClass = this.props.selected ? 'selected' : '';
    subFolderClass = this.props.isSubFolder ? 'subfolder' : '';
    return div({
      className: selectableClass + " " + selectedClass + " " + subFolderClass,
      title: this.props.metadata.description || void 0,
      onClick: this.props.metadata.type !== CloudMetadata.Label ? this.fileSelected : void 0
    }, React.DOM.i({
      className: this.props.metadata.type === CloudMetadata.Folder ? 'icon-inspectorArrow-collapse' : this.props.metadata.type === CloudMetadata.File ? 'icon-noteTool' : void 0
    }), this.props.metadata.name);
  }
}));

FileList = React.createFactory(React.createClass({
  displayName: 'FileList',
  getInitialState: function() {
    return {
      loading: true
    };
  },
  componentDidMount: function() {
    this._isMounted = true;
    return this.load(this.props.folder);
  },
  componentWillReceiveProps: function(nextProps) {
    if (nextProps.folder !== this.props.folder) {
      return this.load(nextProps.folder);
    }
  },
  componentWillUnmount: function() {
    return this._isMounted = false;
  },
  load: function(folder) {
    return this.props.provider.list(folder, (function(_this) {
      return function(err, list) {
        if (err) {
          return _this.props.client.alert(err);
        }
        if (_this._isMounted) {
          _this.setState({
            loading: false
          });
        }
        return _this.props.listLoaded(list);
      };
    })(this));
  },
  parentSelected: function(e) {
    var ref1;
    return this.props.fileSelected((ref1 = this.props.folder) != null ? ref1.parent : void 0);
  },
  render: function() {
    var isSubFolder, j, len, list, metadata, ref1;
    list = [];
    isSubFolder = this.props.folder != null;
    if (isSubFolder) {
      list.push(div({
        key: 'parent',
        className: 'selectable',
        onClick: this.parentSelected
      }, React.DOM.i({
        className: 'icon-paletteArrow-collapse'
      }), this.props.folder.name));
    }
    ref1 = this.props.list;
    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
      metadata = ref1[i];
      list.push(FileListFile({
        key: i,
        metadata: metadata,
        selected: this.props.selectedFile === metadata,
        fileSelected: this.props.fileSelected,
        fileConfirmed: this.props.fileConfirmed,
        isSubFolder: isSubFolder
      }));
    }
    return div({
      className: 'filelist'
    }, this.state.loading ? tr("~FILE_DIALOG.LOADING") : list);
  }
}));

FileDialogTab = React.createClass({
  displayName: 'FileDialogTab',
  mixins: [AuthorizeMixin],
  getInitialState: function() {
    var initialState, ref1, ref2;
    this._isMounted = true;
    initialState = this.getStateForFolder((ref1 = this.props.client.state.metadata) != null ? ref1.parent : void 0, true) || null;
    initialState.filename = ((ref2 = initialState.metadata) != null ? ref2.name : void 0) || '';
    return initialState;
  },
  componentWillUnmount: function() {
    return this._isMounted = false;
  },
  isOpen: function() {
    return this.props.dialog.action === 'openFile';
  },
  filenameChanged: function(e) {
    var filename;
    filename = e.target.value;
    return this.setState({
      filename: filename,
      metadata: this.findMetadata(filename, this.state.list)
    });
  },
  listLoaded: function(list) {
    if (this._isMounted) {
      return this.setState({
        list: list
      });
    }
  },
  getSaveMetadata: function() {
    var saveMetadata;
    saveMetadata = this.props.client.state.metadata ? _.clone(this.props.client.state.metadata) : null;
    if (saveMetadata) {
      if (this.props.provider === saveMetadata.provider) {
        saveMetadata.providerData = _.cloneDeep(saveMetadata.providerData);
      } else {
        saveMetadata.provider = null;
        saveMetadata.providerData = null;
        saveMetadata.forceSaveDialog = false;
      }
    }
    return saveMetadata;
  },
  getStateForFolder: function(folder, initialFolder) {
    var metadata, ref1, ref2;
    metadata = this.isOpen() ? ((ref1 = this.state) != null ? ref1.metadata : void 0) || null : this.getSaveMetadata();
    if (initialFolder && (((ref2 = this.props.client.state.metadata) != null ? ref2.provider : void 0) !== this.props.provider)) {
      folder = null;
    } else {
      if (metadata != null) {
        metadata.parent = folder;
      }
    }
    return {
      folder: folder,
      metadata: metadata,
      list: []
    };
  },
  fileSelected: function(metadata) {
    if ((metadata != null ? metadata.type : void 0) === CloudMetadata.Folder) {
      return this.setState(this.getStateForFolder(metadata));
    } else if ((metadata != null ? metadata.type : void 0) === CloudMetadata.File) {
      return this.setState({
        filename: metadata.name,
        metadata: metadata
      });
    } else {
      return this.setState(this.getStateForFolder(null));
    }
  },
  confirm: function() {
    var confirmed, existingMetadata, filename, metadata;
    confirmed = (function(_this) {
      return function(metadata) {
        var base;
        _this.state.metadata = metadata;
        if (_this.state.metadata.provider !== _this.props.provider) {
          _this.state.metadata.provider = _this.props.provider;
          _this.state.metadata.providerData = {};
        }
        if (typeof (base = _this.props.dialog).callback === "function") {
          base.callback(_this.state.metadata);
        }
        return _this.props.close();
      };
    })(this);
    filename = $.trim(this.state.filename);
    existingMetadata = this.findMetadata(filename, this.state.list);
    metadata = this.state.metadata || existingMetadata;
    if (metadata) {
      if (this.isOpen()) {
        return confirmed(metadata);
      } else if (existingMetadata) {
        return this.props.client.confirm("Are you sure you want to overwrite " + existingMetadata.name + "?", function() {
          return confirmed(existingMetadata);
        });
      } else {
        return confirmed(metadata);
      }
    } else if (this.isOpen()) {
      return this.props.client.alert(filename + " not found");
    } else {
      return confirmed(new CloudMetadata({
        name: filename,
        type: CloudMetadata.File,
        parent: this.state.folder || null,
        provider: this.props.provider
      }));
    }
  },
  remove: function() {
    if (this.state.metadata && this.state.metadata.type !== CloudMetadata.Folder) {
      return this.props.client.confirm(tr("~FILE_DIALOG.REMOVE_CONFIRM", {
        filename: this.state.metadata.name
      }), (function(_this) {
        return function() {
          return _this.props.provider.remove(_this.state.metadata, function(err) {
            var index, list;
            if (!err) {
              _this.props.client.alert(tr("~FILE_DIALOG.REMOVED_MESSAGE", {
                filename: _this.state.metadata.name
              }), tr("~FILE_DIALOG.REMOVED_TITLE"));
              list = _this.state.list.slice(0);
              index = list.indexOf(_this.state.metadata);
              list.splice(index, 1);
              return _this.setState({
                list: list,
                metadata: null,
                filename: ''
              });
            }
          });
        };
      })(this));
    }
  },
  cancel: function() {
    return this.props.close();
  },
  findMetadata: function(filename, list) {
    var j, len, metadata;
    for (j = 0, len = list.length; j < len; j++) {
      metadata = list[j];
      if (metadata.name === filename) {
        return metadata;
      }
    }
    return null;
  },
  watchForEnter: function(e) {
    if (e.keyCode === 13 && !this.confirmDisabled()) {
      return this.confirm();
    }
  },
  confirmDisabled: function() {
    return (this.state.filename.length === 0) || (this.isOpen() && !this.state.metadata);
  },
  renderWhenAuthorized: function() {
    var confirmDisabled, removeDisabled;
    confirmDisabled = this.confirmDisabled();
    removeDisabled = (this.state.metadata === null) || (this.state.metadata.type === CloudMetadata.Folder);
    return div({
      className: 'dialogTab'
    }, input({
      type: 'text',
      value: this.state.filename,
      placeholder: tr("~FILE_DIALOG.FILENAME"),
      onChange: this.filenameChanged,
      onKeyDown: this.watchForEnter
    }), FileList({
      provider: this.props.provider,
      folder: this.state.folder,
      selectedFile: this.state.metadata,
      fileSelected: this.fileSelected,
      fileConfirmed: this.confirm,
      list: this.state.list,
      listLoaded: this.listLoaded,
      client: this.props.client
    }), div({
      className: 'buttons'
    }, button({
      onClick: this.confirm,
      disabled: confirmDisabled,
      className: confirmDisabled ? 'disabled' : ''
    }, this.isOpen() ? tr("~FILE_DIALOG.OPEN") : tr("~FILE_DIALOG.SAVE")), this.props.provider.can('remove') ? button({
      onClick: this.remove,
      disabled: removeDisabled,
      className: removeDisabled ? 'disabled' : ''
    }, tr("~FILE_DIALOG.REMOVE")) : void 0, button({
      onClick: this.cancel
    }, tr("~FILE_DIALOG.CANCEL"))));
  }
});

module.exports = FileDialogTab;


},{"../providers/provider-interface":65,"../utils/translate":80,"./authorize-mixin":84}],91:[function(require,module,exports){
var LocalFileImportTab, LocalFileTab, ModalTabbedDialog, TabbedPanel, UrlTab, tr;

ModalTabbedDialog = React.createFactory(require('./modal-tabbed-dialog-view'));

TabbedPanel = require('./tabbed-panel-view');

LocalFileTab = React.createFactory(require('./local-file-tab-list-view'));

UrlTab = React.createFactory(require('./url-tab-view'));

tr = require('../utils/translate');

LocalFileImportTab = React.createFactory(React.createClass);

module.exports = React.createClass({
  displayName: 'ImportTabbedDialog',
  importFile: function(metadata, via) {
    var reader;
    switch (metadata.provider) {
      case 'localFile':
        reader = new FileReader();
        reader.onload = (function(_this) {
          return function(loaded) {
            var base, data;
            data = {
              file: {
                name: metadata.providerData.file.name,
                content: loaded.target.result,
                object: metadata.providerData.file
              },
              via: via
            };
            return typeof (base = _this.props.dialog).callback === "function" ? base.callback(data) : void 0;
          };
        })(this);
        return reader.readAsText(metadata.providerData.file);
    }
  },
  importUrl: function(url, via) {
    var base;
    return typeof (base = this.props.dialog).callback === "function" ? base.callback({
      url: url,
      via: via
    }) : void 0;
  },
  render: function() {
    var tabs;
    tabs = [
      TabbedPanel.Tab({
        key: 0,
        label: tr("~IMPORT.LOCAL_FILE"),
        component: LocalFileTab({
          client: this.props.client,
          dialog: {
            callback: this.importFile
          },
          provider: 'localFile',
          close: this.props.close
        })
      }), TabbedPanel.Tab({
        key: 1,
        label: tr("~IMPORT.URL"),
        component: UrlTab({
          client: this.props.client,
          dialog: {
            callback: this.importUrl
          },
          close: this.props.close
        })
      })
    ];
    return ModalTabbedDialog({
      title: tr("~DIALOG.IMPORT_DATA"),
      close: this.props.close,
      tabs: tabs,
      selectedTabIndex: 0
    });
  }
});


},{"../utils/translate":80,"./local-file-tab-list-view":92,"./modal-tabbed-dialog-view":96,"./tabbed-panel-view":102,"./url-tab-view":103}],92:[function(require,module,exports){
var CloudMetadata, button, div, input, ref, tr;

ref = React.DOM, div = ref.div, input = ref.input, button = ref.button;

tr = require('../utils/translate');

CloudMetadata = (require('../providers/provider-interface')).CloudMetadata;

module.exports = React.createClass({
  displayName: 'LocalFileListTab',
  componentDidMount: function() {
    this.refs.dropZone.addEventListener('drop', this.drop);
  },
  componentWillUnmount: function() {
    this.refs.dropZone.removeEventListener('drop', this.drop);
  },
  getInitialState: function() {
    return {
      hover: false
    };
  },
  changed: function(e) {
    var files;
    files = e.target.files;
    if (files.length > 1) {
      return this.props.client.alert(tr("~LOCAL_FILE_DIALOG.MULTIPLE_FILES_SELECTED"));
    } else if (files.length === 1) {
      return this.openFile(files[0], 'select');
    }
  },
  openFile: function(file, via) {
    var base, metadata;
    metadata = new CloudMetadata({
      name: file.name.split('.')[0],
      type: CloudMetadata.File,
      parent: null,
      provider: this.props.provider,
      providerData: {
        file: file
      }
    });
    if (typeof (base = this.props.dialog).callback === "function") {
      base.callback(metadata, via);
    }
    return this.props.close();
  },
  cancel: function() {
    return this.props.close();
  },
  dragEnter: function(e) {
    e.preventDefault();
    return this.setState({
      hover: true
    });
  },
  dragLeave: function(e) {
    e.preventDefault();
    return this.setState({
      hover: false
    });
  },
  drop: function(e) {
    var droppedFiles;
    e.preventDefault();
    e.stopPropagation();
    droppedFiles = e.dataTransfer ? e.dataTransfer.files : e.target.files;
    if (droppedFiles.length > 1) {
      this.props.client.alert(tr("~LOCAL_FILE_DIALOG.MULTIPLE_FILES_DROPPED"));
    } else if (droppedFiles.length === 1) {
      this.openFile(droppedFiles[0], 'drop');
    }
  },
  render: function() {
    var dropClass;
    dropClass = "dropArea" + (this.state.hover ? ' dropHover' : '');
    return div({
      className: 'dialogTab localFileLoad'
    }, div({
      ref: 'dropZone',
      className: dropClass,
      onDragEnter: this.dragEnter,
      onDragLeave: this.dragLeave
    }, tr("~LOCAL_FILE_DIALOG.DROP_FILE_HERE"), input({
      type: 'file',
      onChange: this.changed
    })), div({
      className: 'buttons'
    }, button({
      onClick: this.cancel
    }, tr("~FILE_DIALOG.CANCEL"))));
  }
});


},{"../providers/provider-interface":65,"../utils/translate":80}],93:[function(require,module,exports){
var CloudMetadata, FileSaver, a, button, cloudContentFactory, div, input, ref, tr;

ref = React.DOM, div = ref.div, input = ref.input, button = ref.button, a = ref.a;

tr = require('../utils/translate');

CloudMetadata = (require('../providers/provider-interface')).CloudMetadata;

cloudContentFactory = (require('../providers/provider-interface')).cloudContentFactory;

FileSaver = require('../lib/file-saver');

module.exports = React.createClass({
  displayName: 'LocalFileSaveTab',
  getInitialState: function() {
    var extension, filename, hasPropsContent, ref1, ref2, ref3, state;
    hasPropsContent = ((ref1 = this.props.dialog.data) != null ? ref1.content : void 0) != null;
    filename = ((ref2 = this.props.client.state.metadata) != null ? ref2.name : void 0) || (tr("~MENUBAR.UNTITLED_DOCUMENT"));
    extension = hasPropsContent && this.props.dialog.data.extension ? this.props.dialog.data.extension : 'json';
    return state = {
      filename: filename,
      supportsDownloadAttribute: document.createElement('a').download !== void 0,
      downloadFilename: this.getDownloadFilename(hasPropsContent, filename, extension),
      extension: extension,
      mimeType: hasPropsContent && (this.props.dialog.data.mimeType != null) ? this.props.dialog.data.mimeType : 'text/plain',
      shared: this.props.client.isShared(),
      hasPropsContent: hasPropsContent,
      includeShareInfo: hasPropsContent,
      gotContent: hasPropsContent,
      content: (ref3 = this.props.dialog.data) != null ? ref3.content : void 0
    };
  },
  componentDidMount: function() {
    if (!this.state.hasPropsContent) {
      this.props.client._event('getContent', {
        shared: this.props.client._sharedMetadata()
      }, (function(_this) {
        return function(content) {
          var envelopedContent, ref1, ref2;
          envelopedContent = cloudContentFactory.createEnvelopedCloudContent(content);
          if ((ref1 = _this.props.client.state) != null) {
            if ((ref2 = ref1.currentContent) != null) {
              ref2.copyMetadataTo(envelopedContent);
            }
          }
          return _this.setState({
            gotContent: true,
            content: envelopedContent
          });
        };
      })(this));
    }
    return this.refs.download.addEventListener('click', this.confirm);
  },
  componentWillUnmount: function() {
    return this.refs.download.removeEventListener('click', this.confirm);
  },
  filenameChanged: function() {
    var filename;
    filename = this.refs.filename.value;
    return this.setState({
      filename: filename,
      downloadFilename: this.getDownloadFilename(this.state.hasPropsContent, filename, this.state.extension)
    });
  },
  includeShareInfoChanged: function() {
    return this.setState({
      includeShareInfo: this.refs.includeShareInfo.checked
    });
  },
  getDownloadFilename: function(hasPropsContent, filename, extension) {
    var newName;
    newName = filename.replace(/^\s+|\s+$/, '');
    if (hasPropsContent) {
      return CloudMetadata.newExtension(newName, extension);
    } else {
      return CloudMetadata.withExtension(newName, extension);
    }
  },
  confirm: function(e, simulateClick) {
    var blob, metadata;
    if (!this.confirmDisabled()) {
      if (this.state.supportsDownloadAttribute) {
        this.refs.download.href = this.props.client.getDownloadUrl(this.state.content, this.state.includeShareInfo, this.state.mimeType);
        if (simulateClick) {
          this.refs.download.click();
        }
      } else {
        blob = this.props.client.getDownloadBlob(this.state.content, this.state.includeShareInfo, this.state.mimeType);
        FileSaver.saveAs(blob, this.state.downloadFilename, true);
        if (e != null) {
          e.preventDefault();
        }
      }
      metadata = new CloudMetadata({
        name: this.state.downloadFilename.split('.')[0],
        type: CloudMetadata.File,
        parent: null,
        provider: this.props.provider
      });
      this.props.dialog.callback(metadata);
      this.props.close();
      return this.state.supportsDownloadAttribute;
    } else {
      if (e != null) {
        e.preventDefault();
      }
    }
  },
  contextMenu: function(e) {
    this.refs.download.href = this.props.client.getDownloadUrl(this.state.content, this.state.includeShareInfo, this.state.mimeType);
  },
  cancel: function() {
    this.props.close();
  },
  watchForEnter: function(e) {
    if (e.keyCode === 13 && !this.confirmDisabled()) {
      e.preventDefault();
      e.stopPropagation();
      this.confirm(null, true);
    }
  },
  confirmDisabled: function() {
    return (this.state.downloadFilename.length === 0) || !this.state.gotContent;
  },
  render: function() {
    var confirmDisabled, downloadAnchor, downloadButton;
    confirmDisabled = this.confirmDisabled();
    downloadAnchor = a({
      href: '#',
      ref: 'download',
      className: (confirmDisabled ? 'disabled' : ''),
      download: this.state.downloadFilename,
      onContextMenu: this.contextMenu
    }, tr('~FILE_DIALOG.DOWNLOAD'));
    downloadButton = button({
      ref: 'download',
      className: (confirmDisabled ? 'disabled' : '')
    }, tr('~FILE_DIALOG.DOWNLOAD'));
    return div({
      className: 'dialogTab localFileSave'
    }, input({
      type: 'text',
      ref: 'filename',
      value: this.state.filename,
      placeholder: tr("~FILE_DIALOG.FILENAME"),
      onChange: this.filenameChanged,
      onKeyDown: this.watchForEnter
    }), div({
      className: 'saveArea'
    }, this.state.shared && !this.state.hasPropsContent ? div({
      className: 'shareCheckbox'
    }, input({
      type: 'checkbox',
      ref: 'includeShareInfo',
      value: this.state.includeShareInfo,
      onChange: this.includeShareInfoChanged
    }), tr('~DOWNLOAD_DIALOG.INCLUDE_SHARE_INFO')) : void 0), div({
      className: 'note'
    }, tr('~FILE_DIALOG.DOWNLOAD_NOTE', {
      download: tr('~FILE_DIALOG.DOWNLOAD')
    })), div({
      className: 'buttons'
    }, this.state.supportsDownloadAttribute ? downloadAnchor : downloadButton, button({
      onClick: this.cancel
    }, tr("~FILE_DIALOG.CANCEL"))));
  }
});


},{"../lib/file-saver":55,"../providers/provider-interface":65,"../utils/translate":80}],94:[function(require,module,exports){
var Dropdown, TriangleOnlyAnchor, div, i, input, ref, span, tr;

ref = React.DOM, div = ref.div, i = ref.i, span = ref.span, input = ref.input;

Dropdown = React.createFactory(require('./dropdown-view'));

TriangleOnlyAnchor = require("./dropdown-anchors").TriangleOnlyAnchor;

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'MenuBar',
  componentWillMount: function() {
    if (window.addEventListener) {
      window.addEventListener('mousedown', this.checkBlur, true);
      window.addEventListener('touchstart', this.checkBlur, true);
    }
    return this.props.client._ui.listen((function(_this) {
      return function(event) {
        switch (event.type) {
          case 'editInitialFilename':
            _this.setState({
              editingFilename: true,
              editingInitialFilename: true
            });
            return setTimeout((function() {
              return _this.focusFilename();
            }), 10);
        }
      };
    })(this));
  },
  componentWillUnmount: function() {
    if (window.removeEventListener) {
      window.removeEventListener('mousedown', this.checkBlur, true);
      return window.removeEventListener('touchstart', this.checkBlur, true);
    }
  },
  getFilename: function(props) {
    var ref1;
    if (((ref1 = props.filename) != null ? ref1.length : void 0) > 0) {
      return props.filename;
    } else {
      return tr("~MENUBAR.UNTITLED_DOCUMENT");
    }
  },
  getEditableFilename: function(props) {
    var ref1;
    if (((ref1 = props.filename) != null ? ref1.length : void 0) > 0) {
      return props.filename;
    } else {
      return tr("~MENUBAR.UNTITLED_DOCUMENT");
    }
  },
  getInitialState: function() {
    var state;
    return state = {
      editingFilename: false,
      filename: this.getFilename(this.props),
      editableFilename: this.getEditableFilename(this.props),
      initialEditableFilename: this.getEditableFilename(this.props),
      editingInitialFilename: false
    };
  },
  componentWillReceiveProps: function(nextProps) {
    return this.setState({
      filename: this.getFilename(nextProps),
      editableFilename: this.getEditableFilename(nextProps),
      provider: nextProps.provider
    });
  },
  filenameClicked: function(e) {
    e.preventDefault();
    e.stopPropagation();
    this.setState({
      editingFilename: true,
      editingInitialFilename: false
    });
    return setTimeout(((function(_this) {
      return function() {
        return _this.focusFilename();
      };
    })(this)), 10);
  },
  filenameChanged: function() {
    return this.setState({
      editableFilename: this.filename().value
    });
  },
  filenameBlurred: function() {
    return this.rename();
  },
  filename: function() {
    return ReactDOM.findDOMNode(this.refs.filename);
  },
  focusFilename: function() {
    var el;
    el = this.filename();
    el.focus();
    return el.select();
  },
  cancelEdit: function() {
    var ref1;
    return this.setState({
      editingFilename: false,
      editableFilename: ((ref1 = this.state.filename) != null ? ref1.length : void 0) > 0 ? this.state.filename : this.state.initialEditableFilename
    });
  },
  rename: function() {
    var filename;
    filename = this.state.editableFilename.replace(/^\s+|\s+$/, '');
    if (filename.length > 0) {
      if (this.state.editingInitialFilename) {
        this.props.client.setInitialFilename(filename);
      } else {
        this.props.client.rename(this.props.client.state.metadata, filename);
      }
      return this.setState({
        editingFilename: false,
        filename: filename,
        editableFilename: filename
      });
    } else {
      return this.cancelEdit();
    }
  },
  watchForEnter: function(e) {
    if (e.keyCode === 13) {
      return this.rename();
    } else if (e.keyCode === 27) {
      return this.cancelEdit();
    }
  },
  help: function() {
    return window.open(this.props.options.help, '_blank');
  },
  infoClicked: function() {
    var base;
    return typeof (base = this.props.options).onInfoClicked === "function" ? base.onInfoClicked(this.props.client) : void 0;
  },
  checkBlur: function(e) {
    if (this.state.editingFilename && e.target !== this.filename()) {
      return this.filenameBlurred();
    }
  },
  langChanged: function(langCode) {
    var client, onLangChanged, options, ref1;
    ref1 = this.props, client = ref1.client, options = ref1.options;
    onLangChanged = options.languageMenu.onLangChanged;
    if (onLangChanged != null) {
      return client.changeLanguage(langCode, onLangChanged);
    }
  },
  renderLanguageMenu: function() {
    var currentOption, defaultOption, flag, hasFlags, items, label, langMenu, menuAnchor, ref1;
    langMenu = this.props.options.languageMenu;
    items = langMenu.options.filter(function(option) {
      return option.langCode !== langMenu.currentLang;
    }).map((function(_this) {
      return function(option) {
        var className, label;
        label = option.label || option.langCode.toUpperCase();
        if (option.flag) {
          className = "flag flag-" + option.flag;
        }
        return {
          content: span({
            className: 'lang-option'
          }, div({
            className: className
          }), label),
          action: function() {
            return _this.langChanged(option.langCode);
          }
        };
      };
    })(this));
    hasFlags = langMenu.options.filter(function(option) {
      return option.flag != null;
    }).length > 0;
    currentOption = langMenu.options.filter(function(option) {
      return option.langCode === langMenu.currentLang;
    })[0];
    defaultOption = hasFlags ? {
      flag: "us"
    } : {
      label: "English"
    };
    ref1 = currentOption || defaultOption, flag = ref1.flag, label = ref1.label;
    menuAnchor = flag ? div({
      className: "flag flag-" + flag
    }) : div({
      className: "lang-menu with-border"
    }, span({
      className: "lang-label"
    }, label || defaultOption.label), TriangleOnlyAnchor);
    return Dropdown({
      className: "lang-menu",
      menuAnchorClassName: "menu-anchor-right",
      items: items,
      menuAnchor: menuAnchor
    });
  },
  render: function() {
    var ref1;
    return div({
      className: 'menu-bar'
    }, div({
      className: 'menu-bar-left'
    }, Dropdown({
      items: this.props.items
    }), this.state.editingFilename ? div({
      className: 'menu-bar-content-filename'
    }, input({
      ref: 'filename',
      value: this.state.editableFilename,
      onChange: this.filenameChanged,
      onKeyDown: this.watchForEnter
    })) : div({
      className: 'menu-bar-content-filename',
      onClick: this.filenameClicked
    }, this.state.filename), this.props.fileStatus ? span({
      className: "menu-bar-file-status-" + this.props.fileStatus.type
    }, this.props.fileStatus.message) : void 0), div({
      className: 'menu-bar-right'
    }, this.props.options.info ? span({
      className: 'menu-bar-info',
      onClick: this.infoClicked
    }, this.props.options.info) : void 0, ((ref1 = this.props.provider) != null ? ref1.authorized() : void 0) ? this.props.provider.renderUser() : void 0, this.props.options.help ? i({
      style: {
        fontSize: "13px"
      },
      className: 'clickable icon-help',
      onClick: this.help
    }) : void 0, this.props.options.languageMenu ? this.renderLanguageMenu() : void 0));
  }
});


},{"../utils/translate":80,"./dropdown-anchors":88,"./dropdown-view":89}],95:[function(require,module,exports){
var Modal, div, i, ref;

Modal = React.createFactory(require('./modal-view'));

ref = React.DOM, div = ref.div, i = ref.i;

module.exports = React.createClass({
  displayName: 'ModalDialog',
  close: function() {
    var base;
    return typeof (base = this.props).close === "function" ? base.close() : void 0;
  },
  render: function() {
    return Modal({
      close: this.close,
      zIndex: this.props.zIndex
    }, div({
      className: 'modal-dialog'
    }, div({
      className: 'modal-dialog-wrapper'
    }, div({
      className: 'modal-dialog-title'
    }, i({
      className: "modal-dialog-title-close icon-ex",
      onClick: this.close
    }), this.props.title || 'Untitled Dialog'), div({
      className: 'modal-dialog-workspace'
    }, this.props.children))));
  }
});


},{"./modal-view":97}],96:[function(require,module,exports){
var ModalDialog, TabbedPanel;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

TabbedPanel = React.createFactory(require('./tabbed-panel-view'));

module.exports = React.createClass({
  displayName: 'ModalTabbedDialogView',
  render: function() {
    return ModalDialog({
      title: this.props.title,
      close: this.props.close
    }, TabbedPanel({
      tabs: this.props.tabs,
      selectedTabIndex: this.props.selectedTabIndex
    }));
  }
});


},{"./modal-dialog-view":95,"./tabbed-panel-view":102}],97:[function(require,module,exports){
var div;

div = React.DOM.div;

module.exports = React.createClass({
  displayName: 'Modal',
  watchForEscape: function(e) {
    var base;
    if (e.keyCode === 27) {
      return typeof (base = this.props).close === "function" ? base.close() : void 0;
    }
  },
  getDimensions: function() {
    return {
      width: '100vw',
      height: '100vh'
    };
  },
  getInitialState: function() {
    var dimensions, initialState;
    dimensions = this.getDimensions();
    return initialState = {
      backgroundStyle: this.getBackgroundStyle(dimensions),
      contentStyle: this.getContentStyle(dimensions)
    };
  },
  getBackgroundStyle: function(dimensions) {
    if (this.props.zIndex) {
      return {
        zIndex: this.props.zIndex,
        width: dimensions.width,
        height: dimensions.height
      };
    } else {
      return dimensions;
    }
  },
  getContentStyle: function(dimensions) {
    if (this.props.zIndex) {
      return {
        zIndex: this.props.zIndex + 1,
        width: dimensions.width,
        height: dimensions.height
      };
    } else {
      return dimensions;
    }
  },
  updateStyles: function() {
    var dimensions;
    dimensions = this.getDimensions();
    return this.setState({
      backgroundStyle: this.getBackgroundStyle(dimensions),
      contentStyle: this.getContentStyle(dimensions)
    });
  },
  componentDidMount: function() {
    $(window).bind('keyup', this.watchForEscape);
    return $(window).bind('resize', this.updateStyles);
  },
  componentWillUnmount: function() {
    $(window).unbind('keyup', this.watchForEscape);
    return $(window).unbind('resize', this.updateStyles);
  },
  render: function() {
    return div({
      className: 'modal'
    }, div({
      className: 'modal-background',
      style: this.state.backgroundStyle
    }), div({
      className: 'modal-content',
      style: this.state.contentStyle
    }, this.props.children));
  }
});


},{}],98:[function(require,module,exports){
var CloudMetadata, FileDialogTab, ModalTabbedDialog, SelectProviderDialogTab, TabbedPanel, tr;

ModalTabbedDialog = React.createFactory(require('./modal-tabbed-dialog-view'));

TabbedPanel = require('./tabbed-panel-view');

CloudMetadata = (require('../providers/provider-interface')).CloudMetadata;

FileDialogTab = React.createFactory(require('./file-dialog-tab-view'));

SelectProviderDialogTab = React.createFactory(require('./select-provider-dialog-tab-view'));

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'ProviderTabbedDialog',
  render: function() {
    var TabComponent, capability, component, filteredTabComponent, i, j, len, onSelected, provider, ref, ref1, ref2, ref3, selectedTabIndex, tabs;
    ref = (function() {
      switch (this.props.dialog.action) {
        case 'openFile':
          return ['list', FileDialogTab];
        case 'saveFile':
        case 'saveFileAs':
          return ['save', FileDialogTab];
        case 'saveSecondaryFileAs':
          return ['export', FileDialogTab];
        case 'createCopy':
          return ['save', FileDialogTab];
        case 'selectProvider':
          return [null, SelectProviderDialogTab];
      }
    }).call(this), capability = ref[0], TabComponent = ref[1];
    tabs = [];
    selectedTabIndex = 0;
    ref1 = this.props.client.state.availableProviders;
    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
      provider = ref1[i];
      if (!capability || provider.capabilities[capability]) {
        filteredTabComponent = provider.filterTabComponent(capability, TabComponent);
        if (filteredTabComponent) {
          component = filteredTabComponent({
            client: this.props.client,
            dialog: this.props.dialog,
            close: this.props.close,
            provider: provider
          });
          onSelected = provider.onProviderTabSelected ? provider.onProviderTabSelected.bind(provider) : null;
          tabs.push(TabbedPanel.Tab({
            key: i,
            label: tr(provider.displayName),
            component: component,
            capability: capability,
            onSelected: onSelected
          }));
          if (provider.name === ((ref2 = this.props.client.state.metadata) != null ? (ref3 = ref2.provider) != null ? ref3.name : void 0 : void 0)) {
            selectedTabIndex = tabs.length - 1;
          }
        }
      }
    }
    return ModalTabbedDialog({
      title: tr(this.props.dialog.title),
      close: this.props.close,
      tabs: tabs,
      selectedTabIndex: selectedTabIndex
    });
  }
});


},{"../providers/provider-interface":65,"../utils/translate":80,"./file-dialog-tab-view":90,"./modal-tabbed-dialog-view":96,"./select-provider-dialog-tab-view":100,"./tabbed-panel-view":102}],99:[function(require,module,exports){
var ModalDialog, a, button, div, input, ref, tr;

ref = React.DOM, div = ref.div, input = ref.input, a = ref.a, button = ref.button;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'RenameDialogView',
  getInitialState: function() {
    var filename, state;
    filename = this.props.filename || '';
    return state = {
      filename: filename,
      trimmedFilename: this.trim(filename)
    };
  },
  componentDidMount: function() {
    this.filename = ReactDOM.findDOMNode(this.refs.filename);
    return this.filename.focus();
  },
  updateFilename: function() {
    var filename;
    filename = this.filename.value;
    return this.setState({
      filename: filename,
      trimmedFilename: this.trim(filename)
    });
  },
  trim: function(s) {
    return s.replace(/^\s+|\s+$/, '');
  },
  rename: function(e) {
    var base;
    if (this.state.trimmedFilename.length > 0) {
      if (typeof (base = this.props).callback === "function") {
        base.callback(this.state.filename);
      }
      return this.props.close();
    } else {
      e.preventDefault();
      return this.filename.focus();
    }
  },
  render: function() {
    return ModalDialog({
      title: tr('~DIALOG.RENAME'),
      close: this.props.close
    }, div({
      className: 'rename-dialog'
    }, input({
      ref: 'filename',
      placeholder: 'Filename',
      value: this.state.filename,
      onChange: this.updateFilename
    }), div({
      className: 'buttons'
    }, button({
      className: (this.state.trimmedFilename.length === 0 ? 'disabled' : ''),
      onClick: this.rename
    }, tr('~RENAME_DIALOG.RENAME')), button({
      onClick: this.props.close
    }, tr('~RENAME_DIALOG.CANCEL')))));
  }
});


},{"../utils/translate":80,"./modal-dialog-view":95}],100:[function(require,module,exports){
var SelectProviderDialogTab, div;

div = React.DOM.div;

SelectProviderDialogTab = React.createFactory(React.createClass({
  displayName: 'SelectProviderDialogTab',
  render: function() {
    return div({}, "TODO: SelectProviderDialogTab: " + this.props.provider.displayName);
  }
}));

module.exports = SelectProviderDialogTab;


},{}],101:[function(require,module,exports){
var ModalDialog, SHOW_LONGEVITY_WARNING, SocialIcon, a, button, circle, div, g, getQueryParam, input, li, path, ref, socialIcons, span, strong, svg, textarea, translate, ul;

ref = React.DOM, div = ref.div, input = ref.input, a = ref.a, button = ref.button, strong = ref.strong, textarea = ref.textarea, svg = ref.svg, g = ref.g, path = ref.path, span = ref.span, circle = ref.circle, ul = ref.ul, li = ref.li;

SHOW_LONGEVITY_WARNING = false;

ModalDialog = React.createFactory(require('./modal-dialog-view'));

getQueryParam = require('../utils/get-query-param');

translate = require('../utils/translate');

socialIcons = require('svg-social-icons/lib/icons.json');

SocialIcon = React.createFactory(React.createClass({
  displayName: 'SocialIcon',
  getInitialState: function() {
    return {
      data: socialIcons[this.props.icon]
    };
  },
  clicked: function() {
    return window.open(this.props.url);
  },
  render: function() {
    return a({
      className: 'social-icon',
      href: this.props.url,
      target: '_blank'
    }, div({
      className: 'social-container'
    }, svg({
      className: 'social-svg',
      viewBox: '0 0 64 64'
    }, g({
      className: 'social-svg-background'
    }, circle({
      cx: 32,
      cy: 32,
      r: 31
    })), g({
      className: 'social-svg-icon'
    }, path({
      d: this.state.data.icon
    })), g({
      className: 'social-svg-mask',
      style: {
        fill: this.state.data.color
      }
    }, path({
      d: this.state.data.mask
    })))));
  }
}));

module.exports = React.createClass({
  displayName: 'ShareDialogView',
  getInitialState: function() {
    return {
      link: this.getShareLink(),
      embed: this.getEmbed(),
      pageType: "autolaunch",
      serverUrl: this.props.settings.serverUrl || "https://codap.concord.org/releases/latest/",
      serverUrlLabel: this.props.settings.serverUrlLabel || translate("~SHARE_DIALOG.LARA_CODAP_URL"),
      launchButtonText: "Launch",
      fullscreenScaling: true,
      graphVisToggles: false,
      tabSelected: 'link'
    };
  },
  getSharedDocumentId: function() {
    var ref1;
    if (this.props.client.isShared()) {
      return (ref1 = this.props.client.state.currentContent) != null ? ref1.get("sharedDocumentId") : void 0;
    } else {
      return null;
    }
  },
  getShareLink: function() {
    var sharedDocumentId;
    sharedDocumentId = this.getSharedDocumentId();
    if (sharedDocumentId) {
      return (this.props.client.getCurrentUrl()) + "#shared=" + sharedDocumentId;
    } else {
      return null;
    }
  },
  getEmbed: function() {
    if (this.getShareLink()) {
      return "<iframe width=\"398px\" height=\"313px\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"true\" webkitallowfullscreen=\"true\" mozallowfullscreen=\"true\" src=\"" + (this.getShareLink()) + "\"></iframe>";
    } else {
      return null;
    }
  },
  getLara: function() {
    var buttonText, documentServer, fullscreenScaling, graphVisToggles, server, sharedDocumentId;
    sharedDocumentId = this.getSharedDocumentId();
    if (sharedDocumentId) {
      documentServer = getQueryParam('documentServer') || 'https://document-store.concord.org';
      while (documentServer.substr(-1) === '/') {
        documentServer = documentServer.slice(0, -1);
      }
      graphVisToggles = this.state.graphVisToggles ? '?app=is' : '';
      server = encodeURIComponent(this.state.serverUrl + graphVisToggles);
      buttonText = this.state.pageType === 'launch' ? "&buttonText=" + (encodeURIComponent(this.state.launchButtonText)) : '';
      fullscreenScaling = this.state.pageType === 'autolaunch' && this.state.fullscreenScaling ? '&scaling' : '';
      return documentServer + "/v2/documents/" + sharedDocumentId + "/" + this.state.pageType + "?server=" + server + buttonText + fullscreenScaling;
    } else {
      return null;
    }
  },
  copy: function(e) {
    var copied, mark, range, selection, toCopy;
    e.preventDefault();
    copied = false;
    toCopy = (function() {
      switch (this.state.tabSelected) {
        case 'embed':
          return this.getEmbed();
        case 'link':
          return this.getShareLink();
        case 'lara':
          return this.getLara();
      }
    }).call(this);
    try {
      mark = document.createElement('mark');
      mark.textContent = toCopy;
      mark.style.all = 'unset';
      mark.style.position = 'fixed';
      mark.style.top = 0;
      mark.style.clip = 'rect(0, 0, 0, 0)';
      mark.style.whiteSpace = 'pre';
      mark.style.webkitUserSelect = 'text';
      mark.style.MozUserSelect = 'text';
      mark.style.msUserSelect = 'text';
      mark.style.userSelect = 'text';
      document.body.appendChild(mark);
      selection = document.getSelection();
      selection.removeAllRanges();
      range = document.createRange();
      range.selectNode(mark);
      selection.addRange(range);
      return copied = document.execCommand('copy');
    } catch (error) {
      try {
        window.clipboardData.setData('text', toCopy);
        return copied = true;
      } catch (error) {
        return copied = false;
      }
    } finally {
      if (selection) {
        if (typeof selection.removeRange === 'function') {
          selection.removeRange(range);
        } else {
          selection.removeAllRanges();
        }
      }
      if (mark) {
        document.body.removeChild(mark);
      }
      this.props.client.alert(translate(copied ? "~SHARE_DIALOG.COPY_SUCCESS" : "~SHARE_DIALOG.COPY_ERROR"), translate("~SHARE_DIALOG.COPY_TITLE"));
    }
  },
  updateShare: function() {
    return this.props.client.shareUpdate();
  },
  toggleShare: function(e) {
    e.preventDefault();
    return this.props.client.toggleShare((function(_this) {
      return function() {
        return _this.setState({
          link: _this.getShareLink(),
          embed: _this.getEmbed()
        });
      };
    })(this));
  },
  selectLinkTab: function() {
    return this.setState({
      tabSelected: 'link'
    });
  },
  selectEmbedTab: function() {
    return this.setState({
      tabSelected: 'embed'
    });
  },
  selectLaraTab: function() {
    return this.setState({
      tabSelected: 'lara'
    });
  },
  changedServerUrl: function(event) {
    return this.setState({
      serverUrl: event.target.value
    });
  },
  changedLaunchButtonText: function(event) {
    return this.setState({
      launchButtonText: event.target.value
    });
  },
  changedAutoscalingPage: function(event) {
    return this.setState({
      pageType: event.target.checked ? 'autolaunch' : 'launch'
    });
  },
  changedFullscreenScaling: function(event) {
    return this.setState({
      fullscreenScaling: event.target.checked
    });
  },
  changedGraphVisToggles: function(event) {
    return this.setState({
      graphVisToggles: event.target.checked
    });
  },
  render: function() {
    var sharing;
    sharing = this.state.link !== null;
    return ModalDialog({
      title: translate('~DIALOG.SHARED'),
      close: this.props.close
    }, div({
      className: 'share-dialog'
    }, div({
      className: 'share-top-dialog'
    }, sharing ? div({}, div({
      className: 'share-status'
    }, translate("~SHARE_DIALOG.SHARE_STATE"), strong({}, translate("~SHARE_DIALOG.SHARE_STATE_ENABLED")), a({
      href: '#',
      onClick: this.toggleShare
    }, translate("~SHARE_DIALOG.STOP_SHARING"))), div({
      className: 'share-button'
    }, button({
      onClick: this.updateShare
    }, translate("~SHARE_DIALOG.UPDATE_SHARING")), div({
      className: 'share-button-help-sharing'
    }, a({
      href: this.state.link,
      target: '_blank'
    }, translate("~SHARE_DIALOG.PREVIEW_SHARING"))))) : div({}, div({
      className: 'share-status'
    }, translate("~SHARE_DIALOG.SHARE_STATE"), strong({}, translate("~SHARE_DIALOG.SHARE_STATE_DISABLED"))), div({
      className: 'share-button'
    }, button({
      onClick: this.toggleShare
    }, translate("~SHARE_DIALOG.ENABLE_SHARING")), div({
      className: 'share-button-help-not-sharing'
    }, translate("~SHARE_DIALOG.ENABLE_SHARING_MESSAGE"))))), sharing ? div({}, ul({
      className: 'sharing-tabs'
    }, li({
      className: "sharing-tab" + (this.state.tabSelected === 'link' ? ' sharing-tab-selected' : ''),
      style: {
        marginLeft: 10
      },
      onClick: this.selectLinkTab
    }, translate("~SHARE_DIALOG.LINK_TAB")), li({
      className: "sharing-tab sharing-tab-embed" + (this.state.tabSelected === 'embed' ? ' sharing-tab-selected' : ''),
      onClick: this.selectEmbedTab
    }, translate("~SHARE_DIALOG.EMBED_TAB")), this.props.enableLaraSharing ? li({
      className: "sharing-tab sharing-tab-lara" + (this.state.tabSelected === 'lara' ? ' sharing-tab-selected' : ''),
      onClick: this.selectLaraTab
    }, "LARA") : void 0), div({
      className: 'sharing-tab-contents'
    }, (function() {
      switch (this.state.tabSelected) {
        case 'embed':
          return div({}, translate("~SHARE_DIALOG.EMBED_MESSAGE"), document.execCommand || window.clipboardData ? a({
            className: 'copy-link',
            href: '#',
            onClick: this.copy
          }, translate('~SHARE_DIALOG.COPY')) : void 0, div({}, textarea({
            value: this.state.embed,
            readOnly: true
          })));
        case 'lara':
          return div({}, translate("~SHARE_DIALOG.LARA_MESSAGE"), document.execCommand || window.clipboardData ? a({
            className: 'copy-link',
            href: '#',
            onClick: this.copy
          }, translate('~SHARE_DIALOG.COPY')) : void 0, div({}, input({
            value: this.getLara(),
            readOnly: true
          })), div({
            className: 'lara-settings'
          }, div({
            className: 'codap-server-url'
          }, this.state.serverUrlLabel, div({}, input({
            value: this.state.serverUrl,
            onChange: this.changedServerUrl
          }))), div({
            className: 'autolaunch'
          }, input({
            type: 'checkbox',
            checked: this.state.pageType === 'autolaunch',
            onChange: this.changedAutoscalingPage
          }), translate("~SHARE_DIALOG.LARA_AUTOLAUNCH_PAGE")), this.state.pageType === 'autolaunch' ? div({
            className: 'fullsceen-scaling'
          }, input({
            type: 'checkbox',
            checked: this.state.fullscreenScaling,
            onChange: this.changedFullscreenScaling
          }), translate("~SHARE_DIALOG.LARA_FULLSCREEN_BUTTON_AND_SCALING")) : void 0, this.state.pageType === 'launch' ? div({
            className: 'launch-button-text'
          }, translate("~SHARE_DIALOG.LARA_LAUNCH_BUTTON_TEXT"), input({
            value: this.state.launchButtonText,
            onChange: this.changedLaunchButtonText
          })) : void 0, div({}, input({
            type: 'checkbox',
            checked: this.state.graphVisToggles,
            onChange: this.changedGraphVisToggles
          }), translate("~SHARE_DIALOG.LARA_DISPLAY_VISIBILITY_TOGGLES"))));
        default:
          return div({}, translate("~SHARE_DIALOG.LINK_MESSAGE"), document.execCommand || window.clipboardData ? a({
            className: 'copy-link',
            href: '#',
            onClick: this.copy
          }, translate('~SHARE_DIALOG.COPY')) : void 0, div({}, input({
            value: this.state.link,
            readOnly: true
          })), div({
            className: 'social-icons'
          }, SocialIcon({
            icon: 'facebook',
            url: "https://www.facebook.com/sharer/sharer.php?u=" + (encodeURIComponent(this.state.link))
          }), SocialIcon({
            icon: 'twitter',
            url: "https://twitter.com/home?status=" + (encodeURIComponent(this.state.link))
          })));
      }
    }).call(this))) : void 0, div({
      className: 'buttons'
    }, button({
      onClick: this.props.close
    }, translate('~SHARE_DIALOG.CLOSE'))), SHOW_LONGEVITY_WARNING ? div({
      className: 'longevity-warning'
    }, translate('~SHARE_DIALOG.LONGEVITY_WARNING')) : void 0));
  }
});


},{"../utils/get-query-param":70,"../utils/translate":80,"./modal-dialog-view":95,"svg-social-icons/lib/icons.json":51}],102:[function(require,module,exports){
var Tab, TabInfo, a, div, li, ref, ul;

ref = React.DOM, div = ref.div, ul = ref.ul, li = ref.li, a = ref.a;

TabInfo = (function() {
  function TabInfo(settings) {
    if (settings == null) {
      settings = {};
    }
    this.label = settings.label, this.component = settings.component, this.capability = settings.capability, this.onSelected = settings.onSelected;
  }

  return TabInfo;

})();

Tab = React.createFactory(React.createClass({
  displayName: 'TabbedPanelTab',
  clicked: function(e) {
    e.preventDefault();
    return this.props.onSelected(this.props.index);
  },
  render: function() {
    var classname;
    classname = this.props.selected ? 'tab-selected' : '';
    return li({
      className: classname,
      onClick: this.clicked
    }, this.props.label);
  }
}));

module.exports = React.createClass({
  displayName: 'TabbedPanelView',
  getInitialState: function() {
    return {
      selectedTabIndex: this.props.selectedTabIndex || 0
    };
  },
  componentDidMount: function() {
    var base;
    return typeof (base = this.props.tabs[this.state.selectedTabIndex]).onSelected === "function" ? base.onSelected(this.props.tabs[this.state.selectedTabIndex].capability) : void 0;
  },
  statics: {
    Tab: function(settings) {
      return new TabInfo(settings);
    }
  },
  selectedTab: function(index) {
    var base;
    if (typeof (base = this.props.tabs[index]).onSelected === "function") {
      base.onSelected(this.props.tabs[index].capability);
    }
    return this.setState({
      selectedTabIndex: index
    });
  },
  renderTab: function(tab, index) {
    return Tab({
      label: tab.label,
      key: index,
      index: index,
      selected: index === this.state.selectedTabIndex,
      onSelected: this.selectedTab
    });
  },
  renderTabs: function() {
    var index, tab;
    return div({
      className: 'workspace-tabs'
    }, (function() {
      var i, len, ref1, results;
      ref1 = this.props.tabs;
      results = [];
      for (index = i = 0, len = ref1.length; i < len; index = ++i) {
        tab = ref1[index];
        results.push(ul({
          key: index
        }, this.renderTab(tab, index)));
      }
      return results;
    }).call(this));
  },
  renderSelectedPanel: function() {
    var index, tab;
    return div({
      className: 'workspace-tab-component'
    }, (function() {
      var i, len, ref1, results;
      ref1 = this.props.tabs;
      results = [];
      for (index = i = 0, len = ref1.length; i < len; index = ++i) {
        tab = ref1[index];
        results.push(div({
          key: index,
          style: {
            display: index === this.state.selectedTabIndex ? 'block' : 'none'
          }
        }, tab.component));
      }
      return results;
    }).call(this));
  },
  render: function() {
    return div({
      className: "tabbed-panel"
    }, this.renderTabs(), this.renderSelectedPanel());
  }
});


},{}],103:[function(require,module,exports){
var button, div, input, ref, tr;

ref = React.DOM, div = ref.div, input = ref.input, button = ref.button;

tr = require('../utils/translate');

module.exports = React.createClass({
  displayName: 'UrlTab',
  getInitialState: function() {
    return {
      hover: false
    };
  },
  importUrl: function(url, via) {
    var base;
    if (typeof (base = this.props.dialog).callback === "function") {
      base.callback(url, via);
    }
    return this.props.close();
  },
  "import": function() {
    var url;
    url = $.trim(ReactDOM.findDOMNode(this.refs.url).value);
    if (url.length === 0) {
      return this.props.client.alert(tr("~IMPORT_URL.PLEASE_ENTER_URL"));
    } else {
      return this.importUrl(url, 'select');
    }
  },
  cancel: function() {
    return this.props.close();
  },
  dragEnter: function(e) {
    e.preventDefault();
    return this.setState({
      hover: true
    });
  },
  dragLeave: function(e) {
    e.preventDefault();
    return this.setState({
      hover: false
    });
  },
  drop: function(e) {
    var droppedUrls;
    e.preventDefault();
    if (e.dataTransfer) {
      droppedUrls = (e.dataTransfer.getData('url') || e.dataTransfer.getData('text/uri-list') || '').split('\n');
      if (droppedUrls.length > 1) {
        return this.props.client.alert(tr("~IMPORT_URL.MULTIPLE_URLS_DROPPED"));
      } else if (droppedUrls.length === 1) {
        return this.importUrl(droppedUrls[0], 'drop');
      }
    }
  },
  render: function() {
    var dropClass;
    dropClass = "urlDropArea" + (this.state.hover ? ' dropHover' : '');
    return div({
      className: 'dialogTab urlImport'
    }, div({
      className: dropClass,
      onDragEnter: this.dragEnter,
      onDragLeave: this.dragLeave,
      onDrop: this.drop
    }, tr("~URL_TAB.DROP_URL_HERE")), input({
      ref: 'url',
      placeholder: 'URL'
    }), div({
      className: 'buttons'
    }, button({
      onClick: this["import"]
    }, tr("~URL_TAB.IMPORT")), button({
      onClick: this.cancel
    }, tr("~FILE_DIALOG.CANCEL"))));
  }
});


},{"../utils/translate":80}]},{},[52,53])(53)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9jb252ZXJ0L2RtcC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9jb252ZXJ0L3htbC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9kaWZmL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvZGlmZi9zcmMvZGlmZi9jaGFyYWN0ZXIuanMiLCJub2RlX21vZHVsZXMvZGlmZi9zcmMvZGlmZi9jc3MuanMiLCJub2RlX21vZHVsZXMvZGlmZi9zcmMvZGlmZi9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2RpZmYvc3JjL2RpZmYvbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9kaWZmL3NlbnRlbmNlLmpzIiwibm9kZV9tb2R1bGVzL2RpZmYvc3JjL2RpZmYvd29yZC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9wYXRjaC9hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy9wYXRjaC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvZGlmZi9zcmMvcGF0Y2gvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvZGlmZi9zcmMvdXRpbC9kaXN0YW5jZS1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmL3NyYy91dGlsL3BhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvamlmZi9qaWZmLmpzIiwibm9kZV9tb2R1bGVzL2ppZmYvbGliL0ludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2ppZmYvbGliL1BhdGNoTm90SW52ZXJ0aWJsZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2ppZmYvbGliL1Rlc3RGYWlsZWRFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9jb21tdXRlUGF0aHMuanMiLCJub2RlX21vZHVsZXMvamlmZi9saWIvZGVlcEVxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9pbnZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2ppZmYvbGliL2pzb25QYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9qc29uUG9pbnRlci5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9qc29uUG9pbnRlclBhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2ppZmYvbGliL2xjcy5qcyIsIm5vZGVfbW9kdWxlcy9qaWZmL2xpYi9wYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJhc2U2NC9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvc3ZnLXNvY2lhbC1pY29ucy9saWIvaWNvbnMuanNvbiIsInBhY2thZ2UuanNvbiIsInNyYy9jb2RlL2FwcC5jb2ZmZWUiLCJzcmMvY29kZS9jbGllbnQuY29mZmVlIiwic3JjL2NvZGUvbGliL2ZpbGUtc2F2ZXIuanMiLCJzcmMvY29kZS9wcm92aWRlcnMvZG9jdW1lbnQtc3RvcmUtcHJvdmlkZXIuY29mZmVlIiwic3JjL2NvZGUvcHJvdmlkZXJzL2RvY3VtZW50LXN0b3JlLXNoYXJlLXByb3ZpZGVyLmNvZmZlZSIsInNyYy9jb2RlL3Byb3ZpZGVycy9kb2N1bWVudC1zdG9yZS11cmwuY29mZmVlIiwic3JjL2NvZGUvcHJvdmlkZXJzL2dvb2dsZS1kcml2ZS1wcm92aWRlci5jb2ZmZWUiLCJzcmMvY29kZS9wcm92aWRlcnMvbGFyYS1wcm92aWRlci5jb2ZmZWUiLCJzcmMvY29kZS9wcm92aWRlcnMvbG9jYWwtZmlsZS1wcm92aWRlci5jb2ZmZWUiLCJzcmMvY29kZS9wcm92aWRlcnMvbG9jYWxzdG9yYWdlLXByb3ZpZGVyLmNvZmZlZSIsInNyYy9jb2RlL3Byb3ZpZGVycy9wYXRjaGFibGUtY29udGVudC5jb2ZmZWUiLCJzcmMvY29kZS9wcm92aWRlcnMvcG9zdC1tZXNzYWdlLXByb3ZpZGVyLmNvZmZlZSIsInNyYy9jb2RlL3Byb3ZpZGVycy9wcm92aWRlci1pbnRlcmZhY2UuY29mZmVlIiwic3JjL2NvZGUvcHJvdmlkZXJzL3JlYWRvbmx5LXByb3ZpZGVyLmNvZmZlZSIsInNyYy9jb2RlL3Byb3ZpZGVycy91cmwtcHJvdmlkZXIuY29mZmVlIiwic3JjL2NvZGUvdWkuY29mZmVlIiwic3JjL2NvZGUvdXRpbHMvZ2V0LWhhc2gtcGFyYW0uY29mZmVlIiwic3JjL2NvZGUvdXRpbHMvZ2V0LXF1ZXJ5LXBhcmFtLmNvZmZlZSIsInNyYy9jb2RlL3V0aWxzL2lzLWFycmF5LmNvZmZlZSIsInNyYy9jb2RlL3V0aWxzL2lzLXN0cmluZy5jb2ZmZWUiLCJzcmMvY29kZS91dGlscy9sYW5nL2RlLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL2VsLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL2VuLVVTLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL2VzLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL2hlLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL3RyLmpzb24iLCJzcmMvY29kZS91dGlscy9sYW5nL3poLVRXLmpzb24iLCJzcmMvY29kZS91dGlscy90cmFuc2xhdGUuY29mZmVlIiwic3JjL2NvZGUvdXRpbHMvdXJsLXBhcmFtcy5qcyIsInNyYy9jb2RlL3ZpZXdzL2FsZXJ0LWRpYWxvZy12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2FwcC12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2F1dGhvcml6ZS1taXhpbi5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9ibG9ja2luZy1tb2RhbC12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2NvbmZpcm0tZGlhbG9nLXZpZXcuY29mZmVlIiwic3JjL2NvZGUvdmlld3MvZG93bmxvYWQtZGlhbG9nLXZpZXcuY29mZmVlIiwic3JjL2NvZGUvdmlld3MvZHJvcGRvd24tYW5jaG9ycy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9kcm9wZG93bi12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2ZpbGUtZGlhbG9nLXRhYi12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2ltcG9ydC10YWJiZWQtZGlhbG9nLXZpZXcuY29mZmVlIiwic3JjL2NvZGUvdmlld3MvbG9jYWwtZmlsZS10YWItbGlzdC12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL2xvY2FsLWZpbGUtdGFiLXNhdmUtdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9tZW51LWJhci12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL21vZGFsLWRpYWxvZy12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL21vZGFsLXRhYmJlZC1kaWFsb2ctdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9tb2RhbC12aWV3LmNvZmZlZSIsInNyYy9jb2RlL3ZpZXdzL3Byb3ZpZGVyLXRhYmJlZC1kaWFsb2ctdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9yZW5hbWUtZGlhbG9nLXZpZXcuY29mZmVlIiwic3JjL2NvZGUvdmlld3Mvc2VsZWN0LXByb3ZpZGVyLWRpYWxvZy10YWItdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy9zaGFyZS1kaWFsb2ctdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy90YWJiZWQtcGFuZWwtdmlldy5jb2ZmZWUiLCJzcmMvY29kZS92aWV3cy91cmwtdGFiLXZpZXcuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUV4QixVQUFJLFFBQVEsY0FBUixDQUF1QixJQUF2QixDQUFKLEVBQWtDO0FBQ2hDLGlCQUFTLElBQVQsSUFBaUIsUUFBUSxJQUFSLENBQWpCLENBRGdDO09BQWxDO0tBRkY7R0FESztBQVFQLFNBQU8sUUFBUCxDQVhpRDtDQUE1Qzs7OztBQ0FQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQSxJQUFBOztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsY0FBUjs7QUFFWixhQUFBLEdBQWdCO0VBQ2Q7SUFBQyxHQUFBLEVBQUssSUFBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsV0FBUixDQUF6QjtHQURjLEVBRWQ7SUFBQyxHQUFBLEVBQUssSUFBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsV0FBUixDQUF6QjtHQUZjLEVBR2Q7SUFBQyxHQUFBLEVBQUssT0FBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsY0FBUixDQUF6QjtHQUhjLEVBSWQ7SUFBQyxHQUFBLEVBQUssSUFBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsV0FBUixDQUF6QjtHQUpjLEVBS2Q7SUFBQyxHQUFBLEVBQUssSUFBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsV0FBUixDQUF6QjtHQUxjLEVBTWQ7SUFBQyxHQUFBLEVBQUssSUFBTjtJQUFlLFFBQUEsRUFBVSxPQUFBLENBQVEsV0FBUixDQUF6QjtHQU5jLEVBT2Q7SUFBQyxHQUFBLEVBQUssT0FBTjtJQUFlLFFBQUEs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OztFQUZJLENBM0JOO0VBb0NBLE1BQUEsRUFBUSxTQUFBO0FBQ04sUUFBQTtJQUFBLFNBQUEsR0FBWSxhQUFBLEdBQWEsQ0FBSSxJQUFDLENBQUEsS0FBSyxDQUFDLEtBQVYsR0FBcUIsWUFBckIsR0FBdUMsRUFBeEM7V0FDeEIsR0FBQSxDQUFJO01BQUMsU0FBQSxFQUFXLHFCQUFaO0tBQUosRUFDRSxHQUFBLENBQUk7TUFBQyxTQUFBLEVBQVcsU0FBWjtNQUF1QixXQUFBLEVBQWEsSUFBQyxDQUFBLFNBQXJDO01BQWdELFdBQUEsRUFBYSxJQUFDLENBQUEsU0FBOUQ7TUFBeUUsTUFBQSxFQUFRLElBQUMsQ0FBQSxJQUFsRjtLQUFKLEVBQ0UsRUFBQSxDQUFHLHdCQUFILENBREYsQ0FERixFQUlFLEtBQUEsQ0FBTTtNQUFDLEdBQUEsRUFBSyxLQUFOO01BQWEsV0FBQSxFQUFhLEtBQTFCO0tBQU4sQ0FKRixFQUtFLEdBQUEsQ0FBSTtNQUFDLFNBQUEsRUFBVyxTQUFaO0tBQUosRUFDRSxNQUFBLENBQU87TUFBQyxPQUFBLEVBQVMsSUFBQyxFQUFBLE1BQUEsRUFBWDtLQUFQLEVBQTRCLEVBQUEsQ0FBRyxpQkFBSCxDQUE1QixDQURGLEVBRUUsTUFBQSxDQUFPO01BQUMsT0FBQSxFQUFTLElBQUMsQ0FBQSxNQUFYO0tBQVAsRUFBNEIsRUFBQSxDQUFHLHFCQUFILENBQTVCLENBRkYsQ0FMRjtFQUZLLENBcENSO0NBRmUiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gU2VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvd2lraS9BUElcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcbiAgbGV0IHJldCA9IFtdLFxuICAgICAgY2hhbmdlLFxuICAgICAgb3BlcmF0aW9uO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIG9wZXJhdGlvbiA9IDE7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgb3BlcmF0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goW29wZXJhdGlvbiwgY2hhbmdlLnZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XG4gIGxldCBuID0gcztcbiAgbiA9IG4ucmVwbGFjZSgvJi9nLCAnJmFtcDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcblxuICByZXR1cm4gbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpZmYoKSB7fVxuXG5EaWZmLnByb3RvdHlwZSA9IHtcbiAgZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcblxuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG5cbiAgICBsZXQgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCwgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcbiAgICBsZXQgZWRpdExlbmd0aCA9IDE7XG4gICAgbGV0IG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XG4gICAgbGV0IGJlc3RQYXRoID0gW3sgbmV3UG9zOiAtMSwgY29tcG9uZW50czogW10gfV07XG5cbiAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuICAgIGxldCBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcbiAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxuICAgICAgcmV0dXJuIGRvbmUoW3t2YWx1ZTogbmV3U3RyaW5nLmpvaW4oJycpLCBjb3VudDogbmV3U3RyaW5nLmxlbmd0aH1dKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKGxldCBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICBsZXQgYmFzZVBhdGg7XG4gICAgICAgIGxldCBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBvbGRQb3MgJiYgb2xkUG9zIDwgb2xkTGVuO1xuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuICAgICAgICBpZiAoIWNhbkFkZCB8fCAoY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAgIC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgIC8vIGlzIHByb2R1Y2VkLlxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgbGV0IHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICBsZXQgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XG4gICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7Y291bnQ6IGxhc3QuY291bnQgKyAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHtjb3VudDogMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcblxuICAgICAgICBjb21tb25Db3VudCA9IDA7XG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtjb3VudDogY29tbW9uQ291bnR9KTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgcmV0dXJuIG9sZFBvcztcbiAgfSxcblxuICBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH0sXG4gIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIGxldCBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgbGV0IG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQudmFsdWUgPSB2YWx1ZS5qb2luKCcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkuam9pbignJyk7XG4gICAgICB9XG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuXG4gICAgICAvLyBDb21tb24gY2FzZVxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gb2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KS5qb2luKCcnKTtcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG5cbiAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgbGV0IHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkLiBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZVxuICAvLyB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgbGV0IGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKVxuICAgICAgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XG59XG4iLCJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiIsImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBjb25zdCBjc3NEaWZmID0gbmV3IERpZmYoKTtcbmNzc0RpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxccyspLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNzcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9XG4iLCJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHtsaW5lRGlmZn0gZnJvbSAnLi9saW5lJztcblxuY29uc3Qgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cbmV4cG9ydCBjb25zdCBqc29uRGlmZiA9IG5ldyBEaWZmKCk7XG4vLyBEaXNjcmltaW5hdGUgYmV0d2VlbiB0d28gbGluZXMgb2YgcHJldHR5LXByaW50ZWQsIHNlcmlhbGl6ZWQgSlNPTiB3aGVyZSBvbmUgb2YgdGhlbSBoYXMgYVxuLy8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XG5qc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xuXG5qc29uRGlmZi50b2tlbml6ZSA9IGxpbmVEaWZmLnRva2VuaXplO1xuanNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSksIHVuZGVmaW5lZCwgJyAgJyk7XG59O1xuanNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIERpZmYucHJvdG90eXBlLmVxdWFscyhsZWZ0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIGNhbGxiYWNrKSB7IHJldHVybiBqc29uRGlmZi5kaWZmKG9sZE9iaiwgbmV3T2JqLCBjYWxsYmFjayk7IH1cblxuXG4vLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbi8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuXG5leHBvcnQgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgbGV0IGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrKTtcbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICBsZXQgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAga2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG4iLCJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHtnZW5lcmF0ZU9wdGlvbnN9IGZyb20gJy4uL3V0aWwvcGFyYW1zJztcblxuZXhwb3J0IGNvbnN0IGxpbmVEaWZmID0gbmV3IERpZmYoKTtcbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IHJldExpbmVzID0gW10sXG4gICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXG58XFxyXFxuKS8pO1xuXG4gIC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuICBpZiAoIWxpbmVzQW5kTmV3bGluZXNbbGluZXNBbmROZXdsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgIGxpbmVzQW5kTmV3bGluZXMucG9wKCk7XG4gIH1cblxuICAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XG5cbiAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xuICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldExpbmVzO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTsgfVxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZUcmltbWVkTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIGxldCBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKGNhbGxiYWNrLCB7aWdub3JlV2hpdGVzcGFjZTogdHJ1ZX0pO1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuXG5cbmV4cG9ydCBjb25zdCBzZW50ZW5jZURpZmYgPSBuZXcgRGlmZigpO1xuc2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBzZW50ZW5jZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9XG4iLCJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHtnZW5lcmF0ZU9wdGlvbnN9IGZyb20gJy4uL3V0aWwvcGFyYW1zJztcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fc2NyaXB0X2luX1VuaWNvZGVcbi8vXG4vLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcbmNvbnN0IGV4dGVuZGVkV29yZENoYXJzID0gL15bYS16QS1aXFx1e0MwfS1cXHV7RkZ9XFx1e0Q4fS1cXHV7RjZ9XFx1e0Y4fS1cXHV7MkM2fVxcdXsyQzh9LVxcdXsyRDd9XFx1ezJERX0tXFx1ezJGRn1cXHV7MUUwMH0tXFx1ezFFRkZ9XSskL3U7XG5cbmNvbnN0IHJlV2hpdGVzcGFjZSA9IC9cXFMvO1xuXG5leHBvcnQgY29uc3Qgd29yZERpZmYgPSBuZXcgRGlmZigpO1xud29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8ICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KSk7XG59O1xud29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhcXHMrfFxcYikvKTtcblxuICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgbGV0IG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG4iLCIvKiBTZWUgTElDRU5TRSBmaWxlIGZvciB0ZXJtcyBvZiB1c2UgKi9cblxuLypcbiAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBBUElTOlxuICogSnNEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXG4gKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcYiByZWdleCkgZGlmZiB3aGljaCBpZ25vcmVzIHdoaXRlc3BhY2VcbiAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxuICpcbiAqIEpzRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XG4gKlxuICogVGhlc2UgbWV0aG9kcyBhcmUgYmFzZWQgb24gdGhlIGltcGxlbWVudGF0aW9uIHByb3Bvc2VkIGluXG4gKiBcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgVmFyaWF0aW9uc1wiIChNeWVycywgMTk4NikuXG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQuNjkyN1xuICovXG5pbXBvcnQgRGlmZiBmcm9tICcuL2RpZmYvYmFzZSc7XG5pbXBvcnQge2RpZmZDaGFyc30gZnJvbSAnLi9kaWZmL2NoYXJhY3Rlcic7XG5pbXBvcnQge2RpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlfSBmcm9tICcuL2RpZmYvd29yZCc7XG5pbXBvcnQge2RpZmZMaW5lcywgZGlmZlRyaW1tZWRMaW5lc30gZnJvbSAnLi9kaWZmL2xpbmUnO1xuaW1wb3J0IHtkaWZmU2VudGVuY2VzfSBmcm9tICcuL2RpZmYvc2VudGVuY2UnO1xuXG5pbXBvcnQge2RpZmZDc3N9IGZyb20gJy4vZGlmZi9jc3MnO1xuaW1wb3J0IHtkaWZmSnNvbiwgY2Fub25pY2FsaXplfSBmcm9tICcuL2RpZmYvanNvbic7XG5cbmltcG9ydCB7YXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzfSBmcm9tICcuL3BhdGNoL2FwcGx5JztcbmltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXRjaC9wYXJzZSc7XG5pbXBvcnQge3N0cnVjdHVyZWRQYXRjaCwgY3JlYXRlVHdvRmlsZXNQYXRjaCwgY3JlYXRlUGF0Y2h9IGZyb20gJy4vcGF0Y2gvY3JlYXRlJztcblxuaW1wb3J0IHtjb252ZXJ0Q2hhbmdlc1RvRE1QfSBmcm9tICcuL2NvbnZlcnQvZG1wJztcbmltcG9ydCB7Y29udmVydENoYW5nZXNUb1hNTH0gZnJvbSAnLi9jb252ZXJ0L3htbCc7XG5cbmV4cG9ydCB7XG4gIERpZmYsXG5cbiAgZGlmZkNoYXJzLFxuICBkaWZmV29yZHMsXG4gIGRpZmZXb3Jkc1dpdGhTcGFjZSxcbiAgZGlmZkxpbmVzLFxuICBkaWZmVHJpbW1lZExpbmVzLFxuICBkaWZmU2VudGVuY2VzLFxuXG4gIGRpZmZDc3MsXG4gIGRpZmZKc29uLFxuXG4gIHN0cnVjdHVyZWRQYXRjaCxcbiAgY3JlYXRlVHdvRmlsZXNQYXRjaCxcbiAgY3JlYXRlUGF0Y2gsXG4gIGFwcGx5UGF0Y2gsXG4gIGFwcGx5UGF0Y2hlcyxcbiAgcGFyc2VQYXRjaCxcbiAgY29udmVydENoYW5nZXNUb0RNUCxcbiAgY29udmVydENoYW5nZXNUb1hNTCxcbiAgY2Fub25pY2FsaXplXG59O1xuIiwiaW1wb3J0IHtwYXJzZVBhdGNofSBmcm9tICcuL3BhcnNlJztcbmltcG9ydCBkaXN0YW5jZUl0ZXJhdG9yIGZyb20gJy4uL3V0aWwvZGlzdGFuY2UtaXRlcmF0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9IHBhcnNlUGF0Y2godW5pRGlmZik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh1bmlEaWZmKSkge1xuICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XG4gICAgfVxuXG4gICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XG4gIH1cblxuICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKSxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcblxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8ICgobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpID0+IGxpbmUgPT09IHBhdGNoQ29udGVudCksXG4gICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgb2Zmc2V0ID0gMCxcblxuICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICBhZGRFT0ZOTDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZVswXSxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5zdWJzdHIoMSk7XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xuICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcbiAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxuICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xuXG4gICAgbGV0IGl0ZXJhdG9yID0gZGlzdGFuY2VJdGVyYXRvcih0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcbiAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICB9XG5cbiAgLy8gQXBwbHkgcGF0Y2ggaHVua3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIHRvUG9zID0gaHVuay5vZmZzZXQgKyBodW5rLm5ld1N0YXJ0IC0gMTtcbiAgICBpZiAoaHVuay5uZXdMaW5lcyA9PSAwKSB7IHRvUG9zKys7IH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmVbMF0sXG4gICAgICAgICAgY29udGVudCA9IGxpbmUuc3Vic3RyKDEpO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKHRvUG9zLCAxKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMCwgY29udGVudCk7XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGxldCBwcmV2aW91c09wZXJhdGlvbiA9IGh1bmsubGluZXNbaiAtIDFdID8gaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xuICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXG4gIGlmIChyZW1vdmVFT0ZOTCkge1xuICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGxpbmVzLnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgIGxpbmVzLnB1c2goJycpO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgbGV0IGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50KTtcblxuICAgICAgc2V0VGltZW91dChwcm9jZXNzSW5kZXgsIDApO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NJbmRleCgpO1xufVxuIiwiaW1wb3J0IHtkaWZmTGluZXN9IGZyb20gJy4uL2RpZmYvbGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgY29udGV4dDogNCB9O1xuICB9XG5cbiAgY29uc3QgZGlmZiA9IGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0cik7XG4gIGRpZmYucHVzaCh7dmFsdWU6ICcnLCBsaW5lczogW119KTsgICAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxuXG4gIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICcgJyArIGVudHJ5OyB9KTtcbiAgfVxuXG4gIGxldCBodW5rcyA9IFtdO1xuICBsZXQgb2xkUmFuZ2VTdGFydCA9IDAsIG5ld1JhbmdlU3RhcnQgPSAwLCBjdXJSYW5nZSA9IFtdLFxuICAgICAgb2xkTGluZSA9IDEsIG5ld0xpbmUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gZGlmZltpXSxcbiAgICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG5cbiAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XG4gICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcbiAgICAgIGN1clJhbmdlLnB1c2goLi4uIGxpbmVzLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cbiAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcbiAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKC4uLiBjb250ZXh0TGluZXMobGluZXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcbiAgICAgICAgICBsZXQgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XG4gICAgICAgICAgY3VyUmFuZ2UucHVzaCguLi4gY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpO1xuXG4gICAgICAgICAgbGV0IGh1bmsgPSB7XG4gICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG9sZExpbmVzOiAob2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSksXG4gICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG5ld0xpbmVzOiAobmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSksXG4gICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xuICAgICAgICAgICAgbGV0IG9sZEVPRk5ld2xpbmUgPSAoL1xcbiQvLnRlc3Qob2xkU3RyKSk7XG4gICAgICAgICAgICBsZXQgbmV3RU9GTmV3bGluZSA9ICgvXFxuJC8udGVzdChuZXdTdHIpKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gMCAmJiAhb2xkRU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvbGRFT0ZOZXdsaW5lIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuXG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxuICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLCBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICBodW5rczogaHVua3NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlmZiA9IHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG5cbiAgY29uc3QgcmV0ID0gW107XG4gIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xuICAgIHJldC5wdXNoKCdJbmRleDogJyArIG9sZEZpbGVOYW1lKTtcbiAgfVxuICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaHVuayA9IGRpZmYuaHVua3NbaV07XG4gICAgcmV0LnB1c2goXG4gICAgICAnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lc1xuICAgICAgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXNcbiAgICAgICsgJyBAQCdcbiAgICApO1xuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoJ1xcbicpLFxuICAgICAgbGlzdCA9IFtdLFxuICAgICAgaSA9IDA7XG5cbiAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICBsZXQgaW5kZXggPSB7fTtcbiAgICBsaXN0LnB1c2goaW5kZXgpO1xuXG4gICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcbiAgICAgIGlmICgvXihcXC1cXC1cXC18XFwrXFwrXFwrfEBAKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRGlmZiBpbmRleFxuICAgICAgbGV0IGhlYWRlciA9ICgvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcdyspKylcXHMrKC4rPylcXHMqJC8pLmV4ZWMobGluZSk7XG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgZmlsZSBoZWFkZXJzIGlmIHRoZXkgYXJlIGRlZmluZWQuIFVuaWZpZWQgZGlmZiByZXF1aXJlcyB0aGVtLCBidXRcbiAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcbiAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG5cbiAgICAvLyBQYXJzZSBodW5rc1xuICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICBsZXQgbGluZSA9IGRpZmZzdHJbaV07XG5cbiAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChsaW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAobGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KGxpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgIGxldCBmaWxlSGVhZGVyID0gKC9eKFxcLVxcLVxcLXxcXCtcXCtcXCspXFxzKyhcXFMqKVxccz8oLio/KVxccyokLykuZXhlYyhkaWZmc3RyW2ldKTtcbiAgICBpZiAoZmlsZUhlYWRlcikge1xuICAgICAgbGV0IGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZUhlYWRlclsyXTtcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IGZpbGVIZWFkZXJbM107XG5cbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgYSBodW5rXG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgbGV0IGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuXG4gICAgbGV0IGh1bmsgPSB7XG4gICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxuICAgICAgb2xkTGluZXM6ICtjaHVua0hlYWRlclsyXSB8fCAxLFxuICAgICAgbmV3U3RhcnQ6ICtjaHVua0hlYWRlclszXSxcbiAgICAgIG5ld0xpbmVzOiArY2h1bmtIZWFkZXJbNF0gfHwgMSxcbiAgICAgIGxpbmVzOiBbXVxuICAgIH07XG5cbiAgICBsZXQgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3BlcmF0aW9uID0gZGlmZnN0cltpXVswXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG4gICAgaWYgKCFhZGRDb3VudCAmJiBodW5rLm5ld0xpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm5ld0xpbmVzID0gMDtcbiAgICB9XG4gICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZUNvdW50ICE9PSBodW5rLm9sZExpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bms7XG4gIH1cblxuICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgcGFyc2VJbmRleCgpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG4iLCIvLyBJdGVyYXRvciB0aGF0IHRyYXZlcnNlcyBpbiB0aGUgcmFuZ2Ugb2YgW21pbiwgbWF4XSwgc3RlcHBpbmdcbi8vIGJ5IGRpc3RhbmNlIGZyb20gYSBnaXZlbiBzdGFydCBwb3NpdGlvbi4gSS5lLiBmb3IgWzAsIDRdLCB3aXRoXG4vLyBzdGFydCBvZiAyLCB0aGlzIHdpbGwgaXRlcmF0ZSAyLCAzLCAxLCA0LCAwLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcbiAgbGV0IHdhbnRGb3J3YXJkID0gdHJ1ZSxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBsb2NhbE9mZnNldCA9IDE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIGxvY2FsT2Zmc2V0Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgIGlmIChzdGFydCArIGxvY2FsT2Zmc2V0IDw9IG1heExpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICBpZiAoIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJlZm9yZSB0ZXh0IGJlZ2lubmluZywgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgLy8gYmVmb3JlIG9mZnNldCBsb2NhdGlvblxuICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xuICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpdGVyYXRvcigpO1xuICAgIH1cblxuICAgIC8vIFdlIHRyaWVkIHRvIGZpdCBodW5rIGJlZm9yZSB0ZXh0IGJlZ2lubmluZyBhbmQgYmV5b25kIHRleHQgbGVuZ2h0LCB0aGVuXG4gICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxudmFyIGxjcyA9IHJlcXVpcmUoJy4vbGliL2xjcycpO1xudmFyIGFycmF5ID0gcmVxdWlyZSgnLi9saWIvYXJyYXknKTtcbnZhciBwYXRjaCA9IHJlcXVpcmUoJy4vbGliL2pzb25QYXRjaCcpO1xudmFyIGludmVyc2UgPSByZXF1aXJlKCcuL2xpYi9pbnZlcnNlJyk7XG52YXIganNvblBvaW50ZXIgPSByZXF1aXJlKCcuL2xpYi9qc29uUG9pbnRlcicpO1xudmFyIGVuY29kZVNlZ21lbnQgPSBqc29uUG9pbnRlci5lbmNvZGVTZWdtZW50O1xuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZXhwb3J0cy5wYXRjaCA9IHBhdGNoLmFwcGx5O1xuZXhwb3J0cy5wYXRjaEluUGxhY2UgPSBwYXRjaC5hcHBseUluUGxhY2U7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5jbG9uZSA9IHBhdGNoLmNsb25lO1xuXG4vLyBFcnJvcnNcbmV4cG9ydHMuSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9JbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcicpO1xuZXhwb3J0cy5UZXN0RmFpbGVkRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9UZXN0RmFpbGVkRXJyb3InKTtcbmV4cG9ydHMuUGF0Y2hOb3RJbnZlcnRpYmxlRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9QYXRjaE5vdEludmVydGlibGVFcnJvcicpO1xuXG52YXIgaXNWYWxpZE9iamVjdCA9IHBhdGNoLmlzVmFsaWRPYmplY3Q7XG52YXIgZGVmYXVsdEhhc2ggPSBwYXRjaC5kZWZhdWx0SGFzaDtcblxuLyoqXG4gKiBDb21wdXRlIGEgSlNPTiBQYXRjaCByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYSBhbmQgYi5cbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ3xudW1iZXJ8bnVsbH0gYVxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfG51bWJlcnxudWxsfSBiXG4gKiBAcGFyYW0gez9mdW5jdGlvbnw/b2JqZWN0fSBvcHRpb25zIGlmIGEgZnVuY3Rpb24sIHNlZSBvcHRpb25zLmhhc2hcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHg6Kik6U3RyaW5nfE51bWJlcn0gb3B0aW9ucy5oYXNoIHVzZWQgdG8gaGFzaCBhcnJheSBpdGVtc1xuICogIGluIG9yZGVyIHRvIHJlY29nbml6ZSBpZGVudGljYWwgb2JqZWN0cywgZGVmYXVsdHMgdG8gSlNPTi5zdHJpbmdpZnlcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKGluZGV4Ok51bWJlciwgYXJyYXk6QXJyYXkpOm9iamVjdH0gb3B0aW9ucy5tYWtlQ29udGV4dFxuICogIHVzZWQgdG8gZ2VuZXJhdGUgcGF0Y2ggY29udGV4dC4gSWYgbm90IHByb3ZpZGVkLCBjb250ZXh0IHdpbGwgbm90IGJlIGdlbmVyYXRlZFxuICogQHJldHVybnMge2FycmF5fSBKU09OIFBhdGNoIHN1Y2ggdGhhdCBwYXRjaChkaWZmKGEsIGIpLCBhKSB+IGJcbiAqL1xuZnVuY3Rpb24gZGlmZihhLCBiLCBvcHRpb25zKSB7XG5cdHJldHVybiBhcHBlbmRDaGFuZ2VzKGEsIGIsICcnLCBpbml0U3RhdGUob3B0aW9ucywgW10pKS5wYXRjaDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgaW5pdGlhbCBkaWZmIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufD9vYmplY3R9IG9wdGlvbnMgQHNlZSBkaWZmIG9wdGlvbnMgYWJvdmVcbiAqIEBwYXJhbSB7YXJyYXl9IHBhdGNoIGFuIGVtcHR5IG9yIGV4aXN0aW5nIEpTT04gUGF0Y2ggYXJyYXkgaW50byB3aGljaFxuICogIHRoZSBkaWZmIHNob3VsZCBnZW5lcmF0ZSBuZXcgcGF0Y2ggb3BlcmF0aW9uc1xuICogQHJldHVybnMge29iamVjdH0gaW5pdGlhbGl6ZWQgZGlmZiBzdGF0ZVxuICovXG5mdW5jdGlvbiBpbml0U3RhdGUob3B0aW9ucywgcGF0Y2gpIHtcblx0aWYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHBhdGNoOiBwYXRjaCxcblx0XHRcdGhhc2g6IG9yRWxzZShpc0Z1bmN0aW9uLCBvcHRpb25zLmhhc2gsIGRlZmF1bHRIYXNoKSxcblx0XHRcdG1ha2VDb250ZXh0OiBvckVsc2UoaXNGdW5jdGlvbiwgb3B0aW9ucy5tYWtlQ29udGV4dCwgZGVmYXVsdENvbnRleHQpLFxuXHRcdFx0aW52ZXJ0aWJsZTogIShvcHRpb25zLmludmVydGlibGUgPT09IGZhbHNlKVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHBhdGNoOiBwYXRjaCxcblx0XHRcdGhhc2g6IG9yRWxzZShpc0Z1bmN0aW9uLCBvcHRpb25zLCBkZWZhdWx0SGFzaCksXG5cdFx0XHRtYWtlQ29udGV4dDogZGVmYXVsdENvbnRleHQsXG5cdFx0XHRpbnZlcnRpYmxlOiB0cnVlXG5cdFx0fTtcblx0fVxufVxuXG4vKipcbiAqIEdpdmVuIHR3byBKU09OIHZhbHVlcyAob2JqZWN0LCBhcnJheSwgbnVtYmVyLCBzdHJpbmcsIGV0Yy4pLCBmaW5kIHRoZWlyXG4gKiBkaWZmZXJlbmNlcyBhbmQgYXBwZW5kIHRoZW0gdG8gdGhlIGRpZmYgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ3xudW1iZXJ8bnVsbH0gYVxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfG51bWJlcnxudWxsfSBiXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB1cGRhdGVkIGRpZmYgc3RhdGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ2hhbmdlcyhhLCBiLCBwYXRoLCBzdGF0ZSkge1xuXHRpZihBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcblx0XHRyZXR1cm4gYXBwZW5kQXJyYXlDaGFuZ2VzKGEsIGIsIHBhdGgsIHN0YXRlKTtcblx0fVxuXG5cdGlmKGlzVmFsaWRPYmplY3QoYSkgJiYgaXNWYWxpZE9iamVjdChiKSkge1xuXHRcdHJldHVybiBhcHBlbmRPYmplY3RDaGFuZ2VzKGEsIGIsIHBhdGgsIHN0YXRlKTtcblx0fVxuXG5cdHJldHVybiBhcHBlbmRWYWx1ZUNoYW5nZXMoYSwgYiwgcGF0aCwgc3RhdGUpO1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byBvYmplY3RzLCBmaW5kIHRoZWlyIGRpZmZlcmVuY2VzIGFuZCBhcHBlbmQgdGhlbSB0byB0aGUgZGlmZiBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG8xXG4gKiBAcGFyYW0ge29iamVjdH0gbzJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IHVwZGF0ZWQgZGlmZiBzdGF0ZVxuICovXG5mdW5jdGlvbiBhcHBlbmRPYmplY3RDaGFuZ2VzKG8xLCBvMiwgcGF0aCwgc3RhdGUpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvMik7XG5cdHZhciBwYXRjaCA9IHN0YXRlLnBhdGNoO1xuXHR2YXIgaSwga2V5O1xuXG5cdGZvcihpPWtleXMubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cdFx0dmFyIGtleVBhdGggPSBwYXRoICsgJy8nICsgZW5jb2RlU2VnbWVudChrZXkpO1xuXHRcdGlmKG8xW2tleV0gIT09IHZvaWQgMCkge1xuXHRcdFx0YXBwZW5kQ2hhbmdlcyhvMVtrZXldLCBvMltrZXldLCBrZXlQYXRoLCBzdGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGNoLnB1c2goeyBvcDogJ2FkZCcsIHBhdGg6IGtleVBhdGgsIHZhbHVlOiBvMltrZXldIH0pO1xuXHRcdH1cblx0fVxuXG5cdGtleXMgPSBPYmplY3Qua2V5cyhvMSk7XG5cdGZvcihpPWtleXMubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cdFx0aWYobzJba2V5XSA9PT0gdm9pZCAwKSB7XG5cdFx0XHR2YXIgcCA9IHBhdGggKyAnLycgKyBlbmNvZGVTZWdtZW50KGtleSk7XG5cdFx0XHRpZihzdGF0ZS5pbnZlcnRpYmxlKSB7XG5cdFx0XHRcdHBhdGNoLnB1c2goeyBvcDogJ3Rlc3QnLCBwYXRoOiBwLCB2YWx1ZTogbzFba2V5XSB9KTtcblx0XHRcdH1cblx0XHRcdHBhdGNoLnB1c2goeyBvcDogJ3JlbW92ZScsIHBhdGg6IHAgfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byBhcnJheXMsIGZpbmQgdGhlaXIgZGlmZmVyZW5jZXMgYW5kIGFwcGVuZCB0aGVtIHRvIHRoZSBkaWZmIHN0YXRlXG4gKiBAcGFyYW0ge2FycmF5fSBhMVxuICogQHBhcmFtIHthcnJheX0gYTJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IHVwZGF0ZWQgZGlmZiBzdGF0ZVxuICovXG5mdW5jdGlvbiBhcHBlbmRBcnJheUNoYW5nZXMoYTEsIGEyLCBwYXRoLCBzdGF0ZSkge1xuXHR2YXIgYTFoYXNoID0gYXJyYXkubWFwKHN0YXRlLmhhc2gsIGExKTtcblx0dmFyIGEyaGFzaCA9IGFycmF5Lm1hcChzdGF0ZS5oYXNoLCBhMik7XG5cblx0dmFyIGxjc01hdHJpeCA9IGxjcy5jb21wYXJlKGExaGFzaCwgYTJoYXNoKTtcblxuXHRyZXR1cm4gbGNzVG9Kc29uUGF0Y2goYTEsIGEyLCBwYXRoLCBzdGF0ZSwgbGNzTWF0cml4KTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gbGNzTWF0cml4IGludG8gSlNPTiBQYXRjaCBvcGVyYXRpb25zIGFuZCBhcHBlbmRcbiAqIHRoZW0gdG8gc3RhdGUucGF0Y2gsIHJlY3Vyc2luZyBpbnRvIGFycmF5IGVsZW1lbnRzIGFzIG5lY2Vzc2FyeVxuICogQHBhcmFtIHthcnJheX0gYTFcbiAqIEBwYXJhbSB7YXJyYXl9IGEyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gbGNzTWF0cml4XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBuZXcgc3RhdGUgd2l0aCBKU09OIFBhdGNoIG9wZXJhdGlvbnMgYWRkZWQgYmFzZWRcbiAqICBvbiB0aGUgcHJvdmlkZWQgbGNzTWF0cml4XG4gKi9cbmZ1bmN0aW9uIGxjc1RvSnNvblBhdGNoKGExLCBhMiwgcGF0aCwgc3RhdGUsIGxjc01hdHJpeCkge1xuXHR2YXIgb2Zmc2V0ID0gMDtcblx0cmV0dXJuIGxjcy5yZWR1Y2UoZnVuY3Rpb24oc3RhdGUsIG9wLCBpLCBqKSB7XG5cdFx0dmFyIGxhc3QsIGNvbnRleHQ7XG5cdFx0dmFyIHBhdGNoID0gc3RhdGUucGF0Y2g7XG5cdFx0dmFyIHAgPSBwYXRoICsgJy8nICsgKGogKyBvZmZzZXQpO1xuXG5cdFx0aWYgKG9wID09PSBsY3MuUkVNT1ZFKSB7XG5cdFx0XHQvLyBDb2FsZXNjZSBhZGphY2VudCByZW1vdmUgKyBhZGQgaW50byByZXBsYWNlXG5cdFx0XHRsYXN0ID0gcGF0Y2hbcGF0Y2gubGVuZ3RoLTFdO1xuXHRcdFx0Y29udGV4dCA9IHN0YXRlLm1ha2VDb250ZXh0KGosIGExKTtcblxuXHRcdFx0aWYoc3RhdGUuaW52ZXJ0aWJsZSkge1xuXHRcdFx0XHRwYXRjaC5wdXNoKHsgb3A6ICd0ZXN0JywgcGF0aDogcCwgdmFsdWU6IGExW2pdLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihsYXN0ICE9PSB2b2lkIDAgJiYgbGFzdC5vcCA9PT0gJ2FkZCcgJiYgbGFzdC5wYXRoID09PSBwKSB7XG5cdFx0XHRcdGxhc3Qub3AgPSAncmVwbGFjZSc7XG5cdFx0XHRcdGxhc3QuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRjaC5wdXNoKHsgb3A6ICdyZW1vdmUnLCBwYXRoOiBwLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQgLT0gMTtcblxuXHRcdH0gZWxzZSBpZiAob3AgPT09IGxjcy5BREQpIHtcblx0XHRcdC8vIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMiNzZWN0aW9uLTQuMVxuXHRcdFx0Ly8gTWF5IHVzZSBlaXRoZXIgaW5kZXg9PT1sZW5ndGggKm9yKiAnLScgdG8gaW5kaWNhdGUgYXBwZW5kaW5nIHRvIGFycmF5XG5cdFx0XHRwYXRjaC5wdXNoKHsgb3A6ICdhZGQnLCBwYXRoOiBwLCB2YWx1ZTogYTJbaV0sXG5cdFx0XHRcdGNvbnRleHQ6IHN0YXRlLm1ha2VDb250ZXh0KGosIGExKVxuXHRcdFx0fSk7XG5cblx0XHRcdG9mZnNldCArPSAxO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGFwcGVuZENoYW5nZXMoYTFbal0sIGEyW2ldLCBwLCBzdGF0ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YXRlO1xuXG5cdH0sIHN0YXRlLCBsY3NNYXRyaXgpO1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byBudW1iZXJ8c3RyaW5nfG51bGwgdmFsdWVzLCBpZiB0aGV5IGRpZmZlciwgYXBwZW5kIHRvIGRpZmYgc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxudWxsfSBhXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gYlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICogQHJldHVybnMge29iamVjdH0gdXBkYXRlZCBkaWZmIHN0YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZFZhbHVlQ2hhbmdlcyhhLCBiLCBwYXRoLCBzdGF0ZSkge1xuXHRpZihhICE9PSBiKSB7XG5cdFx0aWYoc3RhdGUuaW52ZXJ0aWJsZSkge1xuXHRcdFx0c3RhdGUucGF0Y2gucHVzaCh7IG9wOiAndGVzdCcsIHBhdGg6IHBhdGgsIHZhbHVlOiBhIH0pO1xuXHRcdH1cblxuXHRcdHN0YXRlLnBhdGNoLnB1c2goeyBvcDogJ3JlcGxhY2UnLCBwYXRoOiBwYXRoLCB2YWx1ZTogYiB9KTtcblx0fVxuXG5cdHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJucyB7Kn0geCBpZiBwcmVkaWNhdGUoeCkgaXMgdHJ1dGh5LCBvdGhlcndpc2UgeVxuICovXG5mdW5jdGlvbiBvckVsc2UocHJlZGljYXRlLCB4LCB5KSB7XG5cdHJldHVybiBwcmVkaWNhdGUoeCkgPyB4IDogeTtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHBhdGNoIGNvbnRleHQgZ2VuZXJhdG9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSB1bmRlZmluZWQgY29udGV4dFxuICovXG5mdW5jdGlvbiBkZWZhdWx0Q29udGV4dCgpIHtcblx0cmV0dXJuIHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHggaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuXHRyZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yO1xuXG5mdW5jdGlvbiBJbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcihtZXNzYWdlKSB7XG5cdEVycm9yLmNhbGwodGhpcyk7XG5cdHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0aWYodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cdH1cbn1cblxuSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3I7IiwibW9kdWxlLmV4cG9ydHMgPSBQYXRjaE5vdEludmVydGlibGVFcnJvcjtcblxuZnVuY3Rpb24gUGF0Y2hOb3RJbnZlcnRpYmxlRXJyb3IobWVzc2FnZSkge1xuXHRFcnJvci5jYWxsKHRoaXMpO1xuXHR0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdGlmKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXHR9XG59XG5cblBhdGNoTm90SW52ZXJ0aWJsZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblBhdGNoTm90SW52ZXJ0aWJsZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhdGNoTm90SW52ZXJ0aWJsZUVycm9yOyIsIm1vZHVsZS5leHBvcnRzID0gVGVzdEZhaWxlZEVycm9yO1xuXG5mdW5jdGlvbiBUZXN0RmFpbGVkRXJyb3IobWVzc2FnZSkge1xuXHRFcnJvci5jYWxsKHRoaXMpO1xuXHR0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdGlmKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXHR9XG59XG5cblRlc3RGYWlsZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5UZXN0RmFpbGVkRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVzdEZhaWxlZEVycm9yOyIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG5leHBvcnRzLmNvbnMgPSBjb25zO1xuZXhwb3J0cy50YWlsID0gdGFpbDtcbmV4cG9ydHMubWFwID0gbWFwO1xuXG4vKipcbiAqIFByZXBlbmQgeCB0byBhLCB3aXRob3V0IG11dGF0aW5nIGEuIEZhc3RlciB0aGFuIGEudW5zaGlmdCh4KVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0ge0FycmF5fSBhIGFycmF5LWxpa2VcbiAqIEByZXR1cm5zIHtBcnJheX0gbmV3IEFycmF5IHdpdGggeCBwcmVwZW5kZWRcbiAqL1xuZnVuY3Rpb24gY29ucyh4LCBhKSB7XG5cdHZhciBsID0gYS5sZW5ndGg7XG5cdHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG5cdGJbMF0gPSB4O1xuXHRmb3IodmFyIGk9MDsgaTxsOyArK2kpIHtcblx0XHRiW2krMV0gPSBhW2ldO1xuXHR9XG5cblx0cmV0dXJuIGI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFycmF5IGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIGluIGEsIGV4Y2VwdCB0aGUgZmlyc3QuXG4gKiAgRmFzdGVyIHRoYW4gYS5zbGljZSgxKVxuICogQHBhcmFtIHtBcnJheX0gYSBhcnJheS1saWtlXG4gKiBAcmV0dXJucyB7QXJyYXl9IG5ldyBBcnJheSwgdGhlIGVxdWl2YWxlbnQgb2YgYS5zbGljZSgxKVxuICovXG5mdW5jdGlvbiB0YWlsKGEpIHtcblx0dmFyIGwgPSBhLmxlbmd0aC0xO1xuXHR2YXIgYiA9IG5ldyBBcnJheShsKTtcblx0Zm9yKHZhciBpPTA7IGk8bDsgKytpKSB7XG5cdFx0YltpXSA9IGFbaSsxXTtcblx0fVxuXG5cdHJldHVybiBiO1xufVxuXG4vKipcbiAqIE1hcCBhbnkgYXJyYXktbGlrZS4gRmFzdGVyIHRoYW4gQXJyYXkucHJvdG90eXBlLm1hcFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYSBhcnJheS1saWtlXG4gKiBAcmV0dXJucyB7QXJyYXl9IG5ldyBBcnJheSBtYXBwZWQgYnkgZlxuICovXG5mdW5jdGlvbiBtYXAoZiwgYSkge1xuXHR2YXIgYiA9IG5ldyBBcnJheShhLmxlbmd0aCk7XG5cdGZvcih2YXIgaT0wOyBpPCBhLmxlbmd0aDsgKytpKSB7XG5cdFx0YltpXSA9IGYoYVtpXSk7XG5cdH1cblx0cmV0dXJuIGI7XG59IiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHggd2hpY2ggbXVzdCBiZSBhIGxlZ2FsIEpTT04gb2JqZWN0L2FycmF5L3ZhbHVlXG4gKiBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd8bnVtYmVyfG51bGx9IHggb2JqZWN0L2FycmF5L3ZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7b2JqZWN0fGFycmF5fHN0cmluZ3xudW1iZXJ8bnVsbH0gY2xvbmUgb2YgeFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG5mdW5jdGlvbiBjbG9uZSh4KSB7XG5cdGlmKHggPT0gbnVsbCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdGlmKEFycmF5LmlzQXJyYXkoeCkpIHtcblx0XHRyZXR1cm4gY2xvbmVBcnJheSh4KTtcblx0fVxuXG5cdHJldHVybiBjbG9uZU9iamVjdCh4KTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheSAoeCkge1xuXHR2YXIgbCA9IHgubGVuZ3RoO1xuXHR2YXIgeSA9IG5ldyBBcnJheShsKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuXHRcdHlbaV0gPSBjbG9uZSh4W2ldKTtcblx0fVxuXG5cdHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9iamVjdCAoeCkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuXHR2YXIgeSA9IHt9O1xuXG5cdGZvciAodmFyIGssIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRrID0ga2V5c1tpXTtcblx0XHR5W2tdID0gY2xvbmUoeFtrXSk7XG5cdH1cblxuXHRyZXR1cm4geTtcbn1cbiIsInZhciBqc29uUG9pbnRlciA9IHJlcXVpcmUoJy4vanNvblBvaW50ZXInKTtcblxuLyoqXG4gKiBjb21tdXRlIHRoZSBwYXRjaCBzZXF1ZW5jZSBhLGIgdG8gYixhXG4gKiBAcGFyYW0ge29iamVjdH0gYSBwYXRjaCBvcGVyYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBiIHBhdGNoIG9wZXJhdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbW11dGVQYXRocyhhLCBiKSB7XG5cdC8vIFRPRE86IGNhc2VzIGZvciBzcGVjaWFsIHBhdGhzOiAnJyBhbmQgJy8nXG5cdHZhciBsZWZ0ID0ganNvblBvaW50ZXIucGFyc2UoYS5wYXRoKTtcblx0dmFyIHJpZ2h0ID0ganNvblBvaW50ZXIucGFyc2UoYi5wYXRoKTtcblx0dmFyIHByZWZpeCA9IGdldENvbW1vblBhdGhQcmVmaXgobGVmdCwgcmlnaHQpO1xuXHR2YXIgaXNBcnJheSA9IGlzQXJyYXlQYXRoKGxlZnQsIHJpZ2h0LCBwcmVmaXgubGVuZ3RoKTtcblxuXHQvLyBOZXZlciBtdXRhdGUgdGhlIG9yaWdpbmFsc1xuXHR2YXIgYWMgPSBjb3B5UGF0Y2goYSk7XG5cdHZhciBiYyA9IGNvcHlQYXRjaChiKTtcblxuXHRpZihwcmVmaXgubGVuZ3RoID09PSAwICYmICFpc0FycmF5KSB7XG5cdFx0Ly8gUGF0aHMgc2hhcmUgbm8gY29tbW9uIGFuY2VzdG9yLCBzaW1wbGUgc3dhcFxuXHRcdHJldHVybiBbYmMsIGFjXTtcblx0fVxuXG5cdGlmKGlzQXJyYXkpIHtcblx0XHRyZXR1cm4gY29tbXV0ZUFycmF5UGF0aHMoYWMsIGxlZnQsIGJjLCByaWdodCk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGNvbW11dGVUcmVlUGF0aHMoYWMsIGxlZnQsIGJjLCByaWdodCk7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGNvbW11dGVUcmVlUGF0aHMoYSwgbGVmdCwgYiwgcmlnaHQpIHtcblx0aWYoYS5wYXRoID09PSBiLnBhdGgpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgY29tbXV0ZSAnICsgYS5vcCArICcsJyArIGIub3AgKyAnIHdpdGggaWRlbnRpY2FsIG9iamVjdCBwYXRocycpO1xuXHR9XG5cdC8vIEZJWE1FOiBJbXBsZW1lbnQgdHJlZSBwYXRoIGNvbW11dGF0aW9uXG5cdHJldHVybiBbYiwgYV07XG59XG5cbi8qKlxuICogQ29tbXV0ZSB0d28gcGF0Y2hlcyB3aG9zZSBjb21tb24gYW5jZXN0b3IgKHdoaWNoIG1heSBiZSB0aGUgaW1tZWRpYXRlIHBhcmVudClcbiAqIGlzIGFuIGFycmF5XG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGxlZnRcbiAqIEBwYXJhbSBiXG4gKiBAcGFyYW0gcmlnaHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjb21tdXRlQXJyYXlQYXRocyhhLCBsZWZ0LCBiLCByaWdodCkge1xuXHRpZihsZWZ0Lmxlbmd0aCA9PT0gcmlnaHQubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGNvbW11dGVBcnJheVNpYmxpbmdzKGEsIGxlZnQsIGIsIHJpZ2h0KTtcblx0fVxuXG5cdGlmIChsZWZ0Lmxlbmd0aCA+IHJpZ2h0Lmxlbmd0aCkge1xuXHRcdC8vIGxlZnQgaXMgbG9uZ2VyLCBjb21tdXRlIGJ5IFwibW92aW5nXCIgaXQgdG8gdGhlIHJpZ2h0XG5cdFx0bGVmdCA9IGNvbW11dGVBcnJheUFuY2VzdG9yKGIsIHJpZ2h0LCBhLCBsZWZ0LCAtMSk7XG5cdFx0YS5wYXRoID0ganNvblBvaW50ZXIuYWJzb2x1dGUoanNvblBvaW50ZXIuam9pbihsZWZ0KSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gcmlnaHQgaXMgbG9uZ2VyLCBjb21tdXRlIGJ5IFwibW92aW5nXCIgaXQgdG8gdGhlIGxlZnRcblx0XHRyaWdodCA9IGNvbW11dGVBcnJheUFuY2VzdG9yKGEsIGxlZnQsIGIsIHJpZ2h0LCAxKTtcblx0XHRiLnBhdGggPSBqc29uUG9pbnRlci5hYnNvbHV0ZShqc29uUG9pbnRlci5qb2luKHJpZ2h0KSk7XG5cdH1cblxuXHRyZXR1cm4gW2IsIGFdO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5UGF0aChsZWZ0LCByaWdodCwgaW5kZXgpIHtcblx0cmV0dXJuIGpzb25Qb2ludGVyLmlzVmFsaWRBcnJheUluZGV4KGxlZnRbaW5kZXhdKVxuXHRcdCYmIGpzb25Qb2ludGVyLmlzVmFsaWRBcnJheUluZGV4KHJpZ2h0W2luZGV4XSk7XG59XG5cbi8qKlxuICogQ29tbXV0ZSB0d28gcGF0Y2hlcyByZWZlcnJpbmcgdG8gaXRlbXMgaW4gdGhlIHNhbWUgYXJyYXlcbiAqIEBwYXJhbSBsXG4gKiBAcGFyYW0gbHBhdGhcbiAqIEBwYXJhbSByXG4gKiBAcGFyYW0gcnBhdGhcbiAqIEByZXR1cm5zIHsqW119XG4gKi9cbmZ1bmN0aW9uIGNvbW11dGVBcnJheVNpYmxpbmdzKGwsIGxwYXRoLCByLCBycGF0aCkge1xuXG5cdHZhciB0YXJnZXQgPSBscGF0aC5sZW5ndGgtMTtcblx0dmFyIGxpbmRleCA9ICtscGF0aFt0YXJnZXRdO1xuXHR2YXIgcmluZGV4ID0gK3JwYXRoW3RhcmdldF07XG5cblx0dmFyIGNvbW11dGVkO1xuXG5cdGlmKGxpbmRleCA8IHJpbmRleCkge1xuXHRcdC8vIEFkanVzdCByaWdodCBwYXRoXG5cdFx0aWYobC5vcCA9PT0gJ2FkZCcgfHwgbC5vcCA9PT0gJ2NvcHknKSB7XG5cdFx0XHRjb21tdXRlZCA9IHJwYXRoLnNsaWNlKCk7XG5cdFx0XHRjb21tdXRlZFt0YXJnZXRdID0gTWF0aC5tYXgoMCwgcmluZGV4IC0gMSk7XG5cdFx0XHRyLnBhdGggPSBqc29uUG9pbnRlci5hYnNvbHV0ZShqc29uUG9pbnRlci5qb2luKGNvbW11dGVkKSk7XG5cdFx0fSBlbHNlIGlmKGwub3AgPT09ICdyZW1vdmUnKSB7XG5cdFx0XHRjb21tdXRlZCA9IHJwYXRoLnNsaWNlKCk7XG5cdFx0XHRjb21tdXRlZFt0YXJnZXRdID0gcmluZGV4ICsgMTtcblx0XHRcdHIucGF0aCA9IGpzb25Qb2ludGVyLmFic29sdXRlKGpzb25Qb2ludGVyLmpvaW4oY29tbXV0ZWQpKTtcblx0XHR9XG5cdH0gZWxzZSBpZihyLm9wID09PSAnYWRkJyB8fCByLm9wID09PSAnY29weScpIHtcblx0XHQvLyBBZGp1c3QgbGVmdCBwYXRoXG5cdFx0Y29tbXV0ZWQgPSBscGF0aC5zbGljZSgpO1xuXHRcdGNvbW11dGVkW3RhcmdldF0gPSBsaW5kZXggKyAxO1xuXHRcdGwucGF0aCA9IGpzb25Qb2ludGVyLmFic29sdXRlKGpzb25Qb2ludGVyLmpvaW4oY29tbXV0ZWQpKTtcblx0fSBlbHNlIGlmIChsaW5kZXggPiByaW5kZXggJiYgci5vcCA9PT0gJ3JlbW92ZScpIHtcblx0XHQvLyBBZGp1c3QgbGVmdCBwYXRoIG9ubHkgaWYgcmVtb3ZlIHdhcyBhdCBhIChzdHJpY3RseSkgbG93ZXIgaW5kZXhcblx0XHRjb21tdXRlZCA9IGxwYXRoLnNsaWNlKCk7XG5cdFx0Y29tbXV0ZWRbdGFyZ2V0XSA9IE1hdGgubWF4KDAsIGxpbmRleCAtIDEpO1xuXHRcdGwucGF0aCA9IGpzb25Qb2ludGVyLmFic29sdXRlKGpzb25Qb2ludGVyLmpvaW4oY29tbXV0ZWQpKTtcblx0fVxuXG5cdHJldHVybiBbciwgbF07XG59XG5cbi8qKlxuICogQ29tbXV0ZSB0d28gcGF0Y2hlcyB3aXRoIGEgY29tbW9uIGFycmF5IGFuY2VzdG9yXG4gKiBAcGFyYW0gbFxuICogQHBhcmFtIGxwYXRoXG4gKiBAcGFyYW0gclxuICogQHBhcmFtIHJwYXRoXG4gKiBAcGFyYW0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY29tbXV0ZUFycmF5QW5jZXN0b3IobCwgbHBhdGgsIHIsIHJwYXRoLCBkaXJlY3Rpb24pIHtcblx0Ly8gcnBhdGggaXMgbG9uZ2VyIG9yIHNhbWUgbGVuZ3RoXG5cblx0dmFyIHRhcmdldCA9IGxwYXRoLmxlbmd0aC0xO1xuXHR2YXIgbGluZGV4ID0gK2xwYXRoW3RhcmdldF07XG5cdHZhciByaW5kZXggPSArcnBhdGhbdGFyZ2V0XTtcblxuXHQvLyBDb3B5IHJwYXRoLCB0aGVuIGFkanVzdCBpdHMgYXJyYXkgaW5kZXhcblx0dmFyIHJjID0gcnBhdGguc2xpY2UoKTtcblxuXHRpZihsaW5kZXggPiByaW5kZXgpIHtcblx0XHRyZXR1cm4gcmM7XG5cdH1cblxuXHRpZihsLm9wID09PSAnYWRkJyB8fCBsLm9wID09PSAnY29weScpIHtcblx0XHRyY1t0YXJnZXRdID0gTWF0aC5tYXgoMCwgcmluZGV4IC0gZGlyZWN0aW9uKTtcblx0fSBlbHNlIGlmKGwub3AgPT09ICdyZW1vdmUnKSB7XG5cdFx0cmNbdGFyZ2V0XSA9IE1hdGgubWF4KDAsIHJpbmRleCArIGRpcmVjdGlvbik7XG5cdH1cblxuXHRyZXR1cm4gcmM7XG59XG5cbmZ1bmN0aW9uIGdldENvbW1vblBhdGhQcmVmaXgocDEsIHAyKSB7XG5cdHZhciBwMWwgPSBwMS5sZW5ndGg7XG5cdHZhciBwMmwgPSBwMi5sZW5ndGg7XG5cdGlmKHAxbCA9PT0gMCB8fCBwMmwgPT09IDAgfHwgKHAxbCA8IDIgJiYgcDJsIDwgMikpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHQvLyBJZiBwYXRocyBhcmUgc2FtZSBsZW5ndGgsIHRoZSBsYXN0IHNlZ21lbnQgY2Fubm90IGJlIHBhcnRcblx0Ly8gb2YgYSBjb21tb24gcHJlZml4LiAgSWYgbm90IHRoZSBzYW1lIGxlbmd0aCwgdGhlIHByZWZpeCBjYW5ub3Rcblx0Ly8gYmUgbG9uZ2VyIHRoYW4gdGhlIHNob3J0ZXIgcGF0aC5cblx0dmFyIGwgPSBwMWwgPT09IHAybFxuXHRcdD8gcDFsIC0gMVxuXHRcdDogTWF0aC5taW4ocDFsLCBwMmwpO1xuXG5cdHZhciBpID0gMDtcblx0d2hpbGUoaSA8IGwgJiYgcDFbaV0gPT09IHAyW2ldKSB7XG5cdFx0KytpXG5cdH1cblxuXHRyZXR1cm4gcDEuc2xpY2UoMCwgaSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlQYXRjaChwKSB7XG5cdGlmKHAub3AgPT09ICdyZW1vdmUnKSB7XG5cdFx0cmV0dXJuIHsgb3A6IHAub3AsIHBhdGg6IHAucGF0aCB9O1xuXHR9XG5cblx0aWYocC5vcCA9PT0gJ2NvcHknIHx8IHAub3AgPT09ICdtb3ZlJykge1xuXHRcdHJldHVybiB7IG9wOiBwLm9wLCBwYXRoOiBwLnBhdGgsIGZyb206IHAuZnJvbSB9O1xuXHR9XG5cblx0Ly8gdGVzdCwgYWRkLCByZXBsYWNlXG5cdHJldHVybiB7IG9wOiBwLm9wLCBwYXRoOiBwLnBhdGgsIHZhbHVlOiBwLnZhbHVlIH07XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWxzO1xuXG4vKipcbiAqIENvbXBhcmUgMiBKU09OIHZhbHVlcywgb3IgcmVjdXJzaXZlbHkgY29tcGFyZSAyIEpTT04gb2JqZWN0cyBvciBhcnJheXNcbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSBhXG4gKiBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd8bnVtYmVyfGJvb2xlYW58bnVsbH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIGEgYW5kIGIgYXJlIHJlY3Vyc2l2ZWx5IGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYikge1xuXHRpZihhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZihBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcblx0XHRyZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcblx0fVxuXG5cdGlmKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gY29tcGFyZU9iamVjdHMoYSwgYik7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYikge1xuXHRpZihhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IodmFyIGkgPSAwOyBpPGEubGVuZ3RoOyArK2kpIHtcblx0XHRpZighZGVlcEVxdWFscyhhW2ldLCBiW2ldKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlT2JqZWN0cyhhLCBiKSB7XG5cdGlmKChhID09PSBudWxsICYmIGIgIT09IG51bGwpIHx8IChhICE9PSBudWxsICYmIGIgPT09IG51bGwpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGFrZXlzID0gT2JqZWN0LmtleXMoYSk7XG5cdHZhciBia2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG5cdGlmKGFrZXlzLmxlbmd0aCAhPT0gYmtleXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Zm9yKHZhciBpID0gMCwgazsgaTxha2V5cy5sZW5ndGg7ICsraSkge1xuXHRcdGsgPSBha2V5c1tpXTtcblx0XHRpZighKGsgaW4gYiAmJiBkZWVwRXF1YWxzKGFba10sIGJba10pKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufSIsInZhciBwYXRjaGVzID0gcmVxdWlyZSgnLi9wYXRjaGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW52ZXJzZShwKSB7XG5cdHZhciBwciA9IFtdO1xuXHR2YXIgaSwgc2tpcDtcblx0Zm9yKGkgPSBwLmxlbmd0aC0xOyBpPj0gMDsgaSAtPSBza2lwKSB7XG5cdFx0c2tpcCA9IGludmVydE9wKHByLCBwW2ldLCBpLCBwKTtcblx0fVxuXG5cdHJldHVybiBwcjtcbn07XG5cbmZ1bmN0aW9uIGludmVydE9wKHBhdGNoLCBjLCBpLCBjb250ZXh0KSB7XG5cdHZhciBvcCA9IHBhdGNoZXNbYy5vcF07XG5cdHJldHVybiBvcCAhPT0gdm9pZCAwICYmIHR5cGVvZiBvcC5pbnZlcnNlID09PSAnZnVuY3Rpb24nXG5cdFx0PyBvcC5pbnZlcnNlKHBhdGNoLCBjLCBpLCBjb250ZXh0KVxuXHRcdDogMTtcbn1cbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG52YXIgcGF0Y2hlcyA9IHJlcXVpcmUoJy4vcGF0Y2hlcycpO1xudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xudmFyIEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9JbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcicpO1xuXG5leHBvcnRzLmFwcGx5ID0gcGF0Y2g7XG5leHBvcnRzLmFwcGx5SW5QbGFjZSA9IHBhdGNoSW5QbGFjZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuaXNWYWxpZE9iamVjdCA9IGlzVmFsaWRPYmplY3Q7XG5leHBvcnRzLmRlZmF1bHRIYXNoID0gZGVmYXVsdEhhc2g7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzdXBwbGllZCBKU09OIFBhdGNoIHRvIHhcbiAqIEBwYXJhbSB7YXJyYXl9IGNoYW5nZXMgSlNPTiBQYXRjaFxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfG51bWJlcn0geCBvYmplY3QvYXJyYXkvdmFsdWUgdG8gcGF0Y2hcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGluZGV4Ok51bWJlciwgYXJyYXk6QXJyYXksIGNvbnRleHQ6b2JqZWN0KTpOdW1iZXJ9IG9wdGlvbnMuZmluZENvbnRleHRcbiAqICBmdW5jdGlvbiB1c2VkIGFkanVzdCBhcnJheSBpbmRleGVzIGZvciBzbWFydHkvZnV6enkgcGF0Y2hpbmcsIGZvclxuICogIHBhdGNoZXMgY29udGFpbmluZyBjb250ZXh0XG4gKiBAcmV0dXJucyB7b2JqZWN0fGFycmF5fHN0cmluZ3xudW1iZXJ9IHBhdGNoZWQgdmVyc2lvbiBvZiB4LiBJZiB4IGlzXG4gKiAgYW4gYXJyYXkgb3Igb2JqZWN0LCBpdCB3aWxsIGJlIG11dGF0ZWQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGlmXG4gKiAgeCBpcyBhIHZhbHVlLCB0aGUgbmV3IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIHBhdGNoKGNoYW5nZXMsIHgsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHBhdGNoSW5QbGFjZShjaGFuZ2VzLCBjbG9uZSh4KSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoSW5QbGFjZShjaGFuZ2VzLCB4LCBvcHRpb25zKSB7XG5cdGlmKCFvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXHR9XG5cblx0Ly8gVE9ETzogQ29uc2lkZXIgdGhyb3dpbmcgaWYgY2hhbmdlcyBpcyBub3QgYW4gYXJyYXlcblx0aWYoIUFycmF5LmlzQXJyYXkoY2hhbmdlcykpIHtcblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdHZhciBwYXRjaCwgcDtcblx0Zm9yKHZhciBpPTA7IGk8Y2hhbmdlcy5sZW5ndGg7ICsraSkge1xuXHRcdHAgPSBjaGFuZ2VzW2ldO1xuXHRcdHBhdGNoID0gcGF0Y2hlc1twLm9wXTtcblxuXHRcdGlmKHBhdGNoID09PSB2b2lkIDApIHtcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcignaW52YWxpZCBvcCAnICsgSlNPTi5zdHJpbmdpZnkocCkpO1xuXHRcdH1cblxuXHRcdHggPSBwYXRjaC5hcHBseSh4LCBwLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0SGFzaCh4KSB7XG5cdHJldHVybiBpc1ZhbGlkT2JqZWN0KHgpIHx8IGlzQXJyYXkoeCkgPyBKU09OLnN0cmluZ2lmeSh4KSA6IHg7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRPYmplY3QgKHgpIHtcblx0cmV0dXJuIHggIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoeCkge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKCcuL2pzb25Qb2ludGVyUGFyc2UnKTtcblxuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuam9pbiA9IGpvaW47XG5leHBvcnRzLmFic29sdXRlID0gYWJzb2x1dGU7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG5leHBvcnRzLmVuY29kZVNlZ21lbnQgPSBlbmNvZGVTZWdtZW50O1xuZXhwb3J0cy5kZWNvZGVTZWdtZW50ID0gZGVjb2RlU2VnbWVudDtcbmV4cG9ydHMucGFyc2VBcnJheUluZGV4ID0gcGFyc2VBcnJheUluZGV4O1xuZXhwb3J0cy5pc1ZhbGlkQXJyYXlJbmRleCA9IGlzVmFsaWRBcnJheUluZGV4O1xuXG4vLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3BhZ2UtMlxudmFyIHNlcGFyYXRvciA9ICcvJztcbnZhciBzZXBhcmF0b3JSeCA9IC9cXC8vZztcbnZhciBlbmNvZGVkU2VwYXJhdG9yID0gJ34xJztcbnZhciBlbmNvZGVkU2VwYXJhdG9yUnggPSAvfjEvZztcblxudmFyIGVzY2FwZUNoYXIgPSAnfic7XG52YXIgZXNjYXBlUnggPSAvfi9nO1xudmFyIGVuY29kZWRFc2NhcGUgPSAnfjAnO1xudmFyIGVuY29kZWRFc2NhcGVSeCA9IC9+MC9nO1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBvZiB0aGUgc3BlY2lmaWVkIHBhdGggaW4geCBhbmQgcmV0dXJuIGEgZGVzY3JpcHRvclxuICogY29udGFpbmluZyB0aGUgcGFyZW50IGFuZCBhIGtleS4gIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgZXhpc3QgaW4geCxcbiAqIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQuXG4gKiBAcGFyYW0ge29iamVjdHxhcnJheX0geCBvYmplY3Qgb3IgYXJyYXkgaW4gd2hpY2ggdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBKU09OIFBvaW50ZXIgc3RyaW5nIChlbmNvZGVkKVxuICogQHBhcmFtIHs/ZnVuY3Rpb24oaW5kZXg6TnVtYmVyLCBhcnJheTpBcnJheSwgY29udGV4dDpvYmplY3QpOk51bWJlcn0gZmluZENvbnRleHRcbiAqICBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIGFkanVzdCBhcnJheSBpbmRleGVzIGZvciBzbWFydHkvZnV6enkgcGF0Y2hpbmcsIGZvclxuICogIHBhdGNoZXMgY29udGFpbmluZyBjb250ZXh0LiAgSWYgcHJvdmlkZWQsIGNvbnRleHQgTVVTVCBhbHNvIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHs/e2JlZm9yZTpBcnJheSwgYWZ0ZXI6QXJyYXl9fSBjb250ZXh0IG9wdGlvbmFsIHBhdGNoIGNvbnRleHQgZm9yXG4gKiAgZmluZENvbnRleHQgdG8gdXNlIHRvIGFkanVzdCBhcnJheSBpbmRpY2VzLiAgSWYgcHJvdmlkZWQsIGZpbmRDb250ZXh0IE1VU1RcbiAqICBhbHNvIGJlIHByb3ZpZGVkLlxuICogQHJldHVybnMge3t0YXJnZXQ6b2JqZWN0fGFycmF5fG51bWJlcnxzdHJpbmcsIGtleTpzdHJpbmd9fHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZmluZCh4LCBwYXRoLCBmaW5kQ29udGV4dCwgY29udGV4dCkge1xuXHRpZih0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZihwYXRoID09PSAnJykge1xuXHRcdC8vIHdob2xlIGRvY3VtZW50XG5cdFx0cmV0dXJuIHsgdGFyZ2V0OiB4LCBrZXk6IHZvaWQgMCB9O1xuXHR9XG5cblx0aWYocGF0aCA9PT0gc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHsgdGFyZ2V0OiB4LCBrZXk6ICcnIH07XG5cdH1cblxuXHR2YXIgcGFyZW50ID0geCwga2V5O1xuXHR2YXIgaGFzQ29udGV4dCA9IGNvbnRleHQgIT09IHZvaWQgMDtcblxuXHRfcGFyc2UocGF0aCwgZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdC8vIGhtLi4uIHRoaXMgc2VlbXMgbGlrZSBpdCBzaG91bGQgYmUgaWYodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKVxuXHRcdGlmKHggPT0gbnVsbCkge1xuXHRcdFx0Ly8gU2lnbmFsIHRoYXQgd2UgcHJlbWF0dXJlbHkgaGl0IHRoZSBlbmQgb2YgdGhlIHBhdGggaGllcmFyY2h5LlxuXHRcdFx0cGFyZW50ID0gbnVsbDtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZihBcnJheS5pc0FycmF5KHgpKSB7XG5cdFx0XHRrZXkgPSBoYXNDb250ZXh0XG5cdFx0XHRcdD8gZmluZEluZGV4KGZpbmRDb250ZXh0LCBwYXJzZUFycmF5SW5kZXgoc2VnbWVudCksIHgsIGNvbnRleHQpXG5cdFx0XHRcdDogc2VnbWVudCA9PT0gJy0nID8gc2VnbWVudCA6IHBhcnNlQXJyYXlJbmRleChzZWdtZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5ID0gc2VnbWVudDtcblx0XHR9XG5cblx0XHRwYXJlbnQgPSB4O1xuXHRcdHggPSB4W2tleV07XG5cdH0pO1xuXG5cdHJldHVybiBwYXJlbnQgPT09IG51bGxcblx0XHQ/IHZvaWQgMFxuXHRcdDogeyB0YXJnZXQ6IHBhcmVudCwga2V5OiBrZXkgfTtcbn1cblxuZnVuY3Rpb24gYWJzb2x1dGUocGF0aCkge1xuXHRyZXR1cm4gcGF0aFswXSA9PT0gc2VwYXJhdG9yID8gcGF0aCA6IHNlcGFyYXRvciArIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGpvaW4oc2VnbWVudHMpIHtcblx0cmV0dXJuIHNlZ21lbnRzLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuXHR2YXIgc2VnbWVudHMgPSBbXTtcblx0X3BhcnNlKHBhdGgsIHNlZ21lbnRzLnB1c2guYmluZChzZWdtZW50cykpO1xuXHRyZXR1cm4gc2VnbWVudHM7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcblx0cmV0dXJuIGIuaW5kZXhPZihhKSA9PT0gMCAmJiBiW2EubGVuZ3RoXSA9PT0gc2VwYXJhdG9yO1xufVxuXG4vKipcbiAqIERlY29kZSBhIEpTT04gUG9pbnRlciBwYXRoIHNlZ21lbnRcbiAqIEBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMSNwYWdlLTNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIGVuY29kZWQgc2VnbWVudFxuICogQHJldHVybnMge3N0cmluZ30gZGVjb2RlZCBzZWdtZW50XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVNlZ21lbnQocykge1xuXHQvLyBTZWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjcGFnZS0zXG5cdHJldHVybiBzLnJlcGxhY2UoZW5jb2RlZFNlcGFyYXRvclJ4LCBzZXBhcmF0b3IpLnJlcGxhY2UoZW5jb2RlZEVzY2FwZVJ4LCBlc2NhcGVDaGFyKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBKU09OIFBvaW50ZXIgcGF0aCBzZWdtZW50XG4gKiBAc2VlIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjcGFnZS0zXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBkZWNvZGVkIHNlZ21lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVuY29kZWQgc2VnbWVudFxuICovXG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50KHMpIHtcblx0cmV0dXJuIHMucmVwbGFjZShlc2NhcGVSeCwgZW5jb2RlZEVzY2FwZSkucmVwbGFjZShzZXBhcmF0b3JSeCwgZW5jb2RlZFNlcGFyYXRvcik7XG59XG5cbnZhciBhcnJheUluZGV4UnggPSAvXigwfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBzIGlzIGEgdmFsaWQgSlNPTiBQb2ludGVyIGFycmF5IGluZGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4KHMpIHtcblx0cmV0dXJuIGFycmF5SW5kZXhSeC50ZXN0KHMpO1xufVxuXG4vKipcbiAqIFNhZmVseSBwYXJzZSBhIHN0cmluZyBpbnRvIGEgbnVtYmVyID49IDAuIERvZXMgbm90IGNoZWNrIGZvciBkZWNpbWFsIG51bWJlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIG51bWVyaWMgc3RyaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgPj0gMFxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5SW5kZXggKHMpIHtcblx0aWYoaXNWYWxpZEFycmF5SW5kZXgocykpIHtcblx0XHRyZXR1cm4gK3M7XG5cdH1cblxuXHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2ludmFsaWQgYXJyYXkgaW5kZXggJyArIHMpO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXggKGZpbmRDb250ZXh0LCBzdGFydCwgYXJyYXksIGNvbnRleHQpIHtcblx0dmFyIGluZGV4ID0gc3RhcnQ7XG5cblx0aWYoaW5kZXggPCAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdhcnJheSBpbmRleCBvdXQgb2YgYm91bmRzICcgKyBpbmRleCk7XG5cdH1cblxuXHRpZihjb250ZXh0ICE9PSB2b2lkIDAgJiYgdHlwZW9mIGZpbmRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aW5kZXggPSBmaW5kQ29udGV4dChzdGFydCwgYXJyYXksIGNvbnRleHQpO1xuXHRcdGlmKGluZGV4IDwgMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZmluZCBwYXRjaCBjb250ZXh0ICcgKyBjb250ZXh0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaW5kZXg7XG59IiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbm1vZHVsZS5leHBvcnRzID0ganNvblBvaW50ZXJQYXJzZTtcblxudmFyIHBhcnNlUnggPSAvXFwvfH4xfH4wL2c7XG52YXIgc2VwYXJhdG9yID0gJy8nO1xudmFyIGVzY2FwZUNoYXIgPSAnfic7XG52YXIgZW5jb2RlZFNlcGFyYXRvciA9ICd+MSc7XG5cbi8qKlxuICogUGFyc2UgdGhyb3VnaCBhbiBlbmNvZGVkIEpTT04gUG9pbnRlciBzdHJpbmcsIGRlY29kaW5nIGVhY2ggcGF0aCBzZWdtZW50XG4gKiBhbmQgcGFzc2luZyBpdCB0byBhbiBvblNlZ21lbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tNFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZW5jb2RlZCBKU09OIFBvaW50ZXIgc3RyaW5nXG4gKiBAcGFyYW0ge3tmdW5jdGlvbihzZWdtZW50OnN0cmluZyk6Ym9vbGVhbn19IG9uU2VnbWVudCBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3N0cmluZ30gb3JpZ2luYWwgcGF0aFxuICovXG5mdW5jdGlvbiBqc29uUG9pbnRlclBhcnNlKHBhdGgsIG9uU2VnbWVudCkge1xuXHR2YXIgcG9zLCBhY2N1bSwgbWF0Y2hlcywgbWF0Y2g7XG5cblx0cG9zID0gcGF0aC5jaGFyQXQoMCkgPT09IHNlcGFyYXRvciA/IDEgOiAwO1xuXHRhY2N1bSA9ICcnO1xuXHRwYXJzZVJ4Lmxhc3RJbmRleCA9IHBvcztcblxuXHR3aGlsZShtYXRjaGVzID0gcGFyc2VSeC5leGVjKHBhdGgpKSB7XG5cblx0XHRtYXRjaCA9IG1hdGNoZXNbMF07XG5cdFx0YWNjdW0gKz0gcGF0aC5zbGljZShwb3MsIHBhcnNlUngubGFzdEluZGV4IC0gbWF0Y2gubGVuZ3RoKTtcblx0XHRwb3MgPSBwYXJzZVJ4Lmxhc3RJbmRleDtcblxuXHRcdGlmKG1hdGNoID09PSBzZXBhcmF0b3IpIHtcblx0XHRcdGlmIChvblNlZ21lbnQoYWNjdW0pID09PSBmYWxzZSkgcmV0dXJuIHBhdGg7XG5cdFx0XHRhY2N1bSA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhY2N1bSArPSBtYXRjaCA9PT0gZW5jb2RlZFNlcGFyYXRvciA/IHNlcGFyYXRvciA6IGVzY2FwZUNoYXI7XG5cdFx0fVxuXHR9XG5cblx0YWNjdW0gKz0gcGF0aC5zbGljZShwb3MpO1xuXHRvblNlZ21lbnQoYWNjdW0pO1xuXG5cdHJldHVybiBwYXRoO1xufVxuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcblxudmFyIFJFTU9WRSwgUklHSFQsIEFERCwgRE9XTiwgU0tJUDtcblxuZXhwb3J0cy5SRU1PVkUgPSBSRU1PVkUgPSBSSUdIVCA9IC0xO1xuZXhwb3J0cy5BREQgICAgPSBBREQgICAgPSBET1dOICA9ICAxO1xuZXhwb3J0cy5FUVVBTCAgPSBTS0lQICAgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBsY3MgY29tcGFyaXNvbiBtYXRyaXggZGVzY3JpYmluZyB0aGUgZGlmZmVyZW5jZXNcbiAqIGJldHdlZW4gdHdvIGFycmF5LWxpa2Ugc2VxdWVuY2VzXG4gKiBAcGFyYW0ge2FycmF5fSBhIGFycmF5LWxpa2VcbiAqIEBwYXJhbSB7YXJyYXl9IGIgYXJyYXktbGlrZVxuICogQHJldHVybnMge29iamVjdH0gbGNzIGRlc2NyaXB0b3IsIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIHJlZHVjZSgpXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuXHR2YXIgY29scyA9IGEubGVuZ3RoO1xuXHR2YXIgcm93cyA9IGIubGVuZ3RoO1xuXG5cdHZhciBwcmVmaXggPSBmaW5kUHJlZml4KGEsIGIpO1xuXHR2YXIgc3VmZml4ID0gcHJlZml4IDwgY29scyAmJiBwcmVmaXggPCByb3dzXG5cdFx0PyBmaW5kU3VmZml4KGEsIGIsIHByZWZpeClcblx0XHQ6IDA7XG5cblx0dmFyIHJlbW92ZSA9IHN1ZmZpeCArIHByZWZpeCAtIDE7XG5cdGNvbHMgLT0gcmVtb3ZlO1xuXHRyb3dzIC09IHJlbW92ZTtcblx0dmFyIG1hdHJpeCA9IGNyZWF0ZU1hdHJpeChjb2xzLCByb3dzKTtcblxuXHRmb3IgKHZhciBqID0gY29scyAtIDE7IGogPj0gMDsgLS1qKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHJvd3MgLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0bWF0cml4W2ldW2pdID0gYmFja3RyYWNrKG1hdHJpeCwgYSwgYiwgcHJlZml4LCBqLCBpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHByZWZpeDogcHJlZml4LFxuXHRcdG1hdHJpeDogbWF0cml4LFxuXHRcdHN1ZmZpeDogc3VmZml4XG5cdH07XG59XG5cbi8qKlxuICogUmVkdWNlIGEgc2V0IG9mIGxjcyBjaGFuZ2VzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2luZyBjb21wYXJlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc3VsdDoqLCB0eXBlOm51bWJlciwgaTpudW1iZXIsIGo6bnVtYmVyKX0gZlxuICogIHJlZHVjZXIgZnVuY3Rpb24sIHdoZXJlOlxuICogIC0gcmVzdWx0IGlzIHRoZSBjdXJyZW50IHJlZHVjZSB2YWx1ZSxcbiAqICAtIHR5cGUgaXMgdGhlIHR5cGUgb2YgY2hhbmdlOiBBREQsIFJFTU9WRSwgb3IgU0tJUFxuICogIC0gaSBpcyB0aGUgaW5kZXggb2YgdGhlIGNoYW5nZSBsb2NhdGlvbiBpbiBiXG4gKiAgLSBqIGlzIHRoZSBpbmRleCBvZiB0aGUgY2hhbmdlIGxvY2F0aW9uIGluIGFcbiAqIEBwYXJhbSB7Kn0gciBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gbGNzIHJlc3VsdHMgcmV0dXJuZWQgYnkgY29tcGFyZSgpXG4gKiBAcmV0dXJucyB7Kn0gdGhlIGZpbmFsIHJlZHVjZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGYsIHIsIGxjcykge1xuXHR2YXIgaSwgaiwgaywgb3A7XG5cblx0dmFyIG0gPSBsY3MubWF0cml4O1xuXG5cdC8vIFJlZHVjZSBzaGFyZWQgcHJlZml4XG5cdHZhciBsID0gbGNzLnByZWZpeDtcblx0Zm9yKGkgPSAwO2kgPCBsOyArK2kpIHtcblx0XHRyID0gZihyLCBTS0lQLCBpLCBpKTtcblx0fVxuXG5cdC8vIFJlZHVjZSBsb25nZXN0IGNoYW5nZSBzcGFuXG5cdGsgPSBpO1xuXHRsID0gbS5sZW5ndGg7XG5cdGkgPSAwO1xuXHRqID0gMDtcblx0d2hpbGUoaSA8IGwpIHtcblx0XHRvcCA9IG1baV1bal0udHlwZTtcblx0XHRyID0gZihyLCBvcCwgaStrLCBqK2spO1xuXG5cdFx0c3dpdGNoKG9wKSB7XG5cdFx0XHRjYXNlIFNLSVA6ICArK2k7ICsrajsgYnJlYWs7XG5cdFx0XHRjYXNlIFJJR0hUOiArK2o7IGJyZWFrO1xuXHRcdFx0Y2FzZSBET1dOOiAgKytpOyBicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZWR1Y2Ugc2hhcmVkIHN1ZmZpeFxuXHRpICs9IGs7XG5cdGogKz0gaztcblx0bCA9IGxjcy5zdWZmaXg7XG5cdGZvcihrID0gMDtrIDwgbDsgKytrKSB7XG5cdFx0ciA9IGYociwgU0tJUCwgaStrLCBqK2spO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmVmaXgoYSwgYikge1xuXHR2YXIgaSA9IDA7XG5cdHZhciBsID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblx0d2hpbGUoaSA8IGwgJiYgYVtpXSA9PT0gYltpXSkge1xuXHRcdCsraTtcblx0fVxuXHRyZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZmluZFN1ZmZpeChhLCBiKSB7XG5cdHZhciBhbCA9IGEubGVuZ3RoIC0gMTtcblx0dmFyIGJsID0gYi5sZW5ndGggLSAxO1xuXHR2YXIgbCA9IE1hdGgubWluKGFsLCBibCk7XG5cdHZhciBpID0gMDtcblx0d2hpbGUoaSA8IGwgJiYgYVthbC1pXSA9PT0gYltibC1pXSkge1xuXHRcdCsraTtcblx0fVxuXHRyZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gYmFja3RyYWNrKG1hdHJpeCwgYSwgYiwgc3RhcnQsIGosIGkpIHtcblx0aWYgKGFbaitzdGFydF0gPT09IGJbaStzdGFydF0pIHtcblx0XHRyZXR1cm4geyB2YWx1ZTogbWF0cml4W2kgKyAxXVtqICsgMV0udmFsdWUsIHR5cGU6IFNLSVAgfTtcblx0fVxuXHRpZiAobWF0cml4W2ldW2ogKyAxXS52YWx1ZSA8IG1hdHJpeFtpICsgMV1bal0udmFsdWUpIHtcblx0XHRyZXR1cm4geyB2YWx1ZTogbWF0cml4W2ldW2ogKyAxXS52YWx1ZSArIDEsIHR5cGU6IFJJR0hUIH07XG5cdH1cblxuXHRyZXR1cm4geyB2YWx1ZTogbWF0cml4W2kgKyAxXVtqXS52YWx1ZSArIDEsIHR5cGU6IERPV04gfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWF0cml4IChjb2xzLCByb3dzKSB7XG5cdHZhciBtID0gW10sIGksIGosIGxhc3Ryb3c7XG5cblx0Ly8gRmlsbCB0aGUgbGFzdCByb3dcblx0bGFzdHJvdyA9IG1bcm93c10gPSBbXTtcblx0Zm9yIChqID0gMDsgajxjb2xzOyArK2opIHtcblx0XHRsYXN0cm93W2pdID0geyB2YWx1ZTogY29scyAtIGosIHR5cGU6IFJJR0hUIH07XG5cdH1cblxuXHQvLyBGaWxsIHRoZSBsYXN0IGNvbFxuXHRmb3IgKGkgPSAwOyBpPHJvd3M7ICsraSkge1xuXHRcdG1baV0gPSBbXTtcblx0XHRtW2ldW2NvbHNdID0geyB2YWx1ZTogcm93cyAtIGksIHR5cGU6IERPV04gfTtcblx0fVxuXG5cdC8vIEZpbGwgdGhlIGxhc3QgY2VsbFxuXHRtW3Jvd3NdW2NvbHNdID0geyB2YWx1ZTogMCwgdHlwZTogU0tJUCB9O1xuXG5cdHJldHVybiBtO1xufVxuIiwidmFyIGpzb25Qb2ludGVyID0gcmVxdWlyZSgnLi9qc29uUG9pbnRlcicpO1xudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xudmFyIGRlZXBFcXVhbHMgPSByZXF1aXJlKCcuL2RlZXBFcXVhbHMnKTtcbnZhciBjb21tdXRlUGF0aHMgPSByZXF1aXJlKCcuL2NvbW11dGVQYXRocycpO1xuXG52YXIgYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbnZhciBUZXN0RmFpbGVkRXJyb3IgPSByZXF1aXJlKCcuL1Rlc3RGYWlsZWRFcnJvcicpO1xudmFyIEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9JbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcicpO1xudmFyIFBhdGNoTm90SW52ZXJ0aWJsZUVycm9yID0gcmVxdWlyZSgnLi9QYXRjaE5vdEludmVydGlibGVFcnJvcicpO1xuXG52YXIgZmluZCA9IGpzb25Qb2ludGVyLmZpbmQ7XG52YXIgcGFyc2VBcnJheUluZGV4ID0ganNvblBvaW50ZXIucGFyc2VBcnJheUluZGV4O1xuXG5leHBvcnRzLnRlc3QgPSB7XG5cdGFwcGx5OiBhcHBseVRlc3QsXG5cdGludmVyc2U6IGludmVydFRlc3QsXG5cdGNvbW11dGU6IGNvbW11dGVUZXN0XG59O1xuXG5leHBvcnRzLmFkZCA9IHtcblx0YXBwbHk6IGFwcGx5QWRkLFxuXHRpbnZlcnNlOiBpbnZlcnRBZGQsXG5cdGNvbW11dGU6IGNvbW11dGVBZGRPckNvcHlcbn07XG5cbmV4cG9ydHMucmVtb3ZlID0ge1xuXHRhcHBseTogYXBwbHlSZW1vdmUsXG5cdGludmVyc2U6IGludmVydFJlbW92ZSxcblx0Y29tbXV0ZTogY29tbXV0ZVJlbW92ZVxufTtcblxuZXhwb3J0cy5yZXBsYWNlID0ge1xuXHRhcHBseTogYXBwbHlSZXBsYWNlLFxuXHRpbnZlcnNlOiBpbnZlcnRSZXBsYWNlLFxuXHRjb21tdXRlOiBjb21tdXRlUmVwbGFjZVxufTtcblxuZXhwb3J0cy5tb3ZlID0ge1xuXHRhcHBseTogYXBwbHlNb3ZlLFxuXHRpbnZlcnNlOiBpbnZlcnRNb3ZlLFxuXHRjb21tdXRlOiBjb21tdXRlTW92ZVxufTtcblxuZXhwb3J0cy5jb3B5ID0ge1xuXHRhcHBseTogYXBwbHlDb3B5LFxuXHRpbnZlcnNlOiBub3RJbnZlcnRpYmxlLFxuXHRjb21tdXRlOiBjb21tdXRlQWRkT3JDb3B5XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgdGVzdCBvcGVyYXRpb24gdG8geFxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IHhcbiAqIEBwYXJhbSB7b2JqZWN0fSB0ZXN0IHRlc3Qgb3BlcmF0aW9uXG4gKiBAdGhyb3dzIHtUZXN0RmFpbGVkRXJyb3J9IGlmIHRoZSB0ZXN0IG9wZXJhdGlvbiBmYWlsc1xuICovXG5cbmZ1bmN0aW9uIGFwcGx5VGVzdCh4LCB0ZXN0LCBvcHRpb25zKSB7XG5cdHZhciBwb2ludGVyID0gZmluZCh4LCB0ZXN0LnBhdGgsIG9wdGlvbnMuZmluZENvbnRleHQsIHRlc3QuY29udGV4dCk7XG5cdHZhciB0YXJnZXQgPSBwb2ludGVyLnRhcmdldDtcblx0dmFyIGluZGV4LCB2YWx1ZTtcblxuXHRpZihBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcblx0XHRpbmRleCA9IHBhcnNlQXJyYXlJbmRleChwb2ludGVyLmtleSk7XG5cdFx0Ly9pbmRleCA9IGZpbmRJbmRleChvcHRpb25zLmZpbmRDb250ZXh0LCBpbmRleCwgdGFyZ2V0LCB0ZXN0LmNvbnRleHQpO1xuXHRcdHZhbHVlID0gdGFyZ2V0W2luZGV4XTtcblx0fSBlbHNlIHtcblx0XHR2YWx1ZSA9IHBvaW50ZXIua2V5ID09PSB2b2lkIDAgPyBwb2ludGVyLnRhcmdldCA6IHBvaW50ZXIudGFyZ2V0W3BvaW50ZXIua2V5XTtcblx0fVxuXG5cdGlmKCFkZWVwRXF1YWxzKHZhbHVlLCB0ZXN0LnZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBUZXN0RmFpbGVkRXJyb3IoJ3Rlc3QgZmFpbGVkICcgKyBKU09OLnN0cmluZ2lmeSh0ZXN0KSk7XG5cdH1cblxuXHRyZXR1cm4geDtcbn1cblxuLyoqXG4gKiBJbnZlcnQgdGhlIHByb3ZpZGVkIHRlc3QgYW5kIGFkZCBpdCB0byB0aGUgaW52ZXJ0ZWQgcGF0Y2ggc2VxdWVuY2VcbiAqIEBwYXJhbSBwclxuICogQHBhcmFtIHRlc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGludmVydFRlc3QocHIsIHRlc3QpIHtcblx0cHIucHVzaCh0ZXN0KTtcblx0cmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGNvbW11dGVUZXN0KHRlc3QsIGIpIHtcblx0aWYodGVzdC5wYXRoID09PSBiLnBhdGggJiYgYi5vcCA9PT0gJ3JlbW92ZScpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IGNvbW11dGUgdGVzdCxyZW1vdmUgLT4gcmVtb3ZlLHRlc3QgZm9yIHNhbWUgcGF0aCcpO1xuXHR9XG5cblx0aWYoYi5vcCA9PT0gJ3Rlc3QnIHx8IGIub3AgPT09ICdyZXBsYWNlJykge1xuXHRcdHJldHVybiBbYiwgdGVzdF07XG5cdH1cblxuXHRyZXR1cm4gY29tbXV0ZVBhdGhzKHRlc3QsIGIpO1xufVxuXG4vKipcbiAqIEFwcGx5IGFuIGFkZCBvcGVyYXRpb24gdG8geFxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IHhcbiAqIEBwYXJhbSB7b2JqZWN0fSBjaGFuZ2UgYWRkIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseUFkZCh4LCBjaGFuZ2UsIG9wdGlvbnMpIHtcblx0dmFyIHBvaW50ZXIgPSBmaW5kKHgsIGNoYW5nZS5wYXRoLCBvcHRpb25zLmZpbmRDb250ZXh0LCBjaGFuZ2UuY29udGV4dCk7XG5cblx0aWYobm90Rm91bmQocG9pbnRlcikpIHtcblx0XHR0aHJvdyBuZXcgSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IoJ3BhdGggZG9lcyBub3QgZXhpc3QgJyArIGNoYW5nZS5wYXRoKTtcblx0fVxuXG5cdGlmKGNoYW5nZS52YWx1ZSA9PT0gdm9pZCAwKSB7XG5cdFx0dGhyb3cgbmV3IEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yKCdtaXNzaW5nIHZhbHVlJyk7XG5cdH1cblxuXHR2YXIgdmFsID0gY2xvbmUoY2hhbmdlLnZhbHVlKTtcblxuXHQvLyBJZiBwb2ludGVyIHJlZmVycyB0byB3aG9sZSBkb2N1bWVudCwgcmVwbGFjZSB3aG9sZSBkb2N1bWVudFxuXHRpZihwb2ludGVyLmtleSA9PT0gdm9pZCAwKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdF9hZGQocG9pbnRlciwgdmFsKTtcblx0cmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIF9hZGQocG9pbnRlciwgdmFsdWUpIHtcblx0dmFyIHRhcmdldCA9IHBvaW50ZXIudGFyZ2V0O1xuXG5cdGlmKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuXHRcdC8vICctJyBpbmRpY2F0ZXMgJ2FwcGVuZCcgdG8gYXJyYXlcblx0XHRpZihwb2ludGVyLmtleSA9PT0gJy0nKSB7XG5cdFx0XHR0YXJnZXQucHVzaCh2YWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChwb2ludGVyLmtleSA+IHRhcmdldC5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcigndGFyZ2V0IG9mIGFkZCBvdXRzaWRlIG9mIGFycmF5IGJvdW5kcycpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5zcGxpY2UocG9pbnRlci5rZXksIDAsIHZhbHVlKTtcblx0XHR9XG5cdH0gZWxzZSBpZihpc1ZhbGlkT2JqZWN0KHRhcmdldCkpIHtcblx0XHR0YXJnZXRbcG9pbnRlci5rZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yKCd0YXJnZXQgb2YgYWRkIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5ICcgKyBwb2ludGVyLmtleSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW52ZXJ0QWRkKHByLCBhZGQpIHtcblx0dmFyIGNvbnRleHQgPSBhZGQuY29udGV4dDtcblx0aWYoY29udGV4dCAhPT0gdm9pZCAwKSB7XG5cdFx0Y29udGV4dCA9IHtcblx0XHRcdGJlZm9yZTogY29udGV4dC5iZWZvcmUsXG5cdFx0XHRhZnRlcjogYXJyYXkuY29ucyhhZGQudmFsdWUsIGNvbnRleHQuYWZ0ZXIpXG5cdFx0fVxuXHR9XG5cdHByLnB1c2goeyBvcDogJ3Rlc3QnLCBwYXRoOiBhZGQucGF0aCwgdmFsdWU6IGFkZC52YWx1ZSwgY29udGV4dDogY29udGV4dCB9KTtcblx0cHIucHVzaCh7IG9wOiAncmVtb3ZlJywgcGF0aDogYWRkLnBhdGgsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG5cdHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBjb21tdXRlQWRkT3JDb3B5KGFkZCwgYikge1xuXHRpZihhZGQucGF0aCA9PT0gYi5wYXRoICYmIGIub3AgPT09ICdyZW1vdmUnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBjb21tdXRlIGFkZCxyZW1vdmUgLT4gcmVtb3ZlLGFkZCBmb3Igc2FtZSBwYXRoJyk7XG5cdH1cblxuXHRyZXR1cm4gY29tbXV0ZVBhdGhzKGFkZCwgYik7XG59XG5cbi8qKlxuICogQXBwbHkgYSByZXBsYWNlIG9wZXJhdGlvbiB0byB4XG4gKiBAcGFyYW0ge29iamVjdHxhcnJheX0geFxuICogQHBhcmFtIHtvYmplY3R9IGNoYW5nZSByZXBsYWNlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseVJlcGxhY2UoeCwgY2hhbmdlLCBvcHRpb25zKSB7XG5cdHZhciBwb2ludGVyID0gZmluZCh4LCBjaGFuZ2UucGF0aCwgb3B0aW9ucy5maW5kQ29udGV4dCwgY2hhbmdlLmNvbnRleHQpO1xuXG5cdGlmKG5vdEZvdW5kKHBvaW50ZXIpIHx8IG1pc3NpbmdWYWx1ZShwb2ludGVyKSkge1xuXHRcdHRocm93IG5ldyBJbnZhbGlkUGF0Y2hPcGVyYXRpb25FcnJvcigncGF0aCBkb2VzIG5vdCBleGlzdCAnICsgY2hhbmdlLnBhdGgpO1xuXHR9XG5cblx0aWYoY2hhbmdlLnZhbHVlID09PSB2b2lkIDApIHtcblx0XHR0aHJvdyBuZXcgSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IoJ21pc3NpbmcgdmFsdWUnKTtcblx0fVxuXG5cdHZhciB2YWx1ZSA9IGNsb25lKGNoYW5nZS52YWx1ZSk7XG5cblx0Ly8gSWYgcG9pbnRlciByZWZlcnMgdG8gd2hvbGUgZG9jdW1lbnQsIHJlcGxhY2Ugd2hvbGUgZG9jdW1lbnRcblx0aWYocG9pbnRlci5rZXkgPT09IHZvaWQgMCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdHZhciB0YXJnZXQgPSBwb2ludGVyLnRhcmdldDtcblxuXHRpZihBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcblx0XHR0YXJnZXRbcGFyc2VBcnJheUluZGV4KHBvaW50ZXIua2V5KV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHR0YXJnZXRbcG9pbnRlci5rZXldID0gdmFsdWU7XG5cdH1cblxuXHRyZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gaW52ZXJ0UmVwbGFjZShwciwgYywgaSwgcGF0Y2gpIHtcblx0dmFyIHByZXYgPSBwYXRjaFtpLTFdO1xuXHRpZihwcmV2ID09PSB2b2lkIDAgfHwgcHJldi5vcCAhPT0gJ3Rlc3QnIHx8IHByZXYucGF0aCAhPT0gYy5wYXRoKSB7XG5cdFx0dGhyb3cgbmV3IFBhdGNoTm90SW52ZXJ0aWJsZUVycm9yKCdjYW5ub3QgaW52ZXJ0IHJlcGxhY2Ugdy9vIHRlc3QnKTtcblx0fVxuXG5cdHZhciBjb250ZXh0ID0gcHJldi5jb250ZXh0O1xuXHRpZihjb250ZXh0ICE9PSB2b2lkIDApIHtcblx0XHRjb250ZXh0ID0ge1xuXHRcdFx0YmVmb3JlOiBjb250ZXh0LmJlZm9yZSxcblx0XHRcdGFmdGVyOiBhcnJheS5jb25zKHByZXYudmFsdWUsIGFycmF5LnRhaWwoY29udGV4dC5hZnRlcikpXG5cdFx0fVxuXHR9XG5cblx0cHIucHVzaCh7IG9wOiAndGVzdCcsIHBhdGg6IHByZXYucGF0aCwgdmFsdWU6IGMudmFsdWUgfSk7XG5cdHByLnB1c2goeyBvcDogJ3JlcGxhY2UnLCBwYXRoOiBwcmV2LnBhdGgsIHZhbHVlOiBwcmV2LnZhbHVlIH0pO1xuXHRyZXR1cm4gMjtcbn1cblxuZnVuY3Rpb24gY29tbXV0ZVJlcGxhY2UocmVwbGFjZSwgYikge1xuXHRpZihyZXBsYWNlLnBhdGggPT09IGIucGF0aCAmJiBiLm9wID09PSAncmVtb3ZlJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgY29tbXV0ZSByZXBsYWNlLHJlbW92ZSAtPiByZW1vdmUscmVwbGFjZSBmb3Igc2FtZSBwYXRoJyk7XG5cdH1cblxuXHRpZihiLm9wID09PSAndGVzdCcgfHwgYi5vcCA9PT0gJ3JlcGxhY2UnKSB7XG5cdFx0cmV0dXJuIFtiLCByZXBsYWNlXTtcblx0fVxuXG5cdHJldHVybiBjb21tdXRlUGF0aHMocmVwbGFjZSwgYik7XG59XG5cbi8qKlxuICogQXBwbHkgYSByZW1vdmUgb3BlcmF0aW9uIHRvIHhcbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fSB4XG4gKiBAcGFyYW0ge29iamVjdH0gY2hhbmdlIHJlbW92ZSBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZW1vdmUoeCwgY2hhbmdlLCBvcHRpb25zKSB7XG5cdHZhciBwb2ludGVyID0gZmluZCh4LCBjaGFuZ2UucGF0aCwgb3B0aW9ucy5maW5kQ29udGV4dCwgY2hhbmdlLmNvbnRleHQpO1xuXG5cdC8vIGtleSBtdXN0IGV4aXN0IGZvciByZW1vdmVcblx0aWYobm90Rm91bmQocG9pbnRlcikgfHwgcG9pbnRlci50YXJnZXRbcG9pbnRlci5rZXldID09PSB2b2lkIDApIHtcblx0XHR0aHJvdyBuZXcgSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IoJ3BhdGggZG9lcyBub3QgZXhpc3QgJyArIGNoYW5nZS5wYXRoKTtcblx0fVxuXG5cdF9yZW1vdmUocG9pbnRlcik7XG5cdHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBfcmVtb3ZlIChwb2ludGVyKSB7XG5cdHZhciB0YXJnZXQgPSBwb2ludGVyLnRhcmdldDtcblxuXHR2YXIgcmVtb3ZlZDtcblx0aWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuXHRcdHJlbW92ZWQgPSB0YXJnZXQuc3BsaWNlKHBhcnNlQXJyYXlJbmRleChwb2ludGVyLmtleSksIDEpO1xuXHRcdHJldHVybiByZW1vdmVkWzBdO1xuXG5cdH0gZWxzZSBpZiAoaXNWYWxpZE9iamVjdCh0YXJnZXQpKSB7XG5cdFx0cmVtb3ZlZCA9IHRhcmdldFtwb2ludGVyLmtleV07XG5cdFx0ZGVsZXRlIHRhcmdldFtwb2ludGVyLmtleV07XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IoJ3RhcmdldCBvZiByZW1vdmUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYXJyYXknKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbnZlcnRSZW1vdmUocHIsIGMsIGksIHBhdGNoKSB7XG5cdHZhciBwcmV2ID0gcGF0Y2hbaS0xXTtcblx0aWYocHJldiA9PT0gdm9pZCAwIHx8IHByZXYub3AgIT09ICd0ZXN0JyB8fCBwcmV2LnBhdGggIT09IGMucGF0aCkge1xuXHRcdHRocm93IG5ldyBQYXRjaE5vdEludmVydGlibGVFcnJvcignY2Fubm90IGludmVydCByZW1vdmUgdy9vIHRlc3QnKTtcblx0fVxuXG5cdHZhciBjb250ZXh0ID0gcHJldi5jb250ZXh0O1xuXHRpZihjb250ZXh0ICE9PSB2b2lkIDApIHtcblx0XHRjb250ZXh0ID0ge1xuXHRcdFx0YmVmb3JlOiBjb250ZXh0LmJlZm9yZSxcblx0XHRcdGFmdGVyOiBhcnJheS50YWlsKGNvbnRleHQuYWZ0ZXIpXG5cdFx0fVxuXHR9XG5cblx0cHIucHVzaCh7IG9wOiAnYWRkJywgcGF0aDogcHJldi5wYXRoLCB2YWx1ZTogcHJldi52YWx1ZSwgY29udGV4dDogY29udGV4dCB9KTtcblx0cmV0dXJuIDI7XG59XG5cbmZ1bmN0aW9uIGNvbW11dGVSZW1vdmUocmVtb3ZlLCBiKSB7XG5cdGlmKHJlbW92ZS5wYXRoID09PSBiLnBhdGggJiYgYi5vcCA9PT0gJ3JlbW92ZScpIHtcblx0XHRyZXR1cm4gW2IsIHJlbW92ZV07XG5cdH1cblxuXHRyZXR1cm4gY29tbXV0ZVBhdGhzKHJlbW92ZSwgYik7XG59XG5cbi8qKlxuICogQXBwbHkgYSBtb3ZlIG9wZXJhdGlvbiB0byB4XG4gKiBAcGFyYW0ge29iamVjdHxhcnJheX0geFxuICogQHBhcmFtIHtvYmplY3R9IGNoYW5nZSBtb3ZlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseU1vdmUoeCwgY2hhbmdlLCBvcHRpb25zKSB7XG5cdGlmKGpzb25Qb2ludGVyLmNvbnRhaW5zKGNoYW5nZS5wYXRoLCBjaGFuZ2UuZnJvbSkpIHtcblx0XHR0aHJvdyBuZXcgSW52YWxpZFBhdGNoT3BlcmF0aW9uRXJyb3IoJ21vdmUuZnJvbSBjYW5ub3QgYmUgYW5jZXN0b3Igb2YgbW92ZS5wYXRoJyk7XG5cdH1cblxuXHR2YXIgcHRvID0gZmluZCh4LCBjaGFuZ2UucGF0aCwgb3B0aW9ucy5maW5kQ29udGV4dCwgY2hhbmdlLmNvbnRleHQpO1xuXHR2YXIgcGZyb20gPSBmaW5kKHgsIGNoYW5nZS5mcm9tLCBvcHRpb25zLmZpbmRDb250ZXh0LCBjaGFuZ2UuZnJvbUNvbnRleHQpO1xuXG5cdF9hZGQocHRvLCBfcmVtb3ZlKHBmcm9tKSk7XG5cdHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBpbnZlcnRNb3ZlKHByLCBjKSB7XG5cdHByLnB1c2goeyBvcDogJ21vdmUnLFxuXHRcdHBhdGg6IGMuZnJvbSwgY29udGV4dDogYy5mcm9tQ29udGV4dCxcblx0XHRmcm9tOiBjLnBhdGgsIGZyb21Db250ZXh0OiBjLmNvbnRleHQgfSk7XG5cdHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBjb21tdXRlTW92ZShtb3ZlLCBiKSB7XG5cdGlmKG1vdmUucGF0aCA9PT0gYi5wYXRoICYmIGIub3AgPT09ICdyZW1vdmUnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBjb21tdXRlIG1vdmUscmVtb3ZlIC0+IG1vdmUscmVwbGFjZSBmb3Igc2FtZSBwYXRoJyk7XG5cdH1cblxuXHRyZXR1cm4gY29tbXV0ZVBhdGhzKG1vdmUsIGIpO1xufVxuXG4vKipcbiAqIEFwcGx5IGEgY29weSBvcGVyYXRpb24gdG8geFxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IHhcbiAqIEBwYXJhbSB7b2JqZWN0fSBjaGFuZ2UgY29weSBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gYXBwbHlDb3B5KHgsIGNoYW5nZSwgb3B0aW9ucykge1xuXHR2YXIgcHRvID0gZmluZCh4LCBjaGFuZ2UucGF0aCwgb3B0aW9ucy5maW5kQ29udGV4dCwgY2hhbmdlLmNvbnRleHQpO1xuXHR2YXIgcGZyb20gPSBmaW5kKHgsIGNoYW5nZS5mcm9tLCBvcHRpb25zLmZpbmRDb250ZXh0LCBjaGFuZ2UuZnJvbUNvbnRleHQpO1xuXG5cdGlmKG5vdEZvdW5kKHBmcm9tKSB8fCBtaXNzaW5nVmFsdWUocGZyb20pKSB7XG5cdFx0dGhyb3cgbmV3IEludmFsaWRQYXRjaE9wZXJhdGlvbkVycm9yKCdjb3B5LmZyb20gbXVzdCBleGlzdCcpO1xuXHR9XG5cblx0dmFyIHRhcmdldCA9IHBmcm9tLnRhcmdldDtcblx0dmFyIHZhbHVlO1xuXG5cdGlmKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuXHRcdHZhbHVlID0gdGFyZ2V0W3BhcnNlQXJyYXlJbmRleChwZnJvbS5rZXkpXTtcblx0fSBlbHNlIHtcblx0XHR2YWx1ZSA9IHRhcmdldFtwZnJvbS5rZXldO1xuXHR9XG5cblx0X2FkZChwdG8sIGNsb25lKHZhbHVlKSk7XG5cdHJldHVybiB4O1xufVxuXG4vLyBOT1RFOiBDb3B5IGlzIG5vdCBpbnZlcnRpYmxlXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy9qaWZmL2lzc3Vlcy85XG4vLyBUaGlzIG5lZWRzIG1vcmUgdGhvdWdodC4gV2UgbWF5IGhhdmUgdG8gZXh0ZW5kL2FtZW5kIEpTT04gUGF0Y2guXG4vLyBBdCBmaXJzdCBnbGFuY2UsIHRoaXMgc2VlbXMgbGlrZSBpdCBzaG91bGQganVzdCBiZSBhIHJlbW92ZS5cbi8vIEhvd2V2ZXIsIHRoYXQncyBub3QgY29ycmVjdC4gIEl0IHZpb2xhdGVzIHRoZSBpbnZvbHV0aW9uOlxuLy8gaW52ZXJ0KGludmVydChwKSkgfj0gcC4gIEZvciBleGFtcGxlOlxuLy8gaW52ZXJ0KGNvcHkpIC0+IHJlbW92ZVxuLy8gaW52ZXJ0KHJlbW92ZSkgLT4gYWRkXG4vLyB0aHVzOiBpbnZlcnQoaW52ZXJ0KGNvcHkpKSAtPiBhZGQgKERPSCEgdGhpcyBzaG91bGQgYmUgY29weSEpXG5cbmZ1bmN0aW9uIG5vdEludmVydGlibGUoXywgYykge1xuXHR0aHJvdyBuZXcgUGF0Y2hOb3RJbnZlcnRpYmxlRXJyb3IoJ2Nhbm5vdCBpbnZlcnQgJyArIGMub3ApO1xufVxuXG5mdW5jdGlvbiBub3RGb3VuZCAocG9pbnRlcikge1xuXHRyZXR1cm4gcG9pbnRlciA9PT0gdm9pZCAwIHx8IChwb2ludGVyLnRhcmdldCA9PSBudWxsICYmIHBvaW50ZXIua2V5ICE9PSB2b2lkIDApO1xufVxuXG5mdW5jdGlvbiBtaXNzaW5nVmFsdWUocG9pbnRlcikge1xuXHRyZXR1cm4gcG9pbnRlci5rZXkgIT09IHZvaWQgMCAmJiBwb2ludGVyLnRhcmdldFtwb2ludGVyLmtleV0gPT09IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB4IGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkT2JqZWN0ICh4KSB7XG5cdHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbiIsIi8qXG4gKiAkSWQ6IGJhc2U2NC5qcyx2IDIuMTUgMjAxNC8wNC8wNSAxMjo1ODo1NyBkYW5rb2dhaSBFeHAgZGFua29nYWkgJFxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogIFJlZmVyZW5jZXM6XG4gKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gZXhpc3RpbmcgdmVyc2lvbiBmb3Igbm9Db25mbGljdCgpXG4gICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIHZhciB2ZXJzaW9uID0gXCIyLjMuMlwiO1xuICAgIC8vIGlmIG5vZGUuanMsIHdlIHVzZSBCdWZmZXJcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfVxuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBiNjRjaGFyc1xuICAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICB2YXIgYjY0dGFiID0gZnVuY3Rpb24oYmluKSB7XG4gICAgICAgIHZhciB0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYmluLmxlbmd0aDsgaSA8IGw7IGkrKykgdFtiaW4uY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0oYjY0Y2hhcnMpO1xuICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIC8vIGVuY29kZXIgc3R1ZmZcbiAgICB2YXIgY2JfdXRvYiA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgIDogKGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAxMikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbiAgICB2YXIgdXRvYiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbiAgICB9O1xuICAgIHZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbihjY2MpIHtcbiAgICAgICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM10sXG4gICAgICAgIG9yZCA9IGNjYy5jaGFyQ29kZUF0KDApIDw8IDE2XG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDEgPyBjY2MuY2hhckNvZGVBdCgxKSA6IDApIDw8IDgpXG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDIgPyBjY2MuY2hhckNvZGVBdCgyKSA6IDApKSxcbiAgICAgICAgY2hhcnMgPSBbXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoIG9yZCA+Pj4gMTgpLFxuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDEyKSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDEgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQob3JkICYgNjMpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBidG9hID0gZ2xvYmFsLmJ0b2EgPyBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYnRvYShiKTtcbiAgICB9IDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcbiAgICB2YXIgX2VuY29kZSA9IGJ1ZmZlciA/XG4gICAgICAgIGJ1ZmZlci5mcm9tICYmIGJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gPyBmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgcmV0dXJuICh1LmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3IgPyB1IDogYnVmZmVyLmZyb20odSkpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICB9XG4gICAgICAgIDogIGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICByZXR1cm4gKHUuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvciA/IHUgOiBuZXcgIGJ1ZmZlcih1KSlcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodSkgeyByZXR1cm4gYnRvYSh1dG9iKHUpKSB9XG4gICAgO1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbih1LCB1cmlzYWZlKSB7XG4gICAgICAgIHJldHVybiAhdXJpc2FmZVxuICAgICAgICAgICAgPyBfZW5jb2RlKFN0cmluZyh1KSlcbiAgICAgICAgICAgIDogX2VuY29kZShTdHJpbmcodSkpLnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMCA9PSAnKycgPyAnLScgOiAnXyc7XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC89L2csICcnKTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbih1KSB7IHJldHVybiBlbmNvZGUodSwgdHJ1ZSkgfTtcbiAgICAvLyBkZWNvZGVyIHN0dWZmXG4gICAgdmFyIHJlX2J0b3UgPSBuZXcgUmVnRXhwKFtcbiAgICAgICAgJ1tcXHhDMC1cXHhERl1bXFx4ODAtXFx4QkZdJyxcbiAgICAgICAgJ1tcXHhFMC1cXHhFRl1bXFx4ODAtXFx4QkZdezJ9JyxcbiAgICAgICAgJ1tcXHhGMC1cXHhGN11bXFx4ODAtXFx4QkZdezN9J1xuICAgIF0uam9pbignfCcpLCAnZycpO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICBzd2l0Y2goY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8ICA2KVxuICAgICAgICAgICAgICAgIHwgICAgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKChvZmZzZXQgID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpXG4gICAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuICAgIH07XG4gICAgdmFyIGNiX2RlY29kZSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNjY2MubGVuZ3RoLFxuICAgICAgICBwYWRsZW4gPSBsZW4gJSA0LFxuICAgICAgICBuID0gKGxlbiA+IDAgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMCldIDw8IDE4IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDEgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMSldIDw8IDEyIDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDIgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMildIDw8ICA2IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDMgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMyldICAgICAgIDogMCksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuID4+PiAxNiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoKG4gPj4+ICA4KSAmIDB4ZmYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuICAgICAgICAgJiAweGZmKVxuICAgICAgICBdO1xuICAgICAgICBjaGFycy5sZW5ndGggLT0gWzAsIDAsIDIsIDFdW3BhZGxlbl07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBhdG9iID0gZ2xvYmFsLmF0b2IgPyBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYXRvYihhKTtcbiAgICB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1tcXHNcXFNdezEsNH0vZywgY2JfZGVjb2RlKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gYnVmZmVyID9cbiAgICAgICAgYnVmZmVyLmZyb20gJiYgYnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSA/IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoYS5jb25zdHJ1Y3RvciA9PT0gYnVmZmVyLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgID8gYSA6IGJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoYS5jb25zdHJ1Y3RvciA9PT0gYnVmZmVyLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgID8gYSA6IG5ldyBidWZmZXIoYSwgJ2Jhc2U2NCcpKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24oYSkgeyByZXR1cm4gYnRvdShhdG9iKGEpKSB9O1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGUoXG4gICAgICAgICAgICBTdHJpbmcoYSkucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbihtMCkgeyByZXR1cm4gbTAgPT0gJy0nID8gJysnIDogJy8nIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJylcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3RcbiAgICB9O1xuICAgIC8vIGlmIEVTNSBpcyBhdmFpbGFibGUsIG1ha2UgQmFzZTY0LmV4dGVuZFN0cmluZygpIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBub0VudW0gPSBmdW5jdGlvbih2KXtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6dixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWwuQmFzZTY0LmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAnZnJvbUJhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICh1cmlzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdXJpc2FmZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0VVJJJywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIGlmIChnbG9iYWxbJ01ldGVvciddKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBhbmQgQU1EIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgaGFzIHByZWNlZGVuY2UuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1x0XHRcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlx0XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGdsb2JhbC5CYXNlNjQgfSk7XG4gICAgfVxuICAgIC8vIHRoYXQncyBpdCFcbn0pKCAgIHR5cGVvZiBzZWxmICAgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG4gICAgOiB0aGlzXG4pO1xuIiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcbiAgdmFyIGRpY3Q7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSBkaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImZpdmVodW5kcmVkcGl4XCI6IHtcbiAgICBcImljb25cIjogXCJNNDIuOSwyNy42Yy0yLjEsMC0zLjYsMS01LjgsMy41Yy0xLjktMi41LTMuOC0zLjUtNS44LTMuNWMtMS43LDAtMy43LDAuNy00LjcsMy4yIGMtMS0yLTIuNy0yLjYtNC4xLTIuNmMtMSwwLTIsMC4yLTIuOSwxLjFsMC42LTMuM2g2LjJ2LTIuNWgtOC40bC0xLjUsOHYwLjJoMi43YzAuNi0xLDEuNS0xLjIsMi4zLTEuMmMxLjIsMCwyLjMsMC42LDIuNiwyLjR2MC43IGMtMC4yLDEuNi0xLjMsMi42LTIuNiwyLjZjLTEuMSwwLTIuMy0wLjYtMi40LTIuMmgtM3YwLjdjMCwwLjMsMC41LDEuNSwwLjUsMS42YzEuMywyLjEsMy40LDIuNSw1LDIuNWMxLjgsMCwzLjktMC43LDUuMS0zLjIgYzEuMSwyLjQsMywzLjEsNC44LDMuMWMyLjEsMCwzLjUtMC45LDUuNy0zLjNjMS45LDIuMywzLjcsMy4zLDUuNywzLjNjMy40LDAsNS4xLTIuNiw1LjEtNS42QzQ4LDMwLDQ2LjIsMjcuNiw0Mi45LDI3LjZ6ICBNMzQuNywzMy43Yy0wLjQsMC40LTEsMC45LTEuNCwxLjFjLTAuNywwLjQtMS4zLDAuNi0xLjksMC42Yy0wLjYsMC0xLjctMC40LTIuMS0xLjNjLTAuMS0wLjItMC4yLTAuNi0wLjItMC43di0wLjkgYzAuMy0xLjUsMS4xLTIuMSwyLjItMi4xYzAuMSwwLDAuNiwwLDAuOSwwLjFjMC40LDAuMSwwLjcsMC4zLDEuMSwwLjZjMC40LDAuMywyLDEuNiwyLDEuOEMzNS4zLDMzLjIsMzQuOSwzMy41LDM0LjcsMzMuN3ogIE00Mi45LDM1LjVjLTEuMywwLTIuNi0wLjktMy45LTIuM2MxLjQtMS41LDIuNS0yLjYsMy44LTIuNmMxLjUsMCwyLjMsMS4xLDIuMywyLjVDNDUuMiwzNC40LDQ0LjQsMzUuNSw0Mi45LDM1LjV6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTMzLjMsMzEuM2MtMC40LTAuMi0wLjctMC40LTEuMS0wLjZjLTAuMy0wLjEtMC44LTAuMS0wLjktMC4xYy0xLjEsMC0xLjksMC42LTIuMiwyLjF2MC45YzAsMC4xLDAuMSwwLjQsMC4yLDAuNyBjMC4zLDAuOSwxLjQsMS4zLDIuMSwxLjNzMS4yLTAuMiwxLjktMC42YzAuNS0wLjMsMS0wLjcsMS40LTEuMWMwLjItMC4yLDAuNS0wLjUsMC41LTAuNkMzNS4zLDMyLjgsMzMuNywzMS42LDMzLjMsMzEuM3ogIE00Mi44LDMwLjZjLTEuMywwLTIuNCwxLTMuOCwyLjZjMS4zLDEuNSwyLjYsMi4zLDMuOSwyLjNjMS41LDAsMi4yLTEuMSwyLjItMi40QzQ1LjIsMzEuNyw0NC4zLDMwLjYsNDIuOCwzMC42eiBNMCwwdjY0aDY0VjBIMHogIE00Mi45LDM4LjVjLTIsMC0zLjgtMS01LjctMy4zYy0yLjIsMi40LTMuNywzLjMtNS43LDMuM2MtMS44LDAtMy43LTAuNy00LjgtMy4xYy0xLjIsMi41LTMuMywzLjItNS4xLDMuMmMtMS42LDAtMy44LTAuNC01LTIuNSBDMTYuNSwzNiwxNiwzNC44LDE2LDM0LjV2LTAuN2gzYzAuMSwxLjYsMS4zLDIuMiwyLjQsMi4yYzEuMywwLDIuNC0wLjksMi42LTIuNnYtMC43Yy0wLjItMS44LTEuMy0yLjQtMi42LTIuNCBjLTAuOCwwLTEuNiwwLjItMi4zLDEuMmgtMi43di0wLjJsMS41LThoOC40djIuNWgtNi4ybC0wLjYsMy4zYzEtMC45LDItMS4xLDIuOS0xLjFjMS40LDAsMy4yLDAuNiw0LjEsMi42YzEtMi40LDMtMy4yLDQuNy0zLjIgYzIsMCwzLjksMSw1LjgsMy41YzIuMS0yLjYsMy43LTMuNSw1LjgtMy41YzMuMywwLDUuMSwyLjQsNS4xLDUuNEM0OCwzNS45LDQ2LjIsMzguNSw0Mi45LDM4LjV6XCIsXG4gICAgXCJjb2xvclwiOiBcIiMyMjIyMjJcIlxuICB9LFxuICBcImJhbmRzaW50b3duXCI6IHtcbiAgICBcImljb25cIjogXCJNMjUuOCwzOS4zaDEzLjR2MS4xSDI0LjdWMThoLTUuNnYyOGgyNS44VjMzLjdoLTE5VjM5LjN6IE0zMS40LDI0LjdoLTUuNnY3LjhoNS42VjI0Ljd6IE0zOC4yLDI0LjdoLTUuNnY3LjhoNS42VjI0Ljd6IE0zOS4zLDE4djE0LjZoNS42VjE4SDM5LjN6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE0zMi42LDI0LjdoNS42djcuOGgtNS42VjI0Ljd6IE0yNS44LDI0LjdoNS42djcuOGgtNS42VjI0Ljd6IE00NC45LDQ2SDE5LjFWMThoNS42djIyLjRoMTQuNiB2LTEuMUgyNS44di01LjZoMTlWNDZ6IE00NC45LDMyLjZoLTUuNlYxOGg1LjZWMzIuNnpcIixcbiAgICBcImNvbG9yXCI6IFwiIzFCODc5M1wiXG4gIH0sXG4gIFwiYmVoYW5jZVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTI5LjEsMzFjMC44LTAuNCwxLjUtMC45LDEuOS0xLjVjMC40LTAuNiwwLjYtMS40LDAuNi0yLjNjMC0wLjktMC4xLTEuNi0wLjQtMi4yIGMtMC4zLTAuNi0wLjctMS4xLTEuMi0xLjRjLTAuNS0wLjQtMS4xLTAuNi0xLjktMC44Yy0wLjctMC4yLTEuNS0wLjItMi40LTAuMkgxN3YxOC41aDguOWMwLjgsMCwxLjYtMC4xLDIuNC0wLjMgYzAuOC0wLjIsMS41LTAuNSwyLjEtMWMwLjYtMC40LDEuMS0xLDEuNS0xLjdjMC40LTAuNywwLjUtMS41LDAuNS0yLjRjMC0xLjItMC4zLTIuMS0wLjgtM0MzMS4xLDMxLjksMzAuMiwzMS4zLDI5LjEsMzF6ICBNMjEuMSwyNS43aDMuOGMwLjQsMCwwLjcsMCwxLDAuMWMwLjMsMC4xLDAuNiwwLjIsMC45LDAuM2MwLjMsMC4yLDAuNSwwLjQsMC42LDAuNmMwLjIsMC4zLDAuMiwwLjYsMC4yLDEuMWMwLDAuOC0wLjIsMS4zLTAuNywxLjcgYy0wLjUsMC4zLTEuMSwwLjUtMS44LDAuNWgtNC4xVjI1Ljd6IE0yOC4yLDM2LjdjLTAuMiwwLjMtMC40LDAuNi0wLjcsMC43Yy0wLjMsMC4yLTAuNiwwLjMtMSwwLjRjLTAuNCwwLjEtMC43LDAuMS0xLjEsMC4xaC00LjMgdi01LjFoNC40YzAuOSwwLDEuNiwwLjIsMi4xLDAuNmMwLjUsMC40LDAuOCwxLjEsMC44LDJDMjguNCwzNiwyOC4zLDM2LjQsMjguMiwzNi43eiBNNDYuNywzMi4zYy0wLjItMC45LTAuNi0xLjgtMS4yLTIuNSBDNDUsMjksNDQuMywyOC40LDQzLjUsMjhjLTAuOC0wLjQtMS44LTAuNy0zLTAuN2MtMSwwLTEuOSwwLjItMi44LDAuNWMtMC44LDAuNC0xLjYsMC45LTIuMiwxLjVjLTAuNiwwLjYtMS4xLDEuNC0xLjQsMi4yIGMtMC4zLDAuOS0wLjUsMS44LTAuNSwyLjhjMCwxLDAuMiwyLDAuNSwyLjhjMC4zLDAuOSwwLjgsMS42LDEuNCwyLjJjMC42LDAuNiwxLjMsMS4xLDIuMiwxLjRjMC45LDAuMywxLjgsMC41LDIuOSwwLjUgYzEuNSwwLDIuOC0wLjMsMy45LTFjMS4xLTAuNywxLjktMS44LDIuNC0zLjRoLTMuMmMtMC4xLDAuNC0wLjQsMC44LTEsMS4yYy0wLjUsMC40LTEuMiwwLjYtMS45LDAuNmMtMSwwLTEuOC0wLjMtMi40LTAuOCBjLTAuNi0wLjUtMC45LTEuNS0wLjktMi42SDQ3QzQ3LDM0LjIsNDcsMzMuMiw0Ni43LDMyLjN6IE0zNy4zLDMyLjljMC0wLjMsMC4xLTAuNiwwLjItMC45YzAuMS0wLjMsMC4zLTAuNiwwLjUtMC45IGMwLjItMC4zLDAuNS0wLjUsMC45LTAuN2MwLjQtMC4yLDAuOS0wLjMsMS41LTAuM2MwLjksMCwxLjYsMC4zLDIuMSwwLjdjMC40LDAuNSwwLjgsMS4yLDAuOCwyLjFIMzcuM3ogTTQ0LjEsMjMuOGgtNy41djEuOGg3LjUgVjIzLjh6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTQwLjQsMzAuMWMtMC42LDAtMS4xLDAuMS0xLjUsMC4zYy0wLjQsMC4yLTAuNywwLjQtMC45LDAuN2MtMC4yLDAuMy0wLjQsMC42LTAuNSwwLjljLTAuMSwwLjMtMC4yLDAuNi0wLjIsMC45IGg2Yy0wLjEtMC45LTAuNC0xLjYtMC44LTIuMUM0MiwzMC4zLDQxLjMsMzAuMSw0MC40LDMwLjF6IE0yNS41LDMyLjhoLTQuNHY1LjFoNC4zYzAuNCwwLDAuOCwwLDEuMS0wLjFjMC40LTAuMSwwLjctMC4yLDEtMC40IGMwLjMtMC4yLDAuNS0wLjQsMC43LTAuN2MwLjItMC4zLDAuMi0wLjcsMC4yLTEuMmMwLTEtMC4zLTEuNi0wLjgtMkMyNy4xLDMzLDI2LjQsMzIuOCwyNS41LDMyLjh6IE0yNywyOS41IGMwLjUtMC4zLDAuNy0wLjksMC43LTEuN2MwLTAuNC0wLjEtMC44LTAuMi0xLjFjLTAuMi0wLjMtMC40LTAuNS0wLjYtMC42Yy0wLjMtMC4yLTAuNi0wLjMtMC45LTAuM2MtMC4zLTAuMS0wLjctMC4xLTEtMC4xaC0zLjggdjQuM2g0LjFDMjUuOSwzMC4xLDI2LjUsMjkuOSwyNywyOS41eiBNMCwwdjY0aDY0VjBIMHogTTM2LjYsMjMuOGg3LjV2MS44aC03LjVWMjMuOHogTTMxLjksMzguMWMtMC40LDAuNy0wLjksMS4yLTEuNSwxLjcgYy0wLjYsMC40LTEuMywwLjgtMi4xLDFjLTAuOCwwLjItMS42LDAuMy0yLjQsMC4zSDE3VjIyLjZoOC43YzAuOSwwLDEuNywwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS45LDAuOCBjMC41LDAuNCwwLjksMC44LDEuMiwxLjRjMC4zLDAuNiwwLjQsMS4zLDAuNCwyLjJjMCwwLjktMC4yLDEuNy0wLjYsMi4zYy0wLjQsMC42LTEsMS4xLTEuOSwxLjVjMS4xLDAuMywyLDAuOSwyLjUsMS43IGMwLjYsMC44LDAuOCwxLjgsMC44LDNDMzIuNSwzNi42LDMyLjMsMzcuNCwzMS45LDM4LjF6IE00NywzNS4zaC05LjZjMCwxLjEsMC40LDIuMSwwLjksMi42YzAuNSwwLjUsMS4zLDAuOCwyLjQsMC44IGMwLjcsMCwxLjQtMC4yLDEuOS0wLjZjMC41LTAuNCwwLjktMC44LDEtMS4yaDMuMmMtMC41LDEuNi0xLjMsMi44LTIuNCwzLjRjLTEuMSwwLjctMi40LDEtMy45LDFjLTEuMSwwLTItMC4yLTIuOS0wLjUgYy0wLjgtMC4zLTEuNi0wLjgtMi4yLTEuNGMtMC42LTAuNi0xLTEuNC0xLjQtMi4yYy0wLjMtMC45LTAuNS0xLjgtMC41LTIuOGMwLTEsMC4yLTEuOSwwLjUtMi44YzAuMy0wLjksMC44LTEuNiwxLjQtMi4yIGMwLjYtMC42LDEuMy0xLjEsMi4yLTEuNWMwLjgtMC40LDEuOC0wLjUsMi44LTAuNWMxLjEsMCwyLjEsMC4yLDMsMC43YzAuOCwwLjQsMS41LDEsMi4xLDEuOGMwLjUsMC43LDAuOSwxLjYsMS4yLDIuNSBDNDcsMzMuMiw0NywzNC4yLDQ3LDM1LjN6XCIsXG4gICAgXCJjb2xvclwiOiBcIiMwMDdDRkZcIlxuICB9LFxuICBcImNvZGVwZW5cIjoge1xuICAgIFwiaWNvblwiOiBcIk0yNC40LDM1bDYuOCw0LjV2LTRMMjcuNCwzM0wyNC40LDM1eiBNMjMuOCwzMC42djIuN2wyLjEtMS40TDIzLjgsMzAuNnogTTMxLjIsMjguNXYtNEwyNC40LDI5IGwzLDJMMzEuMiwyOC41eiBNMzkuNiwyOWwtNi44LTQuNXY0bDMuNywyLjVMMzkuNiwyOXogTTMyLDMwbC0zLDJsMywybDMtMkwzMiwzMHogTTMyLDE2Yy04LjgsMC0xNiw3LjItMTYsMTZjMCw4LjgsNy4yLDE2LDE2LDE2IHMxNi03LjIsMTYtMTZDNDgsMjMuMiw0MC44LDE2LDMyLDE2eiBNNDEuOSwzNS4xYzAsMC4zLTAuMSwwLjYtMC40LDAuN2wtOS4xLDUuOWMtMC4zLDAuMi0wLjYsMC4yLTAuOSwwbC05LjEtNS45IGMtMC4yLTAuMi0wLjQtMC40LTAuNC0wLjd2LTYuMmMwLTAuMywwLjEtMC42LDAuNC0wLjdsOS4xLTUuOWMwLjMtMC4yLDAuNi0wLjIsMC45LDBsOS4xLDUuOWMwLjIsMC4yLDAuNCwwLjQsMC40LDAuN1YzNS4xeiAgTTMyLjgsMzUuNXY0bDYuOC00LjVsLTMtMkwzMi44LDM1LjV6IE00MC4yLDMzLjR2LTIuN0wzOC4xLDMyTDQwLjIsMzMuNHpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTMyLDQ4Yy04LjgsMC0xNi03LjItMTYtMTZjMC04LjgsNy4yLTE2LDE2LTE2czE2LDcuMiwxNiwxNkM0OCw0MC44LDQwLjgsNDgsMzIsNDh6IE0zMi41LDIyLjMgYy0wLjMtMC4yLTAuNi0wLjItMC45LDBsLTkuMSw1LjljLTAuMiwwLjItMC40LDAuNC0wLjQsMC43djYuMmMwLDAuMywwLjEsMC42LDAuNCwwLjdsOS4xLDUuOWMwLjMsMC4yLDAuNiwwLjIsMC45LDBsOS4xLTUuOSBjMC4yLTAuMiwwLjQtMC40LDAuNC0wLjd2LTYuMmMwLTAuMy0wLjEtMC42LTAuNC0wLjdMMzIuNSwyMi4zeiBNMzIuOCwyNC41bDYuOCw0LjVsLTMsMmwtMy43LTIuNVYyNC41eiBNMzEuMiwyNC41djRMMjcuNCwzMWwtMy0yIEwzMS4yLDI0LjV6IE0yMy44LDMwLjZsMi4xLDEuNGwtMi4xLDEuNFYzMC42eiBNMzEuMiwzOS41TDI0LjQsMzVsMy0ybDMuNywyLjVWMzkuNXogTTMyLDM0bC0zLTJsMy0ybDMsMkwzMiwzNHogTTMyLjgsMzkuNXYtNCBsMy43LTIuNWwzLDJMMzIuOCwzOS41eiBNNDAuMiwzMy40TDM4LjEsMzJsMi4xLTEuNFYzMy40elwiLFxuICAgIFwiY29sb3JcIjogXCIjIzE1MTUxNVwiXG4gIH0sXG4gIFwiZHJpYmJibGVcIjoge1xuICAgIFwiaWNvblwiOiBcIk0zMiw0OGMtOC44LDAtMTYtNy4yLTE2LTE2czcuMi0xNiwxNi0xNiBzMTYsNy4yLDE2LDE2UzQwLjgsNDgsMzIsNDh6IE00NS41LDM0LjJDNDUsMzQsNDEuMywzMi45LDM3LDMzLjZjMS44LDQuOSwyLjUsOC45LDIuNyw5LjdDNDIuNyw0MS4zLDQ0LjksMzgsNDUuNSwzNC4yeiBNMzcuMyw0NC42IGMtMC4yLTEuMi0xLTUuNC0yLjktMTAuNGMwLDAtMC4xLDAtMC4xLDBjLTcuNywyLjctMTAuNSw4LTEwLjcsOC41YzIuMywxLjgsNS4yLDIuOSw4LjQsMi45QzMzLjksNDUuNywzNS43LDQ1LjMsMzcuMyw0NC42eiAgTTIxLjgsNDEuMmMwLjMtMC41LDQuMS02LjcsMTEuMS05YzAuMi0wLjEsMC40LTAuMSwwLjUtMC4yYy0wLjMtMC44LTAuNy0xLjYtMS4xLTIuM2MtNi44LDItMTMuNCwyLTE0LDEuOWMwLDAuMSwwLDAuMywwLDAuNCBDMTguMywzNS41LDE5LjcsMzguNywyMS44LDQxLjJ6IE0xOC42LDI5LjJjMC42LDAsNi4yLDAsMTIuNi0xLjdjLTIuMy00LTQuNy03LjQtNS4xLTcuOUMyMi40LDIxLjUsMTkuNSwyNSwxOC42LDI5LjJ6IE0yOC44LDE4LjcgYzAuNCwwLjUsMi45LDMuOSw1LjEsOGM0LjktMS44LDYuOS00LjYsNy4yLTQuOWMtMi40LTIuMS01LjYtMy40LTkuMS0zLjRDMzAuOSwxOC40LDI5LjgsMTguNSwyOC44LDE4Ljd6IE00Mi42LDIzLjQgYy0wLjMsMC40LTIuNiwzLjMtNy42LDUuNGMwLjMsMC43LDAuNiwxLjMsMC45LDJjMC4xLDAuMiwwLjIsMC41LDAuMywwLjdjNC41LTAuNiw5LjEsMC4zLDkuNSwwLjRDNDUuNiwyOC43LDQ0LjUsMjUuNyw0Mi42LDIzLjR6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTM0LjMsMzQuM2MtNy43LDIuNy0xMC41LDgtMTAuNyw4LjVjMi4zLDEuOCw1LjIsMi45LDguNCwyLjljMS45LDAsMy43LTAuNCw1LjMtMS4xIEMzNy4xLDQzLjQsMzYuMywzOS4yLDM0LjMsMzQuM0MzNC40LDM0LjIsMzQuNCwzNC4zLDM0LjMsMzQuM3ogTTMxLjMsMjcuNmMtMi4zLTQtNC43LTcuNC01LjEtNy45Yy0zLjgsMS44LTYuNyw1LjMtNy42LDkuNiBDMTkuMiwyOS4yLDI0LjksMjkuMywzMS4zLDI3LjZ6IE0zMywzMi4xYzAuMi0wLjEsMC40LTAuMSwwLjUtMC4yYy0wLjMtMC44LTAuNy0xLjYtMS4xLTIuM2MtNi44LDItMTMuNCwyLTE0LDEuOSBjMCwwLjEsMCwwLjMsMCwwLjRjMCwzLjUsMS4zLDYuNywzLjUsOS4xQzIyLjIsNDAuNiwyNS45LDM0LjQsMzMsMzIuMXogTTQxLjEsMjEuOGMtMi40LTIuMS01LjYtMy40LTkuMS0zLjQgYy0xLjEsMC0yLjIsMC4xLTMuMiwwLjRjMC40LDAuNSwyLjksMy45LDUuMSw4QzM4LjgsMjQuOSw0MC44LDIyLjEsNDEuMSwyMS44eiBNMzQuOSwyOC44YzAuMywwLjcsMC42LDEuMywwLjksMiBjMC4xLDAuMiwwLjIsMC41LDAuMywwLjdjNC41LTAuNiw5LjEsMC4zLDkuNSwwLjRjMC0zLjItMS4yLTYuMi0zLjEtOC41QzQyLjMsMjMuOCw0MCwyNi43LDM0LjksMjguOHogTTM3LDMzLjYgYzEuOCw0LjksMi41LDguOSwyLjcsOS43YzMuMS0yLjEsNS4yLTUuNCw1LjktOS4yQzQ1LDM0LDQxLjMsMzIuOSwzNywzMy42eiBNMCwwdjY0aDY0VjBIMHogTTMyLDQ4Yy04LjgsMC0xNi03LjItMTYtMTYgczcuMi0xNiwxNi0xNnMxNiw3LjIsMTYsMTZTNDAuOCw0OCwzMiw0OHpcIixcbiAgICBcImNvbG9yXCI6IFwiI2VhNGM4OVwiXG4gIH0sXG4gIFwiZHJvcGJveFwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTI1LjQsMTcuMUwxNiwyMy4zbDYuNSw1LjJsOS41LTUuOUwyNS40LDE3LjF6IE0xNiwzMy43bDkuNCw2LjFsNi42LTUuNWwtOS41LTUuOUwxNiwzMy43eiAgTTMyLDM0LjNsNi42LDUuNWw5LjQtNi4xbC02LjUtNS4yTDMyLDM0LjN6IE00OCwyMy4zbC05LjQtNi4xTDMyLDIyLjZsOS41LDUuOUw0OCwyMy4zeiBNMzIsMzUuNUwyNS40LDQxbC0yLjgtMS44djIuMWw5LjQsNS43IGw5LjQtNS43di0yLjFMMzguNiw0MUwzMiwzNS41elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNNDEuNSw0MS4yTDMyLDQ2LjlsLTkuNC01Ljd2LTIuMWwyLjgsMS44bDYuNi01LjVsNi42LDUuNWwyLjgtMS44VjQxLjJ6IE00OCwzMy43bC05LjQsNi4xIEwzMiwzNC4zbC02LjYsNS41TDE2LDMzLjdsNi41LTUuMkwxNiwyMy4zbDkuNC02LjFsNi42LDUuNWw2LjYtNS41bDkuNCw2LjFsLTYuNSw1LjJMNDgsMzMuN3ogTTIyLjUsMjguNWw5LjUsNS45bDkuNS01LjlMMzIsMjIuNiBMMjIuNSwyOC41elwiLFxuICAgIFwiY29sb3JcIjogXCIjMTA4MURFXCJcbiAgfSxcbiAgXCJlbWFpbFwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTE3LDIydjIwaDMwVjIySDE3eiBNNDEuMSwyNUwzMiwzMi4xTDIyLjksMjVINDEuMXogTTIwLDM5VjI2LjZsMTIsOS4zbDEyLTkuM1YzOUgyMHpcIixcbiAgICBcIm1hc2tcIjogXCJNNDEuMSwyNUgyMi45bDkuMSw3LjFMNDEuMSwyNXogTTQ0LDI2LjZsLTEyLDkuM2wtMTItOS4zVjM5aDI0VjI2LjZ6IE0wLDB2NjRoNjRWMEgweiBNNDcsNDJIMTdWMjJoMzBWNDJ6XCIsXG4gICAgXCJjb2xvclwiOiBcIiM3ZjdmN2ZcIlxuICB9LFxuICBcImZhY2Vib29rXCI6IHtcbiAgICBcImljb25cIjogXCJNMzQuMSw0N1YzMy4zaDQuNmwwLjctNS4zaC01LjN2LTMuNGMwLTEuNSwwLjQtMi42LDIuNi0yLjZsMi44LDB2LTQuOGMtMC41LTAuMS0yLjItMC4yLTQuMS0wLjIgYy00LjEsMC02LjksMi41LTYuOSw3VjI4SDI0djUuM2g0LjZWNDdIMzQuMXpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTM5LjYsMjJsLTIuOCwwYy0yLjIsMC0yLjYsMS4xLTIuNiwyLjZWMjhoNS4zbC0wLjcsNS4zaC00LjZWNDdoLTUuNVYzMy4zSDI0VjI4aDQuNlYyNCBjMC00LjYsMi44LTcsNi45LTdjMiwwLDMuNiwwLjEsNC4xLDAuMlYyMnpcIixcbiAgICBcImNvbG9yXCI6IFwiIzNiNTk5OFwiXG4gIH0sXG4gIFwiZmxpY2tyXCI6IHtcbiAgICBcImljb25cIjogXCJNMzIsMTZjLTguOCwwLTE2LDcuMi0xNiwxNnM3LjIsMTYsMTYsMTZzMTYtNy4yLDE2LTE2UzQwLjgsMTYsMzIsMTZ6IE0yNiwzN2MtMi44LDAtNS0yLjItNS01IHMyLjItNSw1LTVzNSwyLjIsNSw1UzI4LjgsMzcsMjYsMzd6IE0zOCwzN2MtMi44LDAtNS0yLjItNS01czIuMi01LDUtNXM1LDIuMiw1LDVTNDAuOCwzNywzOCwzN3pcIixcbiAgICBcIm1hc2tcIjogXCJNMzgsMjdjLTIuOCwwLTUsMi4yLTUsNXMyLjIsNSw1LDVzNS0yLjIsNS01UzQwLjgsMjcsMzgsMjd6IE0wLDB2NjRoNjRWMEgweiBNMzIsNDhjLTguOCwwLTE2LTcuMi0xNi0xNiBzNy4yLTE2LDE2LTE2czE2LDcuMiwxNiwxNlM0MC44LDQ4LDMyLDQ4eiBNMjYsMjdjLTIuOCwwLTUsMi4yLTUsNXMyLjIsNSw1LDVzNS0yLjIsNS01UzI4LjgsMjcsMjYsMjd6XCIsXG4gICAgXCJjb2xvclwiOiBcIiMwMDYzZGJcIlxuICB9LFxuICBcImZvdXJzcXVhcmVcIjoge1xuICAgIFwiaWNvblwiOiBcIk00MS41LDE3YzAsMC0xNC4zLDAtMTYuNSwwYy0yLjMsMC0zLDEuNy0zLDIuOGMwLDEuMSwwLDI2LjMsMCwyNi4zYzAsMS4yLDAuNywxLjcsMSwxLjggYzAuNCwwLjEsMS40LDAuMywyLTAuNGMwLDAsNy44LTkuMSw3LjktOS4yYzAuMi0wLjIsMC4yLTAuMiwwLjQtMC4yYzAuNCwwLDMuNCwwLDUuMSwwYzIuMSwwLDIuNS0xLjUsMi43LTIuNCBjMC4yLTAuNywyLjMtMTEuMywyLjktMTQuN0M0NC42LDE4LjQsNDMuOSwxNyw0MS41LDE3eiBNNDEuMSwzNS43YzAuMi0wLjcsMi4zLTExLjMsMi45LTE0LjcgTTQwLjUsMjEuNWwtMC43LDMuNiBjLTAuMSwwLjQtMC42LDAuOC0xLDAuOGMtMC41LDAtNi40LDAtNi40LDBjLTAuNywwLTEuMiwwLjUtMS4yLDEuMnYwLjhjMCwwLjcsMC41LDEuMiwxLjIsMS4yYzAsMCw1LDAsNS41LDBjMC41LDAsMSwwLjYsMC45LDEuMSBjLTAuMSwwLjUtMC42LDMuMy0wLjcsMy42Yy0wLjEsMC4zLTAuNCwwLjgtMSwwLjhjLTAuNSwwLTQuNSwwLTQuNSwwYy0wLjgsMC0xLjEsMC4xLTEuNiwwLjhjLTAuNSwwLjctNS40LDYuNS01LjQsNi41IGMwLDAuMS0wLjEsMC0wLjEsMFYyMS40YzAtMC41LDAuNC0xLDEtMWMwLDAsMTIuOCwwLDEzLjMsMEM0MC4yLDIwLjQsNDAuNiwyMC45LDQwLjUsMjEuNXpcIixcbiAgICBcIm1hc2tcIjogXCJNMzkuNywyMC40Yy0wLjUsMC0xMy4zLDAtMTMuMywwYy0wLjYsMC0xLDAuNS0xLDF2MjAuNWMwLDAuMSwwLDAuMSwwLjEsMGMwLDAsNC45LTUuOSw1LjQtNi41IGMwLjUtMC43LDAuOC0wLjgsMS42LTAuOGMwLDAsMy45LDAsNC41LDBjMC42LDAsMS0wLjUsMS0wLjhjMC4xLTAuMywwLjYtMywwLjctMy42YzAuMS0wLjUtMC40LTEuMS0wLjktMS4xYy0wLjUsMC01LjUsMC01LjUsMCBjLTAuNywwLTEuMi0wLjUtMS4yLTEuMnYtMC44YzAtMC43LDAuNS0xLjIsMS4yLTEuMmMwLDAsNiwwLDYuNCwwYzAuNSwwLDAuOS0wLjQsMS0wLjhsMC43LTMuNkM0MC42LDIwLjksNDAuMiwyMC40LDM5LjcsMjAuNHogIE0wLDB2NjRoNjRWMEgweiBNNDQsMjAuOWwtMSw1LjJjLTAuOCw0LjItMS44LDktMS45LDkuNWMtMC4yLDAuOS0wLjYsMi40LTIuNywyLjRoLTUuMWMtMC4yLDAtMC4yLDAtMC40LDAuMiBjLTAuMSwwLjEtNy45LDkuMi03LjksOS4yYy0wLjYsMC43LTEuNiwwLjYtMiwwLjRjLTAuNC0wLjEtMS0wLjYtMS0xLjhjMCwwLDAtMjUuMiwwLTI2LjNjMC0xLjEsMC43LTIuOCwzLTIuOGMyLjMsMCwxNi41LDAsMTYuNSwwIEM0My45LDE3LDQ0LjYsMTguNCw0NCwyMC45elwiLFxuICAgIFwiY29sb3JcIjogXCIjMDA3MmIxXCJcbiAgfSxcbiAgXCJnaXRodWJcIjoge1xuICAgIFwiaWNvblwiOiBcIk0zMiwxNmMtOC44LDAtMTYsNy4yLTE2LDE2YzAsNy4xLDQuNiwxMy4xLDEwLjksMTUuMiBjMC44LDAuMSwxLjEtMC4zLDEuMS0wLjhjMC0wLjQsMC0xLjQsMC0yLjdjLTQuNSwxLTUuNC0yLjEtNS40LTIuMWMtMC43LTEuOC0xLjgtMi4zLTEuOC0yLjNjLTEuNS0xLDAuMS0xLDAuMS0xIGMxLjYsMC4xLDIuNSwxLjYsMi41LDEuNmMxLjQsMi40LDMuNywxLjcsNC43LDEuM2MwLjEtMSwwLjYtMS43LDEtMi4xYy0zLjYtMC40LTcuMy0xLjgtNy4zLTcuOWMwLTEuNywwLjYtMy4yLDEuNi00LjMgYy0wLjItMC40LTAuNy0yLDAuMi00LjJjMCwwLDEuMy0wLjQsNC40LDEuNmMxLjMtMC40LDIuNi0wLjUsNC0wLjVjMS40LDAsMi43LDAuMiw0LDAuNWMzLjEtMi4xLDQuNC0xLjYsNC40LTEuNiBjMC45LDIuMiwwLjMsMy44LDAuMiw0LjJjMSwxLjEsMS42LDIuNSwxLjYsNC4zYzAsNi4xLTMuNyw3LjUtNy4zLDcuOWMwLjYsMC41LDEuMSwxLjUsMS4xLDNjMCwyLjEsMCwzLjksMCw0LjQgYzAsMC40LDAuMywwLjksMS4xLDAuOEM0My40LDQ1LjEsNDgsMzkuMSw0OCwzMkM0OCwyMy4yLDQwLjgsMTYsMzIsMTZ6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE0zNy4xLDQ3LjJjLTAuOCwwLjItMS4xLTAuMy0xLjEtMC44YzAtMC41LDAtMi4zLDAtNC40YzAtMS41LTAuNS0yLjUtMS4xLTMgYzMuNi0wLjQsNy4zLTEuNyw3LjMtNy45YzAtMS43LTAuNi0zLjItMS42LTQuM2MwLjItMC40LDAuNy0yLTAuMi00LjJjMCwwLTEuMy0wLjQtNC40LDEuNmMtMS4zLTAuNC0yLjYtMC41LTQtMC41IGMtMS40LDAtMi43LDAuMi00LDAuNWMtMy4xLTIuMS00LjQtMS42LTQuNC0xLjZjLTAuOSwyLjItMC4zLDMuOC0wLjIsNC4yYy0xLDEuMS0xLjYsMi41LTEuNiw0LjNjMCw2LjEsMy43LDcuNSw3LjMsNy45IGMtMC41LDAuNC0wLjksMS4xLTEsMi4xYy0wLjksMC40LTMuMiwxLjEtNC43LTEuM2MwLDAtMC44LTEuNS0yLjUtMS42YzAsMC0xLjYsMC0wLjEsMWMwLDAsMSwwLjUsMS44LDIuM2MwLDAsMC45LDMuMSw1LjQsMi4xIGMwLDEuMywwLDIuMywwLDIuN2MwLDAuNC0wLjMsMC45LTEuMSwwLjhDMjAuNiw0NS4xLDE2LDM5LjEsMTYsMzJjMC04LjgsNy4yLTE2LDE2LTE2YzguOCwwLDE2LDcuMiwxNiwxNiBDNDgsMzkuMSw0My40LDQ1LjEsMzcuMSw0Ny4yelwiLFxuICAgIFwiY29sb3JcIjogXCIjNDE4M2M0XCJcbiAgfSxcbiAgXCJnb29nbGVfcGxheVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTI0LjQsNDUuNmwxNi04LjhsLTMuNi0zLjZMMjQuNCw0NS42eiBNMjIuMiwxOC41Yy0wLjEsMC4yLTAuMiwwLjUtMC4yLDAuOXYyNS4xIGMwLDAuNCwwLjEsMC42LDAuMiwwLjlMMzUuNiwzMkwyMi4yLDE4LjV6IE00Ny4xLDMwLjhMNDIuMSwyOEwzOC4xLDMybDQsNGw1LTIuOEM0OC4zLDMyLjUsNDguMywzMS40LDQ3LjEsMzAuOHogTTQwLjQsMjcuMSBsLTE1LjktOC44bDEyLjMsMTIuM0w0MC40LDI3LjF6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE00MC40LDI3LjFsLTMuNiwzLjZMMjQuNSwxOC40TDQwLjQsMjcuMXogTTIyLDQ0LjVWMTkuNGMwLTAuNCwwLjEtMC43LDAuMi0wLjlMMzUuNiwzMiBMMjIuMiw0NS40QzIyLjEsNDUuMiwyMiw0NC45LDIyLDQ0LjV6IE0yNC40LDQ1LjZsMTIuNC0xMi40bDMuNiwzLjZMMjQuNCw0NS42eiBNNDcuMSwzMy4ybC01LDIuOGwtNC00bDMuOS0zLjlsNS4xLDIuOCBDNDguMywzMS40LDQ4LjMsMzIuNSw0Ny4xLDMzLjJ6XCIsXG4gICAgXCJjb2xvclwiOiBcIiM0MEJCQzFcIlxuICB9LFxuICBcImdvb2dsZVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTM1LjQsMTdoLThjLTEuMSwwLTIuMiwwLjEtMy40LDAuNCBjLTEuMiwwLjMtMi40LDAuOS0zLjUsMS44Yy0xLjcsMS42LTIuNSwzLjQtMi41LDUuNGMwLDEuNiwwLjYsMy4xLDEuOCw0LjNjMS4xLDEuMywyLjcsMiw0LjksMmMwLjQsMCwwLjgsMCwxLjMtMC4xIGMtMC4xLDAuMi0wLjIsMC40LTAuMiwwLjdjLTAuMSwwLjItMC4yLDAuNS0wLjIsMC45YzAsMC42LDAuMSwxLjEsMC40LDEuNWMwLjIsMC40LDAuNSwwLjgsMC44LDEuMmMtMC45LDAtMi4xLDAuMS0zLjUsMC40IGMtMS40LDAuMi0yLjgsMC43LTQuMSwxLjVjLTEuMiwwLjctMS45LDEuNS0yLjQsMi40Yy0wLjUsMC45LTAuNywxLjctMC43LDIuNWMwLDEuNSwwLjcsMi44LDIuMSwzLjljMS40LDEuMiwzLjUsMS44LDYuMywxLjggYzMuMy0wLjEsNS45LTAuOSw3LjctMi40YzEuNy0xLjUsMi42LTMuMiwyLjYtNS4yYzAtMS40LTAuMy0yLjUtMC45LTMuM2MtMC42LTAuOC0xLjQtMS42LTIuMi0yLjNsLTEuNC0xLjEgYy0wLjItMC4yLTAuNC0wLjQtMC42LTAuN2MtMC4yLTAuMy0wLjQtMC42LTAuNC0xYzAtMC40LDAuMS0wLjgsMC40LTEuMWMwLjItMC4zLDAuNC0wLjYsMC43LTAuOGMwLjQtMC40LDAuOC0wLjcsMS4yLTEuMSBjMC4zLTAuNCwwLjYtMC43LDAuOS0xLjJjMC42LTAuOSwwLjktMiwwLjktMy40YzAtMC44LTAuMS0xLjUtMC4zLTIuMWMtMC4yLTAuNi0wLjUtMS4xLTAuNy0xLjVjLTAuMy0wLjUtMC42LTAuOC0wLjktMS4yIGMtMC4zLTAuMy0wLjYtMC41LTAuOC0wLjdIMzNMMzUuNCwxN3ogTTMxLDM4LjljMC43LDAuOCwxLDEuNiwxLDIuN2MwLDEuMy0wLjUsMi4zLTEuNSwzLjFjLTEsMC44LTIuNCwxLjItNC4zLDEuMyBjLTIuMSwwLTMuOC0wLjUtNS0xLjRjLTEuMy0wLjktMS45LTIuMS0xLjktMy41YzAtMC43LDAuMS0xLjMsMC40LTEuOGMwLjMtMC41LDAuNi0wLjksMC45LTEuMmMwLjQtMC4zLDAuOC0wLjYsMS4xLTAuNyBjMC40LTAuMiwwLjctMC4zLDAuOS0wLjRjMC45LTAuMywxLjctMC41LDIuNS0wLjZjMC44LTAuMSwxLjQtMC4xLDEuNi0wLjFjMC4zLDAsMC42LDAsMC45LDBDMjkuMiwzNy4zLDMwLjMsMzguMiwzMSwzOC45eiAgTTI5LjcsMjcuMWMtMC4xLDAuNS0wLjMsMS4xLTAuNywxLjZjLTAuNywwLjctMS42LDEuMS0yLjYsMS4xYy0wLjgsMC0xLjYtMC4zLTIuMi0wLjhjLTAuNi0wLjUtMS4yLTEuMS0xLjYtMS45IGMtMC44LTEuNi0xLjMtMy4xLTEuMy00LjVjMC0xLjEsMC4zLTIuMSwwLjktM2MwLjctMC45LDEuNi0xLjMsMi43LTEuM2MwLjgsMCwxLjUsMC4zLDIuMiwwLjdjMC42LDAuNSwxLjEsMS4xLDEuNSwxLjkgYzAuOCwxLjYsMS4yLDMuMiwxLjIsNC44QzI5LjgsMjYuMSwyOS44LDI2LjUsMjkuNywyNy4xeiBNNDMuNywyOS41di00LjNoLTIuNXY0LjNIMzdWMzJoNC4ydjQuMmgyLjVWMzJINDh2LTIuNUg0My43elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMzEuMywxOS4xYzAuMywwLjMsMC42LDAuNywwLjksMS4yYzAuMywwLjQsMC41LDAuOSwwLjcsMS41YzAuMiwwLjYsMC4zLDEuMywwLjMsMi4xIGMwLDEuNC0wLjMsMi42LTAuOSwzLjRjLTAuMywwLjQtMC42LDAuOC0wLjksMS4yYy0wLjQsMC40LTAuOCwwLjctMS4yLDEuMWMtMC4yLDAuMi0wLjUsMC41LTAuNywwLjhjLTAuMiwwLjMtMC40LDAuNy0wLjQsMS4xIGMwLDAuNCwwLjEsMC44LDAuNCwxYzAuMiwwLjMsMC40LDAuNSwwLjYsMC43bDEuNCwxLjFjMC44LDAuNywxLjYsMS41LDIuMiwyLjNjMC42LDAuOCwwLjksMiwwLjksMy4zYzAsMS45LTAuOSwzLjctMi42LDUuMiBjLTEuOCwxLjYtNC4zLDIuNC03LjcsMi40Yy0yLjgsMC00LjktMC42LTYuMy0xLjhjLTEuNC0xLjEtMi4xLTIuNC0yLjEtMy45YzAtMC43LDAuMi0xLjYsMC43LTIuNWMwLjQtMC45LDEuMi0xLjcsMi40LTIuNCBjMS4zLTAuNywyLjctMS4yLDQuMS0xLjVjMS40LTAuMiwyLjYtMC4zLDMuNS0wLjRjLTAuMy0wLjQtMC41LTAuOC0wLjgtMS4yYy0wLjMtMC40LTAuNC0wLjktMC40LTEuNWMwLTAuNCwwLTAuNiwwLjItMC45IGMwLjEtMC4yLDAuMi0wLjUsMC4yLTAuN2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTIuMSwwLTMuOC0wLjctNC45LTJjLTEuMi0xLjItMS44LTIuNy0xLjgtNC4zYzAtMiwwLjgtMy44LDIuNS01LjQgYzEuMS0wLjksMi4zLTEuNiwzLjUtMS44YzEuMi0wLjIsMi4zLTAuNCwzLjQtMC40aDhMMzMsMTguNGgtMi41QzMwLjcsMTguNiwzMSwxOC44LDMxLjMsMTkuMXogTTQ4LDMyaC00LjN2NC4yaC0yLjVWMzJIMzd2LTIuNSBoNC4ydi00LjNoMi41djQuM0g0OFYzMnogTTI3LjEsMTkuMWMtMC42LTAuNS0xLjQtMC43LTIuMi0wLjdjLTEuMSwwLTIsMC41LTIuNywxLjNjLTAuNiwwLjktMC45LDEuOS0wLjksM2MwLDEuNSwwLjQsMywxLjMsNC41IGMwLjQsMC43LDAuOSwxLjQsMS42LDEuOWMwLjYsMC41LDEuNCwwLjgsMi4yLDAuOGMxLjEsMCwxLjktMC40LDIuNi0xLjFjMC4zLTAuNSwwLjYtMSwwLjctMS42YzAuMS0wLjUsMC4xLTEsMC4xLTEuNCBjMC0xLjYtMC40LTMuMi0xLjItNC44QzI4LjIsMjAuMiwyNy43LDE5LjUsMjcuMSwxOS4xeiBNMjYuOSwzNi4yYy0wLjIsMC0wLjcsMC0xLjYsMC4xYy0wLjgsMC4xLTEuNywwLjMtMi41LDAuNiBjLTAuMiwwLjEtMC41LDAuMi0wLjksMC40Yy0wLjQsMC4yLTAuNywwLjQtMS4xLDAuN2MtMC40LDAuMy0wLjcsMC43LTAuOSwxLjJjLTAuMywwLjUtMC40LDEuMS0wLjQsMS44YzAsMS40LDAuNiwyLjYsMS45LDMuNSBjMS4yLDAuOSwyLjksMS40LDUsMS40YzEuOSwwLDMuMy0wLjQsNC4zLTEuM2MxLTAuOCwxLjUtMS44LDEuNS0zLjFjMC0xLTAuMy0xLjktMS0yLjdjLTAuNy0wLjctMS44LTEuNi0zLjMtMi42IEMyNy41LDM2LjIsMjcuMiwzNi4yLDI2LjksMzYuMnpcIixcbiAgICBcImNvbG9yXCI6IFwiI2RkNGIzOVwiXG4gIH0sXG4gIFwiaW5zdGFncmFtXCI6IHtcbiAgICBcImljb25cIjogXCJNNDMuNSwyOS43aC0yLjZjMC4yLDAuNywwLjMsMS41LDAuMywyLjMgYzAsNS4xLTQuMSw5LjItOS4yLDkuMmMtNS4xLDAtOS4yLTQuMS05LjItOS4yYzAtMC44LDAuMS0xLjYsMC4zLTIuM2gtMi42djEyLjdjMCwwLjYsMC41LDEuMiwxLjIsMS4yaDIwLjhjMC42LDAsMS4yLTAuNSwxLjItMS4yIFYyOS43eiBNNDMuNSwyMS42YzAtMC42LTAuNS0xLjItMS4yLTEuMmgtMy41Yy0wLjYsMC0xLjIsMC41LTEuMiwxLjJ2My41YzAsMC42LDAuNSwxLjIsMS4yLDEuMmgzLjVjMC42LDAsMS4yLTAuNSwxLjItMS4yVjIxLjZ6ICBNMzIsMjYuMmMtMy4yLDAtNS44LDIuNi01LjgsNS44YzAsMy4yLDIuNiw1LjgsNS44LDUuOHM1LjgtMi42LDUuOC01LjhDMzcuOCwyOC44LDM1LjIsMjYuMiwzMiwyNi4yIE00My41LDQ3SDIwLjUgYy0xLjksMC0zLjUtMS42LTMuNS0zLjVWMjAuNWMwLTEuOSwxLjUtMy41LDMuNS0zLjVoMjMuMWMxLjksMCwzLjUsMS41LDMuNSwzLjV2MjMuMUM0Nyw0NS40LDQ1LjUsNDcsNDMuNSw0N1wiLFxuICAgIFwibWFza1wiOiBcIk00MS4yLDMyYzAsNS4xLTQuMSw5LjItOS4yLDkuMmMtNS4xLDAtOS4yLTQuMS05LjItOS4yYzAtMC44LDAuMS0xLjYsMC4zLTIuM2gtMi42djEyLjdjMCwwLjYsMC41LDEuMiwxLjIsMS4yIGgyMC44YzAuNiwwLDEuMi0wLjUsMS4yLTEuMlYyOS43aC0yLjZDNDEuMSwzMC40LDQxLjIsMzEuMiw0MS4yLDMyeiBNMzIsMzcuOGMzLjIsMCw1LjgtMi42LDUuOC01LjhjMC0zLjItMi42LTUuOC01LjgtNS44IGMtMy4yLDAtNS44LDIuNi01LjgsNS44QzI2LjIsMzUuMiwyOC44LDM3LjgsMzIsMzcuOHogTTQyLjQsMjAuNWgtMy41Yy0wLjYsMC0xLjIsMC41LTEuMiwxLjJ2My41YzAsMC42LDAuNSwxLjIsMS4yLDEuMmgzLjUgYzAuNiwwLDEuMi0wLjUsMS4yLTEuMnYtMy41QzQzLjUsMjEsNDMsMjAuNSw0Mi40LDIwLjV6IE0wLDB2NjRoNjRWMEgweiBNNDcsNDMuNWMwLDEuOS0xLjUsMy41LTMuNSwzLjVIMjAuNSBjLTEuOSwwLTMuNS0xLjYtMy41LTMuNVYyMC41YzAtMS45LDEuNS0zLjUsMy41LTMuNWgyMy4xYzEuOSwwLDMuNSwxLjUsMy41LDMuNVY0My41elwiLFxuICAgIFwiY29sb3JcIjogXCIjM2Y3MjliXCJcbiAgfSxcbiAgXCJpdHVuZXNcIjoge1xuICAgIFwiaWNvblwiOiBcIk00MS4xLDE3Yy0wLjEsMC0wLjIsMC0wLjMsMGwtMTQuNywzYy0wLjYsMC4xLTEuMSwwLjctMS4xLDEuNHYxNy42YzAsMC44LTAuNiwxLjQtMS40LDEuNCBoLTIuOGMtMS45LDAtMy40LDEuNS0zLjQsMy40YzAsMS45LDEuNSwzLjQsMy40LDMuNGgyYzIuMiwwLDQtMS44LDQtNFYyNy40YzAtMC40LDAuMy0wLjgsMC43LTAuOWwxMi4xLTIuNGMwLjEsMCwwLjEsMCwwLjIsMCBjMC41LDAsMC45LDAuNCwwLjksMC45djExYzAsMC44LTAuNiwxLjQtMS40LDEuNGgtMi44Yy0xLjksMC0zLjQsMS41LTMuNCwzLjRjMCwxLjksMS41LDMuNCwzLjQsMy40aDJjMi4yLDAsNC0xLjgsNC00VjE4LjQgQzQyLjUsMTcuNiw0MS45LDE3LDQxLjEsMTd6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE00Mi41LDQwYzAsMi4yLTEuOCw0LTQsNGgtMmMtMS45LDAtMy40LTEuNS0zLjQtMy40czEuNS0zLjQsMy40LTMuNGgyLjhjMC44LDAsMS40LTAuNiwxLjQtMS40IHYtMTFjMC0wLjUtMC40LTAuOS0wLjktMC45Yy0wLjEsMC0wLjEsMC0wLjIsMGwtMTIuMSwyLjRjLTAuNCwwLjEtMC43LDAuNC0wLjcsMC45VjQzYzAsMi4yLTEuOCw0LTQsNGgtMmMtMS45LDAtMy40LTEuNS0zLjQtMy40IGMwLTEuOSwxLjUtMy40LDMuNC0zLjRoMi44YzAuOCwwLDEuNC0wLjYsMS40LTEuNFYyMS4zYzAtMC43LDAuNS0xLjIsMS4xLTEuNGwxNC43LTNjMC4xLDAsMC4yLDAsMC4zLDBjMC44LDAsMS40LDAuNiwxLjQsMS40VjQwelwiLFxuICAgIFwiY29sb3JcIjogXCIjRTA0OUQxXCJcbiAgfSxcbiAgXCJsaW5rZWRpblwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTIwLjQsNDRoNS40VjI2LjZoLTUuNFY0NHogTTIzLjEsMThjLTEuNywwLTMuMSwxLjQtMy4xLDMuMWMwLDEuNywxLjQsMy4xLDMuMSwzLjEgYzEuNywwLDMuMS0xLjQsMy4xLTMuMUMyNi4yLDE5LjQsMjQuOCwxOCwyMy4xLDE4eiBNMzkuNSwyNi4yYy0yLjYsMC00LjQsMS40LTUuMSwyLjhoLTAuMXYtMi40aC01LjJWNDRoNS40di04LjYgYzAtMi4zLDAuNC00LjUsMy4yLTQuNWMyLjgsMCwyLjgsMi42LDIuOCw0LjZWNDRINDZ2LTkuNUM0NiwyOS44LDQ1LDI2LjIsMzkuNSwyNi4yelwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMjUuOCw0NGgtNS40VjI2LjZoNS40VjQ0eiBNMjMuMSwyNC4zYy0xLjcsMC0zLjEtMS40LTMuMS0zLjFjMC0xLjcsMS40LTMuMSwzLjEtMy4xIGMxLjcsMCwzLjEsMS40LDMuMSwzLjFDMjYuMiwyMi45LDI0LjgsMjQuMywyMy4xLDI0LjN6IE00Niw0NGgtNS40di04LjRjMC0yLDAtNC42LTIuOC00LjZjLTIuOCwwLTMuMiwyLjItMy4yLDQuNVY0NGgtNS40VjI2LjYgaDUuMlYyOWgwLjFjMC43LTEuNCwyLjUtMi44LDUuMS0yLjhjNS41LDAsNi41LDMuNiw2LjUsOC4zVjQ0elwiLFxuICAgIFwiY29sb3JcIjogXCIjMDA3ZmIxXCJcbiAgfSxcbiAgXCJtZWRpdW1cIjoge1xuICAgIFwiaWNvblwiOiBcIk00NywyMy43aC0xLjJjLTAuNCwwLTAuOSwwLjYtMC45LDF2MTQuN2MwLDAuNCwwLjUsMSwwLjksMUg0N3YzLjRIMzYuNHYtMy40aDIuMVYyNC45aC0wLjEgbC01LjMsMTguOWgtNC4xbC01LjItMTguOWgtMC4xdjE1LjVIMjZ2My40aC05di0zLjRoMS4yYzAuNSwwLDEtMC42LDEtMVYyNC43YzAtMC40LTAuNS0xLTEtMUgxN3YtMy42aDExLjNsMy43LDEzLjhoMC4xbDMuNy0xMy44IEg0N1YyMy43elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNNDcsMjMuN2gtMS4yYy0wLjQsMC0wLjksMC42LTAuOSwxdjE0LjdjMCwwLjQsMC41LDEsMC45LDFINDd2My40SDM2LjR2LTMuNGgyLjFWMjQuOWgtMC4xIGwtNS4zLDE4LjloLTQuMWwtNS4yLTE4LjloLTAuMXYxNS41SDI2djMuNGgtOXYtMy40aDEuMmMwLjUsMCwxLTAuNiwxLTFWMjQuN2MwLTAuNC0wLjUtMS0xLTFIMTd2LTMuNmgxMS4zbDMuNywxMy44aDAuMWwzLjctMTMuOCBINDdWMjMuN3pcIixcbiAgICBcImNvbG9yXCI6IFwiIzMzMzMzMlwiXG4gIH0sXG4gIFwibWVldHVwXCI6IHtcbiAgICBcImljb25cIjogXCJNMzAuOCwzMy40YzAtNi4zLDEuOS0xMS45LDMuNS0xNS4zYzAuNS0xLjEsMC45LTEuNCwxLjktMS40YzEuMywwLDIuOSwwLjIsNC4xLDAuNCBjMS4xLDAuMiwxLjUsMS42LDEuNywyLjVjMS4yLDQuNSw0LjcsMTguNyw1LjUsMjIuNGMwLjIsMC44LDAuNiwyLDAuMSwyLjNjLTAuNCwwLjItMi41LDAuOS0zLjksMWMtMC42LDAuMS0xLjEtMC42LTEuNC0xLjUgYy0xLjUtNC42LTMuNS0xMS44LTUuMi0xNi42YzAsMy43LTAuMywxMC44LTAuNCwxMmMtMC4xLDEuNy0wLjQsMy43LTEuOCwzLjljLTEuMSwwLjItMi40LDAuNC00LDAuNGMtMS4zLDAtMS44LTAuOS0yLjQtMS44IGMtMS0xLjQtMy4xLTQuOC00LjEtNi45YzAuMywyLjMsMC43LDQuNywwLjksNS44YzAuMSwwLjgsMCwxLjUtMC42LDEuOWMtMSwwLjctMy4yLDEuNC00LjEsMS40Yy0wLjgsMC0xLjUtMC44LTEuNi0xLjYgYy0wLjctMy40LTEuMi04LTEuMS0xMS4xYzAtMi44LDAtNS45LDAuMi04LjNjMC0wLjcsMC4zLTEuMSwwLjktMS40YzEuMi0wLjUsMy0wLjYsNC43LTAuM2MwLjgsMC4xLDEsMC44LDEuNCwxLjQgQzI2LjksMjUuNSwyOC45LDI5LjUsMzAuOCwzMy40elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNNDcuOCw0NC4zYy0wLjQsMC4yLTIuNSwwLjktMy45LDFjLTAuNiwwLjEtMS4xLTAuNi0xLjQtMS41Yy0xLjUtNC42LTMuNS0xMS44LTUuMi0xNi42IGMwLDMuNy0wLjMsMTAuOC0wLjQsMTJjLTAuMSwxLjctMC40LDMuNy0xLjgsMy45Yy0xLjEsMC4yLTIuNCwwLjQtNCwwLjRjLTEuMywwLTEuOC0wLjktMi40LTEuOGMtMS0xLjQtMy4xLTQuOC00LjEtNi45IGMwLjMsMi4zLDAuNyw0LjcsMC45LDUuOGMwLjEsMC44LDAsMS41LTAuNiwxLjljLTEsMC43LTMuMiwxLjQtNC4xLDEuNGMtMC44LDAtMS41LTAuOC0xLjYtMS42Yy0wLjctMy40LTEuMi04LTEuMS0xMS4xIGMwLTIuOCwwLTUuOSwwLjItOC4zYzAtMC43LDAuMy0xLjEsMC45LTEuNGMxLjItMC41LDMtMC42LDQuNy0wLjNjMC44LDAuMSwxLDAuOCwxLjQsMS40YzEuNywyLjgsMy44LDYuNyw1LjcsMTAuNiBjMC02LjMsMS45LTExLjksMy41LTE1LjNjMC41LTEuMSwwLjktMS40LDEuOS0xLjRjMS4zLDAsMi45LDAuMiw0LjEsMC40YzEuMSwwLjIsMS41LDEuNiwxLjcsMi41YzEuMiw0LjUsNC43LDE4LjcsNS41LDIyLjQgQzQ3LjgsNDIuOCw0OC4zLDQ0LDQ3LjgsNDQuM3pcIixcbiAgICBcImNvbG9yXCI6IFwiI0U1MTkzN1wiXG4gIH0sXG4gIFwibnBtXCI6IHtcbiAgICBcImljb25cIjogXCJNMTguOSwyMHYyNS42SDMyVjI1LjVoNy41VjQ2aDUuNlYyMEgxOC45elwiLFxuICAgIFwibWFza1wiOiBcIk02OCwwdjY4SDBWMEg2OHogTTE4LjksMjB2MjUuNkgzMlYyNS41aDcuNVY0Nmg1LjZWMjBIMTguOXpcIixcbiAgICBcImNvbG9yXCI6IFwiI2NiMzgzN1wiXG4gIH0sXG4gIFwicGludGVyZXN0XCI6IHtcbiAgICBcImljb25cIjogXCJNMzIsMTZjLTguOCwwLTE2LDcuMi0xNiwxNmMwLDYuNiwzLjksMTIuMiw5LjYsMTQuN2MwLTEuMSwwLTIuNSwwLjMtMy43IGMwLjMtMS4zLDIuMS04LjcsMi4xLTguN3MtMC41LTEtMC41LTIuNWMwLTIuNCwxLjQtNC4xLDMuMS00LjFjMS41LDAsMi4yLDEuMSwyLjIsMi40YzAsMS41LTAuOSwzLjctMS40LDUuNyBjLTAuNCwxLjcsMC45LDMuMSwyLjUsMy4xYzMsMCw1LjEtMy45LDUuMS04LjVjMC0zLjUtMi40LTYuMS02LjctNi4xYy00LjksMC03LjksMy42LTcuOSw3LjdjMCwxLjQsMC40LDIuNCwxLjEsMy4xIGMwLjMsMC4zLDAuMywwLjUsMC4yLDAuOWMtMC4xLDAuMy0wLjMsMS0wLjMsMS4zYy0wLjEsMC40LTAuNCwwLjYtMC44LDAuNGMtMi4yLTAuOS0zLjMtMy40LTMuMy02LjFjMC00LjUsMy44LTEwLDExLjQtMTAgYzYuMSwwLDEwLjEsNC40LDEwLjEsOS4yYzAsNi4zLTMuNSwxMS04LjYsMTFjLTEuNywwLTMuNC0wLjktMy45LTJjMCwwLTAuOSwzLjctMS4xLDQuNGMtMC4zLDEuMi0xLDIuNS0xLjYsMy40IGMxLjQsMC40LDMsMC43LDQuNSwwLjdjOC44LDAsMTYtNy4yLDE2LTE2QzQ4LDIzLjIsNDAuOCwxNiwzMiwxNnpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTMyLDQ4Yy0xLjYsMC0zLjEtMC4yLTQuNS0wLjdjMC42LTEsMS4zLTIuMiwxLjYtMy40YzAuMi0wLjcsMS4xLTQuNCwxLjEtNC40IGMwLjYsMS4xLDIuMiwyLDMuOSwyYzUuMSwwLDguNi00LjcsOC42LTExYzAtNC43LTQtOS4yLTEwLjEtOS4yYy03LjYsMC0xMS40LDUuNS0xMS40LDEwYzAsMi44LDEsNS4yLDMuMyw2LjEgYzAuNCwwLjEsMC43LDAsMC44LTAuNGMwLjEtMC4zLDAuMi0xLDAuMy0xLjNjMC4xLTAuNCwwLjEtMC41LTAuMi0wLjljLTAuNi0wLjgtMS4xLTEuNy0xLjEtMy4xYzAtNCwzLTcuNyw3LjktNy43IGM0LjMsMCw2LjcsMi42LDYuNyw2LjFjMCw0LjYtMiw4LjUtNS4xLDguNWMtMS43LDAtMi45LTEuNC0yLjUtMy4xYzAuNS0yLDEuNC00LjIsMS40LTUuN2MwLTEuMy0wLjctMi40LTIuMi0yLjQgYy0xLjcsMC0zLjEsMS44LTMuMSw0LjFjMCwxLjUsMC41LDIuNSwwLjUsMi41cy0xLjgsNy40LTIuMSw4LjdjLTAuMywxLjItMC4zLDIuNi0wLjMsMy43QzE5LjksNDQuMiwxNiwzOC42LDE2LDMyIGMwLTguOCw3LjItMTYsMTYtMTZjOC44LDAsMTYsNy4yLDE2LDE2QzQ4LDQwLjgsNDAuOCw0OCwzMiw0OHpcIixcbiAgICBcImNvbG9yXCI6IFwiI2NiMjEyOFwiXG4gIH0sXG4gIFwicmRpb1wiOiB7XG4gICAgXCJpY29uXCI6IFwiTTQ3LjMsMjUuN2MtMy4yLDAuMS03LjEtMi40LTguNy0zLjRjLTAuMS0wLjEtMC4zLTAuMi0wLjQtMC4yYy0wLjItMC4xLTAuMy0wLjItMC41LTAuM3Y5LjNoMCBjMCwwLjgtMC4yLDEuNy0wLjgsMi42bDAsMC4xYy0xLjUsMi40LTQuNywzLjktNy43LDIuOWMtMi45LTEtMy43LTMuOC0yLjEtNi4zbDAtMC4xYzEuNS0yLjQsNC43LTMuOSw3LjctMi45IGMwLjIsMC4xLDAuNCwwLjIsMC42LDAuM3YtNi44Yy0xLjEtMC4zLTIuMi0wLjUtMy40LTAuNWMtNi45LDAtMTIsNS4yLTEyLDExLjZ2MC4xYzAsNi40LDUuMSwxMS41LDEyLDExLjVjNi45LDAsMTItNS4yLDEyLTExLjYgdi0wLjFjMC0wLjUsMC0xLTAuMS0xLjVDNDcuNSwyOS41LDQ5LDI1LjgsNDcuMywyNS43elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNNDMuOSwzMC41YzAuMSwwLjUsMC4xLDEsMC4xLDEuNVYzMmMwLDYuNC01LjEsMTEuNi0xMiwxMS42Yy02LjksMC0xMi01LjEtMTItMTEuNVYzMiBjMC02LjQsNS4xLTExLjYsMTItMTEuNmMxLjIsMCwyLjMsMC4yLDMuNCwwLjV2Ni44Yy0wLjItMC4xLTAuNC0wLjItMC42LTAuM2MtMy0xLTYuMiwwLjQtNy43LDIuOWwwLDAuMWMtMS41LDIuNS0wLjgsNS4zLDIuMSw2LjMgYzMsMSw2LjItMC40LDcuNy0yLjlsMC0wLjFjMC41LTAuOCwwLjgtMS43LDAuOC0yLjZoMHYtOS4zYzAuMiwwLjEsMC4zLDAuMiwwLjUsMC4zYzAuMSwwLjEsMC4zLDAuMiwwLjQsMC4yYzEuNSwxLDUuNCwzLjUsOC43LDMuNCBDNDksMjUuOCw0Ny41LDI5LjUsNDMuOSwzMC41elwiLFxuICAgIFwiY29sb3JcIjogXCIjMDQ3NUM1XCJcbiAgfSxcbiAgXCJyc3NcIjoge1xuICAgIFwiaWNvblwiOiBcIk0yNCwzNmMtMi4yLDAtNCwxLjgtNCw0YzAsMi4yLDEuOCw0LDQsNHM0LTEuOCw0LTRDMjgsMzcuOCwyNi4yLDM2LDI0LDM2eiBNMjMsMTggYy0xLjEsMC0yLDAuOS0yLDJzMC45LDIsMiwyYzEwLjUsMCwxOSw4LjUsMTksMTljMCwxLjEsMC45LDIsMiwyczItMC45LDItMkM0NiwyOC4zLDM1LjcsMTgsMjMsMTh6IE0yMywyN2MtMS4xLDAtMiwwLjktMiwyIHMwLjksMiwyLDJjNS41LDAsMTAsNC41LDEwLDEwYzAsMS4xLDAuOSwyLDIsMnMyLTAuOSwyLTJDMzcsMzMuMywzMC43LDI3LDIzLDI3elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMjQsNDRjLTIuMiwwLTQtMS44LTQtNGMwLTIuMiwxLjgtNCw0LTRzNCwxLjgsNCw0QzI4LDQyLjIsMjYuMiw0NCwyNCw0NHogTTM1LDQzIGMtMS4xLDAtMi0wLjktMi0yYzAtNS41LTQuNS0xMC0xMC0xMGMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMmM3LjcsMCwxNCw2LjMsMTQsMTRDMzcsNDIuMSwzNi4xLDQzLDM1LDQzeiBNNDQsNDMgYy0xLjEsMC0yLTAuOS0yLTJjMC0xMC41LTguNS0xOS0xOS0xOWMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMmMxMi43LDAsMjMsMTAuMywyMywyM0M0Niw0Mi4xLDQ1LjEsNDMsNDQsNDN6XCIsXG4gICAgXCJjb2xvclwiOiBcIiNFRjg3MzNcIlxuICB9LFxuICBcInNoYXJldGhpc1wiOiB7XG4gICAgXCJpY29uXCI6IFwiTTI4LjM4NzUsMzIuMDAwMUMyOC4zODc1LDMyLjA4NDMgMjguMzY4MywzMi4xNjMyIDI4LjM2MzMsMzIuMjQ3MUwzNy4xNjQ3LDM2LjY0NjRDMzcuOTE4MiwzNi4wMDgzIDM4Ljg4MjMsMzUuNjEgMzkuOTQ3NCwzNS42MUM0Mi4zNDE4LDM1LjYxMDUgNDQuMjgyMSwzNy41NTA5IDQ0LjI4MjEsMzkuOTQ1QzQ0LjI4MjEsNDIuMzQxOCA0Mi4zNDE3LDQ0LjI4MjEgMzkuOTQ3NCw0NC4yODIxQzM3LjU1MSw0NC4yODIxIDM1LjYxMjcsNDIuMzQxNyAzNS42MTI3LDM5Ljk0NUMzNS42MTI3LDM5Ljg1ODcgMzUuNjMxOSwzOS43ODE2IDM1LjYzNjcsMzkuNjk4TDI2LjgzNTMsMzUuMjk4NEMyNi4wNzk1LDM1LjkzNDEgMjUuMTE3NywzNi4zMzI0IDI0LjA1MjYsMzYuMzMyNEMyMS42NTg0LDM2LjMzMjQgMTkuNzE3OSwzNC4zOTQxIDE5LjcxNzksMzIuMDAwMUMxOS43MTc5LDI5LjYwMzYgMjEuNjU4NCwyNy42NjI4IDI0LjA1MjYsMjcuNjYyOEMyNS4xMTc2LDI3LjY2MjggMjYuMDc5OCwyOC4wNjM1IDI2LjgzNTMsMjguNjk5MkwzNS42MzY3LDI0LjI5OTdDMzUuNjMxOSwyNC4yMTU2IDM1LjYxMjcsMjQuMTM2NSAzNS42MTI3LDI0LjA1MDJDMzUuNjEyNywyMS42NTg0IDM3LjU1MSwxOS43MTc5IDM5Ljk0NzQsMTkuNzE3OUM0Mi4zNDE4LDE5LjcxNzkgNDQuMjgyMSwyMS42NTg0IDQ0LjI4MjEsMjQuMDUwMkM0NC4yODIxLDI2LjQ0NjYgNDIuMzQxNywyOC4zODc1IDM5Ljk0NzQsMjguMzg3NUMzOC44OCwyOC4zODc1IDM3LjkxNzgsMjcuOTg2OCAzNy4xNjQ3LDI3LjM0ODdMMjguMzYzMywzMS43NTA2QzI4LjM2OCwzMS44MzQ3IDI4LjM4NzUsMzEuOTEzOCAyOC4zODc1LDMyLjAwMDFaXCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMEw2NCwwTDY0LDY0TDAsNjRMMCwwWk0yOC4zODc1LDMyLjAwMDFDMjguMzg3NSwzMi4wODQzIDI4LjM2ODMsMzIuMTYzMiAyOC4zNjMzLDMyLjI0NzFMMzcuMTY0NywzNi42NDY0QzM3LjkxODIsMzYuMDA4MyAzOC44ODIzLDM1LjYxIDM5Ljk0NzQsMzUuNjFDNDIuMzQxOCwzNS42MTA1IDQ0LjI4MjEsMzcuNTUwOSA0NC4yODIxLDM5Ljk0NUM0NC4yODIxLDQyLjM0MTggNDIuMzQxNyw0NC4yODIxIDM5Ljk0NzQsNDQuMjgyMUMzNy41NTEsNDQuMjgyMSAzNS42MTI3LDQyLjM0MTcgMzUuNjEyNywzOS45NDVDMzUuNjEyNywzOS44NTg3IDM1LjYzMTksMzkuNzgxNiAzNS42MzY3LDM5LjY5OEwyNi44MzUzLDM1LjI5ODRDMjYuMDc5NSwzNS45MzQxIDI1LjExNzcsMzYuMzMyNCAyNC4wNTI2LDM2LjMzMjRDMjEuNjU4NCwzNi4zMzI0IDE5LjcxNzksMzQuMzk0MSAxOS43MTc5LDMyLjAwMDFDMTkuNzE3OSwyOS42MDM2IDIxLjY1ODQsMjcuNjYyOCAyNC4wNTI2LDI3LjY2MjhDMjUuMTE3NiwyNy42NjI4IDI2LjA3OTgsMjguMDYzNSAyNi44MzUzLDI4LjY5OTJMMzUuNjM2NywyNC4yOTk3QzM1LjYzMTksMjQuMjE1NiAzNS42MTI3LDI0LjEzNjUgMzUuNjEyNywyNC4wNTAyQzM1LjYxMjcsMjEuNjU4NCAzNy41NTEsMTkuNzE3OSAzOS45NDc0LDE5LjcxNzlDNDIuMzQxOCwxOS43MTc5IDQ0LjI4MjEsMjEuNjU4NCA0NC4yODIxLDI0LjA1MDJDNDQuMjgyMSwyNi40NDY2IDQyLjM0MTcsMjguMzg3NSAzOS45NDc0LDI4LjM4NzVDMzguODgsMjguMzg3NSAzNy45MTc4LDI3Ljk4NjggMzcuMTY0NywyNy4zNDg3TDI4LjM2MzMsMzEuNzUwNkMyOC4zNjgsMzEuODM0NyAyOC4zODc1LDMxLjkxMzggMjguMzg3NSwzMi4wMDAxWlwiLFxuICAgIFwiY29sb3JcIjogXCIjMDBCRjAwXCJcbiAgfSxcbiAgXCJzbXVnbXVnXCI6IHtcbiAgICBcImljb25cIjogXCJNMjUuNCwyMi45YzIuOCwwLDQuMS0xLjcsMy45LTMuMSBjLTAuMS0xLjItMS4zLTIuNC0zLjYtMi40Yy0xLjksMC0zLjEsMS40LTMuMywyLjhDMjIuMywyMS42LDIzLjEsMjMsMjUuNCwyMi45eiBNMzkuMiwyMi42YzIuNi0wLjEsMy44LTEuNSwzLjgtMi44IGMwLTEuNS0xLjQtMy0zLjgtMi44Yy0xLjksMC4yLTMsMS41LTMuMiwyLjhDMzUuOSwyMS4zLDM2LjksMjIuNywzOS4yLDIyLjZ6IE00MC45LDI4LjVjLTYuNiwwLjctNi45LDAuNy0xOSwxIGMtNS4xLDAtNCwxNy41LDYuOSwxNy41QzM5LjIsNDcsNTEuNywyNy40LDQwLjksMjguNXogTTI5LDQzLjljLTkuNSwwLTguMi0xMS4zLTYuNi0xMS40YzExLjEtMC40LDEzLjktMC45LDE3LjgtMC45IEM0NC4zLDMxLjYsMzYuNiw0My45LDI5LDQzLjl6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE0zNi4xLDE5LjhjMC4yLTEuMywxLjMtMi42LDMuMi0yLjhjMi40LTAuMiwzLjgsMS4zLDMuOCwyLjhjMCwxLjMtMS4yLDIuNi0zLjgsMi44IEMzNi45LDIyLjcsMzUuOSwyMS4zLDM2LjEsMTkuOHogTTIyLjUsMjAuMmMwLjItMS40LDEuNC0yLjgsMy4zLTIuOGMyLjMsMCwzLjUsMS4xLDMuNiwyLjRjMC4yLDEuNS0xLjEsMy4xLTMuOSwzLjEgQzIzLjEsMjMsMjIuMywyMS42LDIyLjUsMjAuMnogTTI4LjgsNDdjLTEwLjksMC0xMi0xNy41LTYuOS0xNy41YzEyLjEtMC4zLDEyLjUtMC4zLDE5LTFDNTEuNywyNy40LDM5LjIsNDcsMjguOCw0N3ogTTQwLjMsMzEuNiBjLTMuOSwwLTYuOCwwLjUtMTcuOCwwLjljLTEuNiwwLjEtMi45LDExLjQsNi42LDExLjRDMzYuNiw0My45LDQ0LjMsMzEuNiw0MC4zLDMxLjZ6XCIsXG4gICAgXCJjb2xvclwiOiBcIiM4Y2NhMWVcIlxuICB9LFxuICBcInNvdW5kY2xvdWRcIjoge1xuICAgIFwiaWNvblwiOiBcIk00My42LDMwYy0wLjYsMC0xLjIsMC4xLTEuNywwLjNjLTAuMy00LTMuNy03LjEtNy43LTcuMWMtMSwwLTIsMC4yLTIuOCwwLjUgQzMxLjEsMjMuOSwzMSwyNCwzMSwyNC4zdjEzLjljMCwwLjMsMC4yLDAuNSwwLjUsMC41YzAsMCwxMi4yLDAsMTIuMiwwYzIuNCwwLDQuNC0xLjksNC40LTQuNEM0OCwzMS45LDQ2LDMwLDQzLjYsMzB6IE0yNy4yLDI1LjEgYy0wLjcsMC0xLjIsMC41LTEuMiwxLjF2MTEuM2MwLDAuNywwLjYsMS4yLDEuMiwxLjJjMC43LDAsMS4yLTAuNiwxLjItMS4yVjI2LjJDMjguNCwyNS42LDI3LjgsMjUuMSwyNy4yLDI1LjF6IE0yMi4yLDI3LjggYy0wLjcsMC0xLjIsMC41LTEuMiwxLjF2OC41YzAsMC43LDAuNiwxLjIsMS4yLDEuMnMxLjItMC42LDEuMi0xLjJWMjlDMjMuNCwyOC4zLDIyLjksMjcuOCwyMi4yLDI3Ljh6IE0xNy4yLDMwLjIgYy0wLjcsMC0xLjIsMC41LTEuMiwxLjF2NC45YzAsMC43LDAuNiwxLjIsMS4yLDEuMmMwLjcsMCwxLjItMC42LDEuMi0xLjJ2LTQuOUMxOC41LDMwLjcsMTcuOSwzMC4yLDE3LjIsMzAuMnpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTE4LjUsMzYuM2MwLDAuNy0wLjYsMS4yLTEuMiwxLjJjLTAuNywwLTEuMi0wLjYtMS4yLTEuMnYtNC45YzAtMC42LDAuNi0xLjEsMS4yLTEuMSBjMC43LDAsMS4yLDAuNSwxLjIsMS4xVjM2LjN6IE0yMy40LDM3LjVjMCwwLjctMC42LDEuMi0xLjIsMS4yUzIxLDM4LjIsMjEsMzcuNVYyOWMwLTAuNiwwLjYtMS4xLDEuMi0xLjFzMS4yLDAuNSwxLjIsMS4xVjM3LjV6ICBNMjguNCwzNy41YzAsMC43LTAuNiwxLjItMS4yLDEuMmMtMC43LDAtMS4yLTAuNi0xLjItMS4yVjI2LjJjMC0wLjYsMC42LTEuMSwxLjItMS4xYzAuNywwLDEuMiwwLjUsMS4yLDEuMVYzNy41eiBNNDMuNiwzOC43IGMwLDAtMTIuMSwwLTEyLjIsMGMtMC4zLDAtMC41LTAuMi0wLjUtMC41VjI0LjNjMC0wLjMsMC4xLTAuNCwwLjQtMC41YzAuOS0wLjMsMS44LTAuNSwyLjgtMC41YzQsMCw3LjQsMy4xLDcuNyw3LjEgYzAuNS0wLjIsMS4xLTAuMywxLjctMC4zYzIuNCwwLDQuNCwyLDQuNCw0LjRDNDgsMzYuOCw0NiwzOC43LDQzLjYsMzguN3pcIixcbiAgICBcImNvbG9yXCI6IFwiI0ZGNTcwMFwiXG4gIH0sXG4gIFwic3BvdGlmeVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTMyLDE2Yy04LjgsMC0xNiw3LjItMTYsMTZjMCw4LjgsNy4yLDE2LDE2LDE2YzguOCwwLDE2LTcuMiwxNi0xNkM0OCwyMy4yLDQwLjgsMTYsMzIsMTYgTTM5LjMsMzkuMWMtMC4zLDAuNS0wLjksMC42LTEuNCwwLjNjLTMuOC0yLjMtOC41LTIuOC0xNC4xLTEuNWMtMC41LDAuMS0xLjEtMC4yLTEuMi0wLjdjLTAuMS0wLjUsMC4yLTEuMSwwLjgtMS4yIGM2LjEtMS40LDExLjMtMC44LDE1LjUsMS44QzM5LjUsMzgsMzkuNiwzOC42LDM5LjMsMzkuMSBNNDEuMywzNC43Yy0wLjQsMC42LTEuMSwwLjgtMS43LDAuNGMtNC4zLTIuNi0xMC45LTMuNC0xNS45LTEuOSBjLTAuNywwLjItMS40LTAuMi0xLjYtMC44Yy0wLjItMC43LDAuMi0xLjQsMC44LTEuNmM1LjgtMS44LDEzLTAuOSwxOCwyLjFDNDEuNSwzMy40LDQxLjcsMzQuMSw0MS4zLDM0LjcgTTQxLjUsMzAuMiBjLTUuMi0zLjEtMTMuNy0zLjMtMTguNi0xLjljLTAuOCwwLjItMS42LTAuMi0xLjktMWMtMC4yLTAuOCwwLjItMS42LDEtMS45YzUuNy0xLjcsMTUtMS40LDIxLDIuMWMwLjcsMC40LDAuOSwxLjMsMC41LDIuMSBDNDMuMSwzMC40LDQyLjIsMzAuNiw0MS41LDMwLjJcIixcbiAgICBcIm1hc2tcIjogXCJNMzksMzcuN2MtNC4yLTIuNi05LjQtMy4yLTE1LjUtMS44Yy0wLjUsMC4xLTAuOSwwLjctMC44LDEuMmMwLjEsMC41LDAuNywwLjksMS4yLDAuN2M1LjYtMS4zLDEwLjMtMC44LDE0LjEsMS41IGMwLjUsMC4zLDEuMSwwLjEsMS40LTAuM0MzOS42LDM4LjYsMzkuNSwzOCwzOSwzNy43eiBNNDAuOSwzM2MtNC45LTMtMTIuMi0zLjktMTgtMi4xYy0wLjcsMC4yLTEsMC45LTAuOCwxLjYgYzAuMiwwLjcsMC45LDEsMS42LDAuOGM1LjEtMS41LDExLjYtMC44LDE1LjksMS45YzAuNiwwLjQsMS40LDAuMiwxLjctMC40QzQxLjcsMzQuMSw0MS41LDMzLjQsNDAuOSwzM3ogTTAsMHY2NGg2NFYwSDB6IE0zMiw0OCBjLTguOCwwLTE2LTcuMi0xNi0xNmMwLTguOCw3LjItMTYsMTYtMTZjOC44LDAsMTYsNy4yLDE2LDE2QzQ4LDQwLjgsNDAuOCw0OCwzMiw0OHogTTQzLDI3LjZjLTUuOS0zLjUtMTUuMy0zLjktMjEtMi4xIGMtMC44LDAuMi0xLjIsMS4xLTEsMS45YzAuMiwwLjgsMS4xLDEuMiwxLjksMWM0LjktMS41LDEzLjQtMS4yLDE4LjYsMS45YzAuNywwLjQsMS42LDAuMiwyLjEtMC41QzQzLjksMjksNDMuNywyOCw0MywyNy42elwiLFxuICAgIFwiY29sb3JcIjogXCIjMkVCRDU5XCJcbiAgfSxcbiAgXCJzcXVhcmVzcGFjZVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTQ2LjIsMjcuNmMtMi40LTIuNC02LjMtMi40LTguNywwbC05LjgsOS44Yy0wLjYsMC42LTAuNiwxLjYsMCwyLjJjMC42LDAuNiwxLjYsMC42LDIuMiwwIGw5LjgtOS44YzEuMi0xLjIsMy4yLTEuMiw0LjQsMGMxLjIsMS4yLDEuMiwzLjIsMCw0LjRsLTkuNiw5LjZjMS4yLDEuMiwzLjIsMS4yLDQuNCwwbDcuNS03LjVDNDguNiwzNCw0OC42LDMwLDQ2LjIsMjcuNnogIE00Mi45LDMwLjljLTAuNi0wLjYtMS42LTAuNi0yLjIsMGwtOS44LDkuOGMtMS4yLDEuMi0zLjIsMS4yLTQuNCwwYy0wLjYtMC42LTEuNi0wLjYtMi4yLDBjLTAuNiwwLjYtMC42LDEuNiwwLDIuMiBjMi40LDIuNCw2LjMsMi40LDguNywwbDkuOC05LjhDNDMuNSwzMi41LDQzLjUsMzEuNSw0Mi45LDMwLjl6IE0zOS42LDIxLjFjLTIuNC0yLjQtNi4zLTIuNC04LjcsMGwtOS44LDkuOGMtMC42LDAuNi0wLjYsMS42LDAsMi4yIGMwLjYsMC42LDEuNiwwLjYsMi4yLDBsOS44LTkuOGMxLjItMS4yLDMuMi0xLjIsNC40LDBjMC42LDAuNiwxLjYsMC42LDIuMiwwQzQwLjIsMjIuNyw0MC4yLDIxLjcsMzkuNiwyMS4xeiBNMzYuNCwyNC40IGMtMC42LTAuNi0xLjYtMC42LTIuMiwwbC05LjgsOS44Yy0xLjIsMS4yLTMuMiwxLjItNC40LDBjLTEuMi0xLjItMS4yLTMuMiwwLTQuNGw5LjYtOS42Yy0xLjItMS4yLTMuMi0xLjItNC40LDBsLTcuNSw3LjUgYy0yLjQsMi40LTIuNCw2LjMsMCw4LjdjMi40LDIuNCw2LjMsMi40LDguNywwbDkuOC05LjhDMzcsMjUuOSwzNywyNSwzNi40LDI0LjR6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE0zOS42LDIxLjFjMC42LDAuNiwwLjYsMS42LDAsMi4yYy0wLjYsMC42LTEuNiwwLjYtMi4yLDBjLTEuMi0xLjItMy4yLTEuMi00LjQsMGwtOS44LDkuOCBjLTAuNiwwLjYtMS42LDAuNi0yLjIsMGMtMC42LTAuNi0wLjYtMS42LDAtMi4ybDkuOC05LjhDMzMuMywxOC43LDM3LjIsMTguNywzOS42LDIxLjF6IE0xNy44LDM2LjRjLTIuNC0yLjQtMi40LTYuMywwLTguN2w3LjUtNy41IGMxLjItMS4yLDMuMi0xLjIsNC40LDBMMjAsMjkuOGMtMS4yLDEuMi0xLjIsMy4yLDAsNC40YzEuMiwxLjIsMy4yLDEuMiw0LjQsMGw5LjgtOS44YzAuNi0wLjYsMS42LTAuNiwyLjIsMGMwLjYsMC42LDAuNiwxLjYsMCwyLjIgbC05LjgsOS44QzI0LjEsMzguOCwyMC4yLDM4LjgsMTcuOCwzNi40eiBNMjQuNCw0Mi45Yy0wLjYtMC42LTAuNi0xLjYsMC0yLjJjMC42LTAuNiwxLjYtMC42LDIuMiwwYzEuMiwxLjIsMy4yLDEuMiw0LjQsMGw5LjgtOS44IGMwLjYtMC42LDEuNi0wLjYsMi4yLDBjMC42LDAuNiwwLjYsMS42LDAsMi4ybC05LjgsOS44QzMwLjcsNDUuMywyNi44LDQ1LjMsMjQuNCw0Mi45eiBNNDYuMiwzNi40bC03LjUsNy41Yy0xLjIsMS4yLTMuMiwxLjItNC40LDAgbDkuNi05LjZjMS4yLTEuMiwxLjItMy4yLDAtNC40Yy0xLjItMS4yLTMuMi0xLjItNC40LDBsLTkuOCw5LjhjLTAuNiwwLjYtMS42LDAuNi0yLjIsMGMtMC42LTAuNi0wLjYtMS42LDAtMi4ybDkuOC05LjggYzIuNC0yLjQsNi4zLTIuNCw4LjcsMEM0OC42LDMwLDQ4LjYsMzQsNDYuMiwzNi40elwiLFxuICAgIFwiY29sb3JcIjogXCIjMUMxQzFDXCJcbiAgfSxcbiAgXCJ0dW1ibHJcIjoge1xuICAgIFwiaWNvblwiOiBcIk0zOS4yLDQxYy0wLjYsMC4zLTEuNiwwLjUtMi40LDAuNWMtMi40LDAuMS0yLjktMS43LTIuOS0zdi05LjNoNnYtNC41aC02VjE3YzAsMC00LjMsMC00LjQsMCBjLTAuMSwwLTAuMiwwLjEtMC4yLDAuMmMtMC4zLDIuMy0xLjQsNi40LTUuOSw4LjF2My45aDNWMzljMCwzLjQsMi41LDguMSw5LDhjMi4yLDAsNC43LTEsNS4yLTEuOEwzOS4yLDQxelwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMzUuNCw0N2MtNi41LDAuMS05LTQuNy05LTh2LTkuOGgtM3YtMy45YzQuNi0xLjYsNS42LTUuNyw1LjktOC4xYzAtMC4yLDAuMS0wLjIsMC4yLTAuMiBjMC4xLDAsNC40LDAsNC40LDB2Ny42aDZ2NC41aC02djkuM2MwLDEuMywwLjUsMywyLjksM2MwLjgsMCwxLjktMC4zLDIuNC0wLjVsMS40LDQuM0M0MC4xLDQ2LDM3LjYsNDcsMzUuNCw0N3pcIixcbiAgICBcImNvbG9yXCI6IFwiIzJjNDc2MlwiXG4gIH0sXG4gIFwidHdpdGNoXCI6IHtcbiAgICBcImljb25cIjogXCJNNDAsMjUuNmgtMi41djcuNkg0MFYyNS42eiBNMzMsMjUuNmgtMi41djcuNkgzM1YyNS42eiBNMjAuOSwxOEwxOSwyMy4xdjIwLjRoN3YzLjhoMy44bDMuOC0zLjhoNS43bDcuNi03LjZWMThIMjAuOXogTTQ0LjUsMzQuNUw0MCwzOWgtN2wtMy44LDMuOFYzOWgtNS43VjIwLjVoMjFWMzQuNXpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTQ3LDM1LjhsLTcuNiw3LjZoLTUuN2wtMy44LDMuOEgyNnYtMy44aC03VjIzLjFsMS45LTUuMUg0N1YzNS44eiBNMjkuMiw0Mi44TDMzLDM5aDdsNC41LTQuNSB2LTE0aC0yMVYzOWg1LjdWNDIuOHogTTM3LjUsMjUuNkg0MHY3LjZoLTIuNVYyNS42eiBNMzAuNSwyNS42SDMzdjcuNmgtMi41VjI1LjZ6XCIsXG4gICAgXCJjb2xvclwiOiBcIiM2NDQxQTVcIlxuICB9LFxuICBcInR3aXR0ZXJcIjoge1xuICAgIFwiaWNvblwiOiBcIk00OCwyMi4xYy0xLjIsMC41LTIuNCwwLjktMy44LDFjMS40LTAuOCwyLjQtMi4xLDIuOS0zLjZjLTEuMywwLjgtMi43LDEuMy00LjIsMS42IEM0MS43LDE5LjgsNDAsMTksMzguMiwxOWMtMy42LDAtNi42LDIuOS02LjYsNi42YzAsMC41LDAuMSwxLDAuMiwxLjVjLTUuNS0wLjMtMTAuMy0yLjktMTMuNS02LjljLTAuNiwxLTAuOSwyLjEtMC45LDMuMyBjMCwyLjMsMS4yLDQuMywyLjksNS41Yy0xLjEsMC0yLjEtMC4zLTMtMC44YzAsMCwwLDAuMSwwLDAuMWMwLDMuMiwyLjMsNS44LDUuMyw2LjRjLTAuNiwwLjEtMS4xLDAuMi0xLjcsMC4yYy0wLjQsMC0wLjgsMC0xLjItMC4xIGMwLjgsMi42LDMuMyw0LjUsNi4xLDQuNmMtMi4yLDEuOC01LjEsMi44LTguMiwyLjhjLTAuNSwwLTEuMSwwLTEuNi0wLjFjMi45LDEuOSw2LjQsMi45LDEwLjEsMi45YzEyLjEsMCwxOC43LTEwLDE4LjctMTguNyBjMC0wLjMsMC0wLjYsMC0wLjhDNDYsMjQuNSw0Ny4xLDIzLjQsNDgsMjIuMXpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTQ0LjcsMjUuNWMwLDAuMywwLDAuNiwwLDAuOEM0NC43LDM1LDM4LjEsNDUsMjYuMSw0NWMtMy43LDAtNy4yLTEuMS0xMC4xLTIuOSBjMC41LDAuMSwxLDAuMSwxLjYsMC4xYzMuMSwwLDUuOS0xLDguMi0yLjhjLTIuOS0wLjEtNS4zLTItNi4xLTQuNmMwLjQsMC4xLDAuOCwwLjEsMS4yLDAuMWMwLjYsMCwxLjItMC4xLDEuNy0wLjIgYy0zLTAuNi01LjMtMy4zLTUuMy02LjRjMCwwLDAtMC4xLDAtMC4xYzAuOSwwLjUsMS45LDAuOCwzLDAuOGMtMS44LTEuMi0yLjktMy4yLTIuOS01LjVjMC0xLjIsMC4zLTIuMywwLjktMy4zIGMzLjIsNCw4LjEsNi42LDEzLjUsNi45Yy0wLjEtMC41LTAuMi0xLTAuMi0xLjVjMC0zLjYsMi45LTYuNiw2LjYtNi42YzEuOSwwLDMuNiwwLjgsNC44LDIuMWMxLjUtMC4zLDIuOS0wLjgsNC4yLTEuNiBjLTAuNSwxLjUtMS41LDIuOC0yLjksMy42YzEuMy0wLjIsMi42LTAuNSwzLjgtMUM0Ny4xLDIzLjQsNDYsMjQuNSw0NC43LDI1LjV6XCIsXG4gICAgXCJjb2xvclwiOiBcIiMwMGFjZWRcIlxuICB9LFxuICBcInZldm9cIjoge1xuICAgIFwiaWNvblwiOiBcIk00MywyMWMtNC41LDAtNS40LDIuNy02LjgsNC42YzAsMC0zLjcsNS42LTUuMSw3LjdsLTMtMTIuM0gyMGw1LjEsMjAuNmMxLjEsMy43LDQuMSwzLjQsNC4xLDMuNCBjMi4xLDAsMy42LTEuMSw1LTMuMUw0OCwyMUM0OCwyMSw0My4yLDIxLDQzLDIxelwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMzQuMiw0MS45Yy0xLjQsMi4xLTIuOSwzLjEtNSwzLjFjMCwwLTMsMC4yLTQuMS0zLjRMMjAsMjFoOC4xbDMsMTIuM2MxLjQtMi4xLDUuMS03LjcsNS4xLTcuNyBjMS40LTEuOSwyLjItNC42LDYuOC00LjZjMC4yLDAsNSwwLDUsMEwzNC4yLDQxLjl6XCIsXG4gICAgXCJjb2xvclwiOiBcIiNFRDFBM0JcIlxuICB9LFxuICBcInZpbWVvXCI6IHtcbiAgICBcImljb25cIjogXCJNNDcsMjVjLTAuMSwyLjktMi4yLDYuOS02LjEsMTJjLTQuMSw1LjMtNy41LDgtMTAuNCw4Yy0xLjcsMC0zLjItMS42LTQuNC00LjggYy0wLjgtMy0xLjYtNS45LTIuNC04LjljLTAuOS0zLjItMS45LTQuOC0yLjktNC44Yy0wLjIsMC0xLDAuNS0yLjQsMS40TDE3LDI2YzEuNS0xLjMsMi45LTIuNiw0LjQtMy45YzItMS43LDMuNS0yLjYsNC40LTIuNyBjMi4zLTAuMiwzLjgsMS40LDQuMyw0LjhjMC42LDMuNywxLDYsMS4yLDYuOWMwLjcsMy4xLDEuNCw0LjYsMi4yLDQuNmMwLjYsMCwxLjYtMSwyLjgtM2MxLjMtMiwxLjktMy41LDItNC41IGMwLjItMS43LTAuNS0yLjYtMi0yLjZjLTAuNywwLTEuNSwwLjItMi4yLDAuNWMxLjUtNC44LDQuMy03LjIsOC40LTdDNDUuNywxOS4xLDQ3LjIsMjEuMSw0NywyNXpcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTQwLjksMzdjLTQuMSw1LjMtNy41LDgtMTAuNCw4Yy0xLjcsMC0zLjItMS42LTQuNC00LjhjLTAuOC0zLTEuNi01LjktMi40LTguOSBjLTAuOS0zLjItMS45LTQuOC0yLjktNC44Yy0wLjIsMC0xLDAuNS0yLjQsMS40TDE3LDI2YzEuNS0xLjMsMi45LTIuNiw0LjQtMy45YzItMS43LDMuNS0yLjYsNC40LTIuN2MyLjMtMC4yLDMuOCwxLjQsNC4zLDQuOCBjMC42LDMuNywxLDYsMS4yLDYuOWMwLjcsMy4xLDEuNCw0LjYsMi4yLDQuNmMwLjYsMCwxLjYtMSwyLjgtM2MxLjMtMiwxLjktMy41LDItNC41YzAuMi0xLjctMC41LTIuNi0yLTIuNmMtMC43LDAtMS41LDAuMi0yLjIsMC41IGMxLjUtNC44LDQuMy03LjIsOC40LTdjMy4xLDAuMSw0LjUsMi4xLDQuNCw2QzQ2LjksMjcuOSw0NC44LDMxLjksNDAuOSwzN3pcIixcbiAgICBcImNvbG9yXCI6IFwiIzFhYjdlYVwiXG4gIH0sXG4gIFwidmluZVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTQ1LjIsMzEuOWMtMC44LDAuMi0xLjUsMC4zLTIuMiwwLjNjLTMuOCwwLTYuNy0yLjYtNi43LTcuMmMwLTIuMywwLjktMy40LDIuMS0zLjQgYzEuMiwwLDIsMS4xLDIsMy4yYzAsMS4yLTAuMywyLjUtMC42LDMuM2MwLDAsMS4yLDIsNC40LDEuNGMwLjctMS41LDEtMy41LDEtNS4yYzAtNC42LTIuMy03LjMtNi42LTcuM2MtNC40LDAtNywzLjQtNyw3LjkgYzAsNC40LDIuMSw4LjIsNS41LDEwYy0xLjQsMi45LTMuMyw1LjQtNS4yLDcuM2MtMy41LTQuMi02LjYtOS44LTcuOS0yMC43aC01LjFjMi40LDE4LjEsOS40LDIzLjksMTEuMiwyNWMxLjEsMC42LDIsMC42LDIuOSwwLjEgYzEuNS0wLjksNi01LjQsOC42LTEwLjdjMS4xLDAsMi4zLTAuMSwzLjYtMC40VjMxLjl6XCIsXG4gICAgXCJtYXNrXCI6IFwiTTAsMHY2NGg2NFYwSDB6IE0zOC40LDIxLjVjLTEuMiwwLTIuMSwxLjItMi4xLDMuNGMwLDQuNiwyLjksNy4yLDYuNyw3LjJjMC43LDAsMS40LTAuMSwyLjItMC4zdjMuNiBjLTEuMywwLjMtMi41LDAuNC0zLjYsMC40Yy0yLjUsNS4zLTcsOS44LTguNiwxMC43Yy0xLDAuNS0xLjksMC42LTIuOS0wLjFjLTEuOS0xLjEtOC45LTYuOS0xMS4yLTI1SDI0YzEuMywxMC45LDQuNCwxNi41LDcuOSwyMC43IGMxLjktMS45LDMuNy00LjQsNS4yLTcuM2MtMy40LTEuNy01LjUtNS41LTUuNS0xMGMwLTQuNSwyLjYtNy45LDctNy45YzQuMywwLDYuNiwyLjcsNi42LDcuM2MwLDEuNy0wLjQsMy43LTEsNS4yIGMtMy4yLDAuNi00LjQtMS40LTQuNC0xLjRjMC4yLTAuOCwwLjYtMi4xLDAuNi0zLjNDNDAuMywyMi42LDM5LjUsMjEuNSwzOC40LDIxLjV6XCIsXG4gICAgXCJjb2xvclwiOiBcIiMwMEJGOEZcIlxuICB9LFxuICBcInZzY29cIjoge1xuICAgIFwiaWNvblwiOiBcIk0zMiwxNmMtMS40LDAtMi41LDEuMS0yLjUsMi41YzAsMS40LDEuMSwyLjUsMi41LDIuNWMxLjQsMCwyLjUtMS4xLDIuNS0yLjUgQzM0LjUsMTcuMSwzMy40LDE2LDMyLDE2eiBNMTguNSwyOS41Yy0xLjQsMC0yLjUsMS4xLTIuNSwyLjVjMCwxLjQsMS4xLDIuNSwyLjUsMi41YzEuNCwwLDIuNS0xLjEsMi41LTIuNSBDMjAuOSwzMC42LDE5LjgsMjkuNSwxOC41LDI5LjV6IE0yNS4yLDIyLjhjLTEuNCwwLTIuNSwxLjEtMi41LDIuNWMwLDEuNCwxLjEsMi41LDIuNSwyLjVjMS40LDAsMi41LTEuMSwyLjUtMi41IEMyNy43LDIzLjksMjYuNiwyMi44LDI1LjIsMjIuOHogTTM4LjcsMjcuNmMxLjQsMCwyLjUtMS4xLDIuNS0yLjVjMC0xLjQtMS4xLTIuNS0yLjUtMi41Yy0xLjQsMC0yLjUsMS4xLTIuNSwyLjUgQzM2LjIsMjYuNSwzNy4zLDI3LjYsMzguNywyNy42eiBNMjUuMSwzNi4yYy0xLjQsMC0yLjUsMS4xLTIuNSwyLjVjMCwxLjQsMS4xLDIuNSwyLjUsMi41YzEuNCwwLDIuNS0xLjEsMi41LTIuNSBDMjcuNiwzNy4zLDI2LjUsMzYuMiwyNS4xLDM2LjJ6IE0zMS45LDM0LjRjMS40LDAsMi41LTEuMSwyLjUtMi41YzAtMS40LTEuMS0yLjUtMi41LTIuNWMtMS40LDAtMi41LDEuMS0yLjUsMi41IEMyOS41LDMzLjMsMzAuNiwzNC40LDMxLjksMzQuNHogTTQ1LjUsMjkuNWMtMS40LDAtMi41LDEuMS0yLjUsMi41YzAsMS40LDEuMSwyLjUsMi41LDIuNWMxLjQsMCwyLjUtMS4xLDIuNS0yLjUgQzQ4LDMwLjYsNDYuOSwyOS41LDQ1LjUsMjkuNXogTTMyLDQzLjFjLTEuNCwwLTIuNSwxLjEtMi41LDIuNWMwLDEuNCwxLjEsMi41LDIuNSwyLjVjMS40LDAsMi41LTEuMSwyLjUtMi41IEMzNC41LDQ0LjIsMzMuNCw0My4xLDMyLDQzLjF6IE0zOC44LDM2LjNjLTEuNCwwLTIuNSwxLjEtMi41LDIuNWMwLDEuNCwxLjEsMi41LDIuNSwyLjVjMS40LDAsMi41LTEuMSwyLjUtMi41IEM0MS4yLDM3LjQsNDAuMSwzNi4zLDM4LjgsMzYuM3pcIixcbiAgICBcIm1hc2tcIjogXCJNMCwwdjY0aDY0VjBIMHogTTE4LjUsMzQuNWMtMS40LDAtMi41LTEuMS0yLjUtMi41YzAtMS40LDEuMS0yLjUsMi41LTIuNWMxLjQsMCwyLjUsMS4xLDIuNSwyLjUgQzIwLjksMzMuNCwxOS44LDM0LjUsMTguNSwzNC41eiBNMjUuMSw0MS4xYy0xLjQsMC0yLjUtMS4xLTIuNS0yLjVjMC0xLjQsMS4xLTIuNSwyLjUtMi41YzEuNCwwLDIuNSwxLjEsMi41LDIuNSBDMjcuNiw0MCwyNi41LDQxLjEsMjUuMSw0MS4xeiBNMjUuMiwyNy43Yy0xLjQsMC0yLjUtMS4xLTIuNS0yLjVjMC0xLjQsMS4xLTIuNSwyLjUtMi41YzEuNCwwLDIuNSwxLjEsMi41LDIuNSBDMjcuNywyNi42LDI2LjYsMjcuNywyNS4yLDI3Ljd6IE0zMiw0OGMtMS40LDAtMi41LTEuMS0yLjUtMi41YzAtMS40LDEuMS0yLjUsMi41LTIuNWMxLjQsMCwyLjUsMS4xLDIuNSwyLjUgQzM0LjUsNDYuOSwzMy40LDQ4LDMyLDQ4eiBNMjkuNSwzMS45YzAtMS40LDEuMS0yLjUsMi41LTIuNWMxLjQsMCwyLjUsMS4xLDIuNSwyLjVjMCwxLjQtMS4xLDIuNS0yLjUsMi41IEMzMC42LDM0LjQsMjkuNSwzMy4zLDI5LjUsMzEuOXogTTMyLDIwLjljLTEuNCwwLTIuNS0xLjEtMi41LTIuNWMwLTEuNCwxLjEtMi41LDIuNS0yLjVjMS40LDAsMi41LDEuMSwyLjUsMi41IEMzNC41LDE5LjgsMzMuNCwyMC45LDMyLDIwLjl6IE0zOC43LDIyLjdjMS40LDAsMi41LDEuMSwyLjUsMi41YzAsMS40LTEuMSwyLjUtMi41LDIuNWMtMS40LDAtMi41LTEuMS0yLjUtMi41IEMzNi4yLDIzLjgsMzcuMywyMi43LDM4LjcsMjIuN3ogTTM4LjgsNDEuMmMtMS40LDAtMi41LTEuMS0yLjUtMi41YzAtMS40LDEuMS0yLjUsMi41LTIuNWMxLjQsMCwyLjUsMS4xLDIuNSwyLjUgQzQxLjIsNDAuMSw0MC4xLDQxLjIsMzguOCw0MS4yeiBNNDUuNSwzNC41Yy0xLjQsMC0yLjUtMS4xLTIuNS0yLjVjMC0xLjQsMS4xLTIuNSwyLjUtMi41YzEuNCwwLDIuNSwxLjEsMi41LDIuNSBDNDgsMzMuNCw0Ni45LDM0LjUsNDUuNSwzNC41elwiLFxuICAgIFwiY29sb3JcIjogXCIjODM4NzhBXCJcbiAgfSxcbiAgXCJ5ZWxwXCI6IHtcbiAgICBcImljb25cIjogXCJNMjkuNSwzNS43YzAuNS0wLjEsMC45LTAuNiwwLjktMS4yYzAtMC42LTAuMy0xLjItMC44LTEuNGMwLDAtMS41LTAuNi0xLjUtMC42IGMtNS0yLjEtNS4yLTIuMS01LjUtMi4xYy0wLjQsMC0wLjcsMC4yLTEsMC42Yy0wLjUsMC44LTAuNywzLjMtMC41LDVjMC4xLDAuNiwwLjIsMSwwLjMsMS4zYzAuMiwwLjQsMC41LDAuNiwwLjksMC42IGMwLjIsMCwwLjQsMCw1LjEtMS41QzI3LjUsMzYuNCwyOS41LDM1LjcsMjkuNSwzNS43eiBNMzIuMiwzNy42Yy0wLjYtMC4yLTEuMi0wLjEtMS41LDAuNGMwLDAtMSwxLjItMSwxLjIgYy0zLjUsNC4xLTMuNyw0LjMtMy43LDQuNWMtMC4xLDAuMS0wLjEsMC4zLTAuMSwwLjRjMCwwLjIsMC4xLDAuNCwwLjMsMC42YzAuOCwxLDQuNywyLjQsNiwyLjJjMC40LTAuMSwwLjctMC4zLDAuOS0wLjcgQzMzLDQ2LjEsMzMsNDUuOSwzMyw0MWMwLDAsMC0yLjIsMC0yLjJDMzMuMSwzOC4zLDMyLjcsMzcuOCwzMi4yLDM3LjZ6IE0zMi4zLDE2LjhjLTAuMS0wLjQtMC40LTAuNy0wLjktMC44IGMtMS4zLTAuMy02LjUsMS4xLTcuNSwyLjFjLTAuMywwLjMtMC40LDAuNy0wLjMsMS4xYzAuMiwwLjMsNi41LDEwLjQsNi41LDEwLjRjMC45LDEuNSwxLjcsMS4zLDIsMS4yYzAuMy0wLjEsMS0wLjMsMC45LTIuMSBDMzMsMjYuNiwzMi40LDE3LjMsMzIuMywxNi44eiBNMzYuOSwzMy40QzM2LjksMzMuNCwzNi44LDMzLjUsMzYuOSwzMy40YzAuMi0wLjEsMC43LTAuMiwxLjUtMC40YzUuMy0xLjMsNS41LTEuMyw1LjctMS41IGMwLjMtMC4yLDAuNS0wLjYsMC41LTFjMCwwLDAsMCwwLDBjLTAuMS0xLjMtMi40LTQuNy0zLjUtNS4yYy0wLjQtMC4yLTAuOC0wLjItMS4xLDBjLTAuMiwwLjEtMC40LDAuMy0zLjIsNC4yYzAsMC0xLjMsMS43LTEuMywxLjggYy0wLjMsMC40LTAuMywxLDAsMS41QzM1LjgsMzMuMywzNi4zLDMzLjYsMzYuOSwzMy40eiBNNDQuNCwzOC42Yy0wLjItMC4xLTAuMy0wLjItNS0xLjdjMCwwLTItMC43LTIuMS0wLjdjLTAuNS0wLjItMS4xLDAtMS40LDAuNSBjLTAuNCwwLjUtMC41LDEuMS0wLjEsMS42bDAuOCwxLjNjMi44LDQuNSwzLDQuOCwzLjIsNWMwLjMsMC4yLDAuNywwLjMsMS4xLDAuMWMxLjItMC41LDMuNy0zLjcsMy45LTUgQzQ0LjgsMzkuMiw0NC43LDM4LjgsNDQuNCwzOC42elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNMjIuNCwzNy45Yy0wLjQsMC0wLjctMC4yLTAuOS0wLjZjLTAuMS0wLjMtMC4yLTAuNy0wLjMtMS4zYy0wLjItMS43LDAtNC4yLDAuNS01IGMwLjItMC40LDAuNi0wLjYsMS0wLjZjMC4zLDAsMC41LDAuMSw1LjUsMi4xYzAsMCwxLjUsMC42LDEuNSwwLjZjMC41LDAuMiwwLjksMC43LDAuOCwxLjRjMCwwLjYtMC40LDEuMS0wLjksMS4yIGMwLDAtMi4xLDAuNy0yLjEsMC43QzIyLjgsMzcuOSwyMi43LDM3LjksMjIuNCwzNy45eiBNMzMsNDFjMCw0LjksMCw1LTAuMSw1LjNjLTAuMSwwLjQtMC40LDAuNi0wLjksMC43Yy0xLjIsMC4yLTUuMS0xLjItNi0yLjIgYy0wLjItMC4yLTAuMy0wLjQtMC4zLTAuNmMwLTAuMiwwLTAuMywwLjEtMC40YzAuMS0wLjIsMC4yLTAuNCwzLjctNC41YzAsMCwxLTEuMiwxLTEuMmMwLjMtMC40LDEtMC42LDEuNS0wLjQgYzAuNiwwLjIsMC45LDAuNywwLjksMS4yQzMzLDM4LjgsMzMsNDEsMzMsNDF6IE0zMi4yLDMwLjhjLTAuMywwLjEtMSwwLjMtMi0xLjJjMCwwLTYuNC0xMC4xLTYuNS0xMC40Yy0wLjEtMC4zLDAtMC43LDAuMy0xLjEgYzEtMSw2LjEtMi40LDcuNS0yLjFjMC40LDAuMSwwLjcsMC40LDAuOSwwLjhjMC4xLDAuNCwwLjcsOS44LDAuOCwxMS45QzMzLjIsMzAuNSwzMi40LDMwLjcsMzIuMiwzMC44eiBNMzUuNCwzMS4zIGMwLDAsMS4zLTEuOCwxLjMtMS44YzIuOC0zLjksMy00LjEsMy4yLTQuMmMwLjMtMC4yLDAuNy0wLjIsMS4xLDBjMS4xLDAuNSwzLjQsMy45LDMuNSw1LjJjMCwwLDAsMCwwLDBjMCwwLjQtMC4xLDAuOC0wLjUsMSBjLTAuMiwwLjEtMC40LDAuMi01LjcsMS41Yy0wLjgsMC4yLTEuMywwLjMtMS42LDAuNGMwLDAsMCwwLDAsMGMtMC41LDAuMS0xLjEtMC4xLTEuNC0wLjZDMzUuMSwzMi4zLDM1LjEsMzEuNywzNS40LDMxLjN6ICBNNDQuNywzOS42Yy0wLjIsMS4zLTIuNyw0LjUtMy45LDVjLTAuNCwwLjItMC44LDAuMS0xLjEtMC4xYy0wLjItMC4yLTAuNC0wLjUtMy4yLTVsLTAuOC0xLjNjLTAuMy0wLjUtMC4zLTEuMSwwLjEtMS42IGMwLjQtMC41LDAuOS0wLjYsMS40LTAuNWMwLDAsMi4xLDAuNywyLjEsMC43YzQuNiwxLjUsNC44LDEuNiw1LDEuN0M0NC43LDM4LjgsNDQuOCwzOS4yLDQ0LjcsMzkuNnpcIixcbiAgICBcImNvbG9yXCI6IFwiI0I5MEMwNFwiXG4gIH0sXG4gIFwieW91dHViZVwiOiB7XG4gICAgXCJpY29uXCI6IFwiTTQ2LjcsMjZjMCwwLTAuMy0yLjEtMS4yLTNjLTEuMS0xLjItMi40LTEuMi0zLTEuM0MzOC4zLDIxLjQsMzIsMjEuNCwzMiwyMS40aDAgYzAsMC02LjMsMC0xMC41LDAuM2MtMC42LDAuMS0xLjksMC4xLTMsMS4zYy0wLjksMC45LTEuMiwzLTEuMiwzUzE3LDI4LjQsMTcsMzAuOXYyLjNjMCwyLjQsMC4zLDQuOSwwLjMsNC45czAuMywyLjEsMS4yLDMgYzEuMSwxLjIsMi42LDEuMiwzLjMsMS4zYzIuNCwwLjIsMTAuMiwwLjMsMTAuMiwwLjNzNi4zLDAsMTAuNS0wLjNjMC42LTAuMSwxLjktMC4xLDMtMS4zYzAuOS0wLjksMS4yLTMsMS4yLTNzMC4zLTIuNCwwLjMtNC45IHYtMi4zQzQ3LDI4LjQsNDYuNywyNiw0Ni43LDI2eiBNMjguOSwzNS45bDAtOC40bDguMSw0LjJMMjguOSwzNS45elwiLFxuICAgIFwibWFza1wiOiBcIk0wLDB2NjRoNjRWMEgweiBNNDcsMzMuMWMwLDIuNC0wLjMsNC45LTAuMyw0LjlzLTAuMywyLjEtMS4yLDNjLTEuMSwxLjItMi40LDEuMi0zLDEuMyBDMzguMyw0Mi41LDMyLDQyLjYsMzIsNDIuNnMtNy44LTAuMS0xMC4yLTAuM2MtMC43LTAuMS0yLjItMC4xLTMuMy0xLjNjLTAuOS0wLjktMS4yLTMtMS4yLTNTMTcsMzUuNiwxNywzMy4xdi0yLjMgYzAtMi40LDAuMy00LjksMC4zLTQuOXMwLjMtMi4xLDEuMi0zYzEuMS0xLjIsMi40LTEuMiwzLTEuM2M0LjItMC4zLDEwLjUtMC4zLDEwLjUtMC4zaDBjMCwwLDYuMywwLDEwLjUsMC4zYzAuNiwwLjEsMS45LDAuMSwzLDEuMyBjMC45LDAuOSwxLjIsMywxLjIsM3MwLjMsMi40LDAuMyw0LjlWMzMuMXogTTI4LjksMzUuOWw4LjEtNC4ybC04LjEtNC4yTDI4LjksMzUuOXpcIixcbiAgICBcImNvbG9yXCI6IFwiI2ZmMzMzM1wiXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4wLjFcIlxufSIsIkFwcFZpZXcgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vdmlld3MvYXBwLXZpZXcnXG5cbkNsb3VkRmlsZU1hbmFnZXJVSU1lbnUgPSAocmVxdWlyZSAnLi91aScpLkNsb3VkRmlsZU1hbmFnZXJVSU1lbnVcbkNsb3VkRmlsZU1hbmFnZXJDbGllbnQgPSAocmVxdWlyZSAnLi9jbGllbnQnKS5DbG91ZEZpbGVNYW5hZ2VyQ2xpZW50XG5cbmdldEhhc2hQYXJhbSA9IHJlcXVpcmUgJy4vdXRpbHMvZ2V0LWhhc2gtcGFyYW0nXG5cbmNsYXNzIENsb3VkRmlsZU1hbmFnZXJcblxuICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMpIC0+XG4gICAgIyBzaW5jZSB0aGUgbW9kdWxlIGV4cG9ydHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIHdlIG5lZWQgdG8gZmFrZSBhIGNsYXNzIHZhcmlhYmxlIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgQERlZmF1bHRNZW51ID0gQ2xvdWRGaWxlTWFuYWdlclVJTWVudS5EZWZhdWx0TWVudVxuXG4gICAgQGNsaWVudCA9IG5ldyBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50KClcbiAgICBAYXBwT3B0aW9ucyA9IHt9XG5cbiAgIyB1c2luZ0lmcmFtZTogaWYgdHJ1ZSwgY2xpZW50IGFwcCBpcyB3cmFwcGVkIGluIGFuIGlmcmFtZSB3aXRoaW4gdGhlIENGTS1tYW5hZ2VkIGRpdlxuICAjIGFwcE9yTWVudUVsZW1JZDogaWYgYXBwT3JNZW51RWxlbUlkIGlzIHBhc3NlZCBhbmQgdXNpbmdJZnJhbWUgaXMgdHJ1ZSwgdGhlbiB0aGUgQ0ZNXG4gICMgICBwcmVzZW50cyBpdHMgVUkgYW5kIHRoZSB3cmFwcGVkIGNsaWVudCBhcHAgd2l0aGluIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gSWZcbiAgIyAgIGFwcE9yTWVudUVsZW1JZCBpcyBzZXQgYW5kIHVzaW5nSWZyYW1lIGlzIGZhbHNlLCB0aGVuIHRoZSBDRk0gcHJlc2VudHMgaXRzIG1lbnViYXJcbiAgIyAgIFVJIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGJ1dCB0aGVyZSBpcyBubyBpZnJhbWUgb3Igd3JhcHBlZCBjbGllbnQgYXBwLlxuICBpbml0OiAoQGFwcE9wdGlvbnMpIC0+XG4gICAgQGFwcE9wdGlvbnMuaGFzaFBhcmFtcyA9IHtcbiAgICAgIHNoYXJlZENvbnRlbnRJZDogZ2V0SGFzaFBhcmFtIFwic2hhcmVkXCJcbiAgICAgIGZpbGVQYXJhbXM6IGdldEhhc2hQYXJhbSBcImZpbGVcIlxuICAgICAgY29weVBhcmFtczogZ2V0SGFzaFBhcmFtIFwiY29weVwiXG4gICAgICBuZXdJbkZvbGRlclBhcmFtczogZ2V0SGFzaFBhcmFtIFwibmV3SW5Gb2xkZXJcIlxuICAgIH1cblxuICAgIEBjbGllbnQuc2V0QXBwT3B0aW9ucyBAYXBwT3B0aW9uc1xuXG4gICMgQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHNldHRpbmcgdXAgQ0ZNIHdpdGggYW4gaWZyYW1lLXdyYXBwZWQgY2xpZW50IGFwcFxuICBjcmVhdGVGcmFtZTogKEBhcHBPcHRpb25zLCBhcHBFbGVtSWQsIGV2ZW50Q2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIEBhcHBPcHRpb25zLnVzaW5nSWZyYW1lID0gdHJ1ZVxuICAgIEBhcHBPcHRpb25zLmFwcE9yTWVudUVsZW1JZCA9IGFwcEVsZW1JZFxuICAgIEBpbml0IEBhcHBPcHRpb25zXG4gICAgQGNsaWVudC5saXN0ZW4gZXZlbnRDYWxsYmFja1xuICAgIEBfcmVuZGVyQXBwIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFwcEVsZW1JZClcblxuICBjbGllbnRDb25uZWN0OiAoZXZlbnRDYWxsYmFjaykgLT5cbiAgICB0cnlcbiAgICAgIGlmIEBhcHBPcHRpb25zLmFwcE9yTWVudUVsZW1JZD9cbiAgICAgICAgQF9yZW5kZXJBcHAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoQGFwcE9wdGlvbnMuYXBwT3JNZW51RWxlbUlkKVxuICAgICAgZWxzZVxuICAgICAgICBAX2NyZWF0ZUhpZGRlbkFwcCgpXG4gICAgY2F0Y2ggZVxuICAgICAgY29uc29sZS5lcnJvciBcIlVuYWJsZSByZW5kZXIgYXBwOiAje2V9XCJcbiAgICBAY2xpZW50Lmxpc3RlbiBldmVudENhbGxiYWNrXG4gICAgQGNsaWVudC5jb25uZWN0KClcblxuICAgICMgb3BlbiBhbnkgaW5pdGlhbCBkb2N1bWVudCAoaWYgYW55IHNwZWNpZmllZCkgYW5kIHNpZ25hbCByZWFkeSgpXG4gICAgQGNsaWVudC5wcm9jZXNzVXJsUGFyYW1zKClcblxuICAgICMgaWYgaWZyYW1lZCBsZXQgdGhlIHBhcmVudCBrbm93IGFib3V0IHRoZSBjb25uZWN0XG4gICAgaWYgd2luZG93LnBhcmVudFxuICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSh7dHlwZTogXCJjZm06OmlmcmFtZWRDbGllbnRDb25uZWN0ZWRcIn0sIFwiKlwiKVxuXG4gIF9jcmVhdGVIaWRkZW5BcHA6IC0+XG4gICAgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYW5jaG9yKVxuICAgIEBfcmVuZGVyQXBwIGFuY2hvclxuXG4gIF9yZW5kZXJBcHA6IChhbmNob3IpIC0+XG4gICAgQGFwcE9wdGlvbnMuY2xpZW50ID0gQGNsaWVudFxuICAgIFJlYWN0RE9NLnJlbmRlciAoQXBwVmlldyBAYXBwT3B0aW9ucyksIGFuY2hvclxuICAgIEBjbGllbnQuaWZyYW1lID0gYW5jaG9yLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpZnJhbWUnKVswXVxuICAgIEBjbGllbnQucmVuZGVyZWQoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDbG91ZEZpbGVNYW5hZ2VyKClcbiIsInRyID0gcmVxdWlyZSAnLi91dGlscy90cmFuc2xhdGUnXG5pc1N0cmluZyA9IHJlcXVpcmUgJy4vdXRpbHMvaXMtc3RyaW5nJ1xuYmFzZTY0QXJyYXkgPSByZXF1aXJlICdiYXNlNjQtanMnICMgaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzXG5nZXRRdWVyeVBhcmFtID0gcmVxdWlyZSAnLi91dGlscy9nZXQtcXVlcnktcGFyYW0nXG5cbkNsb3VkRmlsZU1hbmFnZXJVSSA9IChyZXF1aXJlICcuL3VpJykuQ2xvdWRGaWxlTWFuYWdlclVJXG5cbkxvY2FsU3RvcmFnZVByb3ZpZGVyID0gcmVxdWlyZSAnLi9wcm92aWRlcnMvbG9jYWxzdG9yYWdlLXByb3ZpZGVyJ1xuUmVhZE9ubHlQcm92aWRlciA9IHJlcXVpcmUgJy4vcHJvdmlkZXJzL3JlYWRvbmx5LXByb3ZpZGVyJ1xuR29vZ2xlRHJpdmVQcm92aWRlciA9IHJlcXVpcmUgJy4vcHJvdmlkZXJzL2dvb2dsZS1kcml2ZS1wcm92aWRlcidcbkxhcmFQcm92aWRlciA9IHJlcXVpcmUgJy4vcHJvdmlkZXJzL2xhcmEtcHJvdmlkZXInXG5Eb2N1bWVudFN0b3JlUHJvdmlkZXIgPSByZXF1aXJlICcuL3Byb3ZpZGVycy9kb2N1bWVudC1zdG9yZS1wcm92aWRlcidcbkRvY3VtZW50U3RvcmVTaGFyZVByb3ZpZGVyID0gcmVxdWlyZSAnLi9wcm92aWRlcnMvZG9jdW1lbnQtc3RvcmUtc2hhcmUtcHJvdmlkZXInXG5Mb2NhbEZpbGVQcm92aWRlciA9IHJlcXVpcmUgJy4vcHJvdmlkZXJzL2xvY2FsLWZpbGUtcHJvdmlkZXInXG5Qb3N0TWVzc2FnZVByb3ZpZGVyID0gcmVxdWlyZSAnLi9wcm92aWRlcnMvcG9zdC1tZXNzYWdlLXByb3ZpZGVyJ1xuVVJMUHJvdmlkZXIgPSByZXF1aXJlICcuL3Byb3ZpZGVycy91cmwtcHJvdmlkZXInXG5cblByb3ZpZGVySW50ZXJmYWNlID0gKHJlcXVpcmUgJy4vcHJvdmlkZXJzL3Byb3ZpZGVyLWludGVyZmFjZScpLlByb3ZpZGVySW50ZXJmYWNlXG5jbG91ZENvbnRlbnRGYWN0b3J5ID0gKHJlcXVpcmUgJy4vcHJvdmlkZXJzL3Byb3ZpZGVyLWludGVyZmFjZScpLmNsb3VkQ29udGVudEZhY3RvcnlcbkNsb3VkQ29udGVudCA9IChyZXF1aXJlICcuL3Byb3ZpZGVycy9wcm92aWRlci1pbnRlcmZhY2UnKS5DbG91ZENvbnRlbnRcbkNsb3VkTWV0YWRhdGEgPSAocmVxdWlyZSAnLi9wcm92aWRlcnMvcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuXG5jbGFzcyBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50RXZlbnRcblxuICBAaWQ6IDBcbiAgQGV2ZW50czoge31cblxuICBjb25zdHJ1Y3RvcjogKEB0eXBlLCBAZGF0YSA9IHt9LCBAY2FsbGJhY2sgPSBudWxsLCBAc3RhdGUgPSB7fSkgLT5cbiAgICBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50RXZlbnQuaWQrK1xuICAgIEBpZCA9IENsb3VkRmlsZU1hbmFnZXJDbGllbnRFdmVudC5pZFxuXG4gIHBvc3RNZXNzYWdlOiAoaWZyYW1lKSAtPlxuICAgIGlmIEBjYWxsYmFja1xuICAgICAgQ2xvdWRGaWxlTWFuYWdlckNsaWVudEV2ZW50LmV2ZW50c1tAaWRdID0gQFxuICAgICMgcmVtb3ZlIGNsaWVudCBmcm9tIGRhdGEgdG8gYXZvaWQgc3RydWN0dXJlZCBjbG9uZSBlcnJvciBpbiBwb3N0TWVzc2FnZVxuICAgIGV2ZW50RGF0YSA9IF8uY2xvbmUgQGRhdGFcbiAgICBkZWxldGUgZXZlbnREYXRhLmNsaWVudFxuICAgIG1lc3NhZ2UgPSB7dHlwZTogXCJjZm06OmV2ZW50XCIsIGV2ZW50SWQ6IEBpZCwgZXZlbnRUeXBlOiBAdHlwZSwgZXZlbnREYXRhOiBldmVudERhdGF9XG4gICAgaWZyYW1lLnBvc3RNZXNzYWdlIG1lc3NhZ2UsIFwiKlwiXG5cbmNsYXNzIENsb3VkRmlsZU1hbmFnZXJDbGllbnRcblxuICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMpIC0+XG4gICAgQHN0YXRlID1cbiAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogW11cbiAgICBAX2xpc3RlbmVycyA9IFtdXG4gICAgQF9yZXNldFN0YXRlKClcbiAgICBAX3VpID0gbmV3IENsb3VkRmlsZU1hbmFnZXJVSSBAXG4gICAgQHByb3ZpZGVycyA9IHt9XG4gICAgQHVybFByb3ZpZGVyID0gbmV3IFVSTFByb3ZpZGVyKClcblxuICBzZXRBcHBPcHRpb25zOiAoQGFwcE9wdGlvbnMgPSB7fSktPlxuXG4gICAgQGFwcE9wdGlvbnMud3JhcEZpbGVDb250ZW50ID89IHRydWVcbiAgICBDbG91ZENvbnRlbnQud3JhcEZpbGVDb250ZW50ID0gQGFwcE9wdGlvbnMud3JhcEZpbGVDb250ZW50XG5cbiAgICAjIERldGVybWluZSB0aGUgYXZhaWxhYmxlIHByb3ZpZGVycy4gTm90ZSB0aGF0IG9yZGVyIGluIHRoZSBsaXN0IGNhblxuICAgICMgYmUgc2lnbmlmaWNhbnQgaW4gcHJvdmlkZXIgc2VhcmNoZXMgKGUuZy4gQGF1dG9Qcm92aWRlcikuXG4gICAgYWxsUHJvdmlkZXJzID0ge31cbiAgICBwcm92aWRlckxpc3QgPSBbXG4gICAgICBMb2NhbFN0b3JhZ2VQcm92aWRlclxuICAgICAgUmVhZE9ubHlQcm92aWRlclxuICAgICAgR29vZ2xlRHJpdmVQcm92aWRlclxuICAgICAgTGFyYVByb3ZpZGVyXG4gICAgICBEb2N1bWVudFN0b3JlUHJvdmlkZXJcbiAgICAgIExvY2FsRmlsZVByb3ZpZGVyXG4gICAgICBQb3N0TWVzc2FnZVByb3ZpZGVyXG4gICAgXVxuICAgIGZvciBQcm92aWRlciBpbiBwcm92aWRlckxpc3RcbiAgICAgIGlmIFByb3ZpZGVyLkF2YWlsYWJsZSgpXG4gICAgICAgIGFsbFByb3ZpZGVyc1tQcm92aWRlci5OYW1lXSA9IFByb3ZpZGVyXG5cbiAgICAjIGRlZmF1bHQgdG8gYWxsIHByb3ZpZGVycyBpZiBub24gc3BlY2lmaWVkXG4gICAgaWYgbm90IEBhcHBPcHRpb25zLnByb3ZpZGVyc1xuICAgICAgQGFwcE9wdGlvbnMucHJvdmlkZXJzID0gW11cbiAgICAgIGZvciBvd24gcHJvdmlkZXJOYW1lIG9mIGFsbFByb3ZpZGVyc1xuICAgICAgICBhcHBPcHRpb25zLnByb3ZpZGVycy5wdXNoIHByb3ZpZGVyTmFtZVxuXG4gICAgIyBwcmVzZXQgdGhlIGV4dGVuc2lvbiBpZiBBdmFpbGFibGVcbiAgICBDbG91ZE1ldGFkYXRhLkV4dGVuc2lvbiA9IEBhcHBPcHRpb25zLmV4dGVuc2lvblxuICAgIENsb3VkTWV0YWRhdGEuUmVhZGFibGVFeHRlbnNpb25zID0gQGFwcE9wdGlvbnMucmVhZGFibGVFeHRlbnNpb25zIG9yIFtdXG4gICAgaWYgQ2xvdWRNZXRhZGF0YS5FeHRlbnNpb24gdGhlbiBDbG91ZE1ldGFkYXRhLlJlYWRhYmxlRXh0ZW5zaW9ucy5wdXNoIENsb3VkTWV0YWRhdGEuRXh0ZW5zaW9uXG5cbiAgICByZWFkYWJsZU1pbWV0eXBlcyA9IEBhcHBPcHRpb25zLnJlYWRhYmxlTWltZVR5cGVzIG9yIFtdXG4gICAgcmVhZGFibGVNaW1ldHlwZXMucHVzaCBAYXBwT3B0aW9ucy5taW1lVHlwZVxuXG4gICAgIyBjaGVjayB0aGUgcHJvdmlkZXJzXG4gICAgcmVxdWVzdGVkUHJvdmlkZXJzID0gQGFwcE9wdGlvbnMucHJvdmlkZXJzLnNsaWNlKClcbiAgICBpZiBnZXRRdWVyeVBhcmFtIFwic2F2ZVNlY29uZGFyeUZpbGVWaWFQb3N0TWVzc2FnZVwiXG4gICAgICByZXF1ZXN0ZWRQcm92aWRlcnMucHVzaCAncG9zdE1lc3NhZ2UnXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzID0gW11cbiAgICBzaGFyZVByb3ZpZGVyID0gbnVsbFxuICAgIGZvciBwcm92aWRlclNwZWMgaW4gcmVxdWVzdGVkUHJvdmlkZXJzXG4gICAgICBbcHJvdmlkZXJOYW1lLCBwcm92aWRlck9wdGlvbnNdID0gaWYgaXNTdHJpbmcgcHJvdmlkZXJTcGVjIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFtwcm92aWRlclNwZWMsIHt9XSBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBbcHJvdmlkZXJTcGVjLm5hbWUsIHByb3ZpZGVyU3BlY11cbiAgICAgICMgbWVyZ2UgaW4gb3RoZXIgb3B0aW9ucyBhcyBuZWVkZWRcbiAgICAgIHByb3ZpZGVyT3B0aW9ucy5taW1lVHlwZSA/PSBAYXBwT3B0aW9ucy5taW1lVHlwZVxuICAgICAgcHJvdmlkZXJPcHRpb25zLnJlYWRhYmxlTWltZXR5cGVzID0gcmVhZGFibGVNaW1ldHlwZXNcbiAgICAgIGlmIG5vdCBwcm92aWRlck5hbWVcbiAgICAgICAgQGFsZXJ0IFwiSW52YWxpZCBwcm92aWRlciBzcGVjIC0gbXVzdCBlaXRoZXIgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoIG5hbWUgcHJvcGVydHlcIlxuICAgICAgZWxzZVxuICAgICAgICBpZiBwcm92aWRlclNwZWMuY3JlYXRlUHJvdmlkZXJcbiAgICAgICAgICBhbGxQcm92aWRlcnNbcHJvdmlkZXJOYW1lXSA9IHByb3ZpZGVyU3BlYy5jcmVhdGVQcm92aWRlciBQcm92aWRlckludGVyZmFjZVxuICAgICAgICBpZiBhbGxQcm92aWRlcnNbcHJvdmlkZXJOYW1lXVxuICAgICAgICAgIFByb3ZpZGVyID0gYWxsUHJvdmlkZXJzW3Byb3ZpZGVyTmFtZV1cbiAgICAgICAgICBwcm92aWRlciA9IG5ldyBQcm92aWRlciBwcm92aWRlck9wdGlvbnMsIEBcbiAgICAgICAgICBAcHJvdmlkZXJzW3Byb3ZpZGVyTmFtZV0gPSBwcm92aWRlclxuICAgICAgICAgICMgaWYgd2UncmUgdXNpbmcgdGhlIERvY3VtZW50U3RvcmVQcm92aWRlciwgaW5zdGFudGlhdGUgdGhlIFNoYXJlUHJvdmlkZXJcbiAgICAgICAgICBpZiBwcm92aWRlck5hbWUgaXMgRG9jdW1lbnRTdG9yZVByb3ZpZGVyLk5hbWVcbiAgICAgICAgICAgIHNoYXJlUHJvdmlkZXIgPSBuZXcgRG9jdW1lbnRTdG9yZVNoYXJlUHJvdmlkZXIoQCwgcHJvdmlkZXIpXG4gICAgICAgICAgaWYgcHJvdmlkZXIudXJsRGlzcGxheU5hbWUgICAgICAgICMgYWxzbyBhZGQgdG8gaGVyZSBpbiBwcm92aWRlcnMgbGlzdCBzbyB3ZSBjYW4gbG9vayBpdCB1cCB3aGVuIHBhcnNpbmcgdXJsIGhhc2hcbiAgICAgICAgICAgIEBwcm92aWRlcnNbcHJvdmlkZXIudXJsRGlzcGxheU5hbWVdID0gcHJvdmlkZXJcbiAgICAgICAgICBhdmFpbGFibGVQcm92aWRlcnMucHVzaCBwcm92aWRlclxuICAgICAgICBlbHNlXG4gICAgICAgICAgQGFsZXJ0IFwiVW5rbm93biBwcm92aWRlcjogI3twcm92aWRlck5hbWV9XCJcbiAgICBAX3NldFN0YXRlXG4gICAgICBhdmFpbGFibGVQcm92aWRlcnM6IGF2YWlsYWJsZVByb3ZpZGVyc1xuICAgICAgc2hhcmVQcm92aWRlcjogc2hhcmVQcm92aWRlclxuXG4gICAgQGFwcE9wdGlvbnMudWkgb3I9IHt9XG4gICAgQGFwcE9wdGlvbnMudWkud2luZG93VGl0bGVTdWZmaXggb3I9IGRvY3VtZW50LnRpdGxlXG4gICAgQGFwcE9wdGlvbnMudWkud2luZG93VGl0bGVTZXBhcmF0b3Igb3I9ICcgLSAnXG4gICAgQF9zZXRXaW5kb3dUaXRsZSgpXG5cbiAgICBAX3VpLmluaXQgQGFwcE9wdGlvbnMudWlcblxuICAgICMgY2hlY2sgZm9yIGF1dG9zYXZlXG4gICAgaWYgQGFwcE9wdGlvbnMuYXV0b1NhdmVJbnRlcnZhbFxuICAgICAgQGF1dG9TYXZlIEBhcHBPcHRpb25zLmF1dG9TYXZlSW50ZXJ2YWxcblxuICAgICMgaW5pdGlhbGl6ZSB0aGUgY2xvdWRDb250ZW50RmFjdG9yeSB3aXRoIGFsbCBkYXRhIHdlIHdhbnQgaW4gdGhlIGVudmVsb3BlXG4gICAgY2xvdWRDb250ZW50RmFjdG9yeS5zZXRFbnZlbG9wZU1ldGFkYXRhXG4gICAgICBjZm1WZXJzaW9uOiAnX19QQUNLQUdFX1ZFUlNJT05fXycgIyByZXBsYWNlZCBieSB2ZXJzaW9uIG51bWJlciBhdCBidWlsZCB0aW1lXG4gICAgICBhcHBOYW1lOiBAYXBwT3B0aW9ucy5hcHBOYW1lIG9yIFwiXCJcbiAgICAgIGFwcFZlcnNpb246IEBhcHBPcHRpb25zLmFwcFZlcnNpb24gb3IgXCJcIlxuICAgICAgYXBwQnVpbGROdW06IEBhcHBPcHRpb25zLmFwcEJ1aWxkTnVtIG9yIFwiXCJcblxuICAgIEBuZXdGaWxlT3BlbnNJbk5ld1RhYiA9IGlmIEBhcHBPcHRpb25zLnVpPy5oYXNPd25Qcm9wZXJ0eSgnbmV3RmlsZU9wZW5zSW5OZXdUYWInKSB0aGVuIEBhcHBPcHRpb25zLnVpLm5ld0ZpbGVPcGVuc0luTmV3VGFiIGVsc2UgdHJ1ZVxuICAgIEBuZXdGaWxlQWRkc05ld1RvUXVlcnkgPSBAYXBwT3B0aW9ucy51aT8ubmV3RmlsZUFkZHNOZXdUb1F1ZXJ5XG5cbiAgICBAX3N0YXJ0UG9zdE1lc3NhZ2VMaXN0ZW5lcigpXG5cbiAgc2V0UHJvdmlkZXJPcHRpb25zOiAobmFtZSwgbmV3T3B0aW9ucykgLT5cbiAgICBmb3IgcHJvdmlkZXIgaW4gQHN0YXRlLmF2YWlsYWJsZVByb3ZpZGVyc1xuICAgICAgaWYgcHJvdmlkZXIubmFtZSBpcyBuYW1lXG4gICAgICAgIHByb3ZpZGVyLm9wdGlvbnMgPz0ge31cbiAgICAgICAgZm9yIGtleSBvZiBuZXdPcHRpb25zXG4gICAgICAgICAgcHJvdmlkZXIub3B0aW9uc1trZXldID0gbmV3T3B0aW9uc1trZXldXG4gICAgICAgIGJyZWFrXG5cbiAgY29ubmVjdDogLT5cbiAgICBAX2V2ZW50ICdjb25uZWN0ZWQnLCB7Y2xpZW50OiBAfVxuXG4gICNcbiAgIyBDYWxsZWQgZnJvbSBDbG91ZEZpbGVNYW5hZ2VyLmNsaWVudENvbm5lY3QgdG8gcHJvY2VzcyB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgIyBhbmQgaW5pdGlhdGUgb3BlbmluZyBhbnkgZG9jdW1lbnQgc3BlY2lmaWVkIGJ5IFVSTCBwYXJhbWV0ZXJzLiBUaGUgQ0ZNXG4gICMgaGFzaCBwYXJhbXMgYXJlIHByb2Nlc3NlZCBoZXJlIGFmdGVyIHdoaWNoIHByb3ZpZGVycyBhcmUgZ2l2ZW4gYSBjaGFuY2VcbiAgIyB0byBwcm9jZXNzIGFueSBwcm92aWRlci1zcGVjaWZpYyBVUkwgcGFyYW1ldGVycy4gQ2FsbHMgcmVhZHkoKSBpZiBub1xuICAjIGluaXRpYWwgZG9jdW1lbnQgb3BlbmluZyBvY2N1cnMuXG4gICNcbiAgcHJvY2Vzc1VybFBhcmFtczogLT5cbiAgICAjIHByb2Nlc3MgdGhlIGhhc2ggcGFyYW1zXG4gICAgaGFzaFBhcmFtcyA9IEBhcHBPcHRpb25zLmhhc2hQYXJhbXNcbiAgICBpZiBoYXNoUGFyYW1zLnNoYXJlZENvbnRlbnRJZFxuICAgICAgQG9wZW5TaGFyZWRDb250ZW50IGhhc2hQYXJhbXMuc2hhcmVkQ29udGVudElkXG4gICAgZWxzZSBpZiBoYXNoUGFyYW1zLmZpbGVQYXJhbXNcbiAgICAgIGlmIGhhc2hQYXJhbXMuZmlsZVBhcmFtcy5pbmRleE9mKFwiaHR0cFwiKSBpcyAwXG4gICAgICAgIEBvcGVuVXJsRmlsZSBoYXNoUGFyYW1zLmZpbGVQYXJhbXNcbiAgICAgIGVsc2VcbiAgICAgICAgW3Byb3ZpZGVyTmFtZSwgcHJvdmlkZXJQYXJhbXNdID0gaGFzaFBhcmFtcy5maWxlUGFyYW1zLnNwbGl0ICc6J1xuICAgICAgICBAb3BlblByb3ZpZGVyRmlsZSBwcm92aWRlck5hbWUsIHByb3ZpZGVyUGFyYW1zXG4gICAgZWxzZSBpZiBoYXNoUGFyYW1zLmNvcHlQYXJhbXNcbiAgICAgIEBvcGVuQ29waWVkRmlsZSBoYXNoUGFyYW1zLmNvcHlQYXJhbXNcbiAgICBlbHNlIGlmIGhhc2hQYXJhbXMubmV3SW5Gb2xkZXJQYXJhbXNcbiAgICAgIFtwcm92aWRlck5hbWUsIGZvbGRlcl0gPSBoYXNoUGFyYW1zLm5ld0luRm9sZGVyUGFyYW1zLnNwbGl0ICc6J1xuICAgICAgQGNyZWF0ZU5ld0luRm9sZGVyIHByb3ZpZGVyTmFtZSwgZm9sZGVyXG4gICAgZWxzZVxuICAgICAgIyBnaXZlIHByb3ZpZGVycyBhIGNoYW5jZSB0byBwcm9jZXNzIHVybCBwYXJhbXNcbiAgICAgIGZvciBwcm92aWRlciBpbiBAc3RhdGUuYXZhaWxhYmxlUHJvdmlkZXJzXG4gICAgICAgIHJldHVybiBpZiBwcm92aWRlci5oYW5kbGVVcmxQYXJhbXMoKVxuXG4gICAgICAjIGlmIG5vIHByb3ZpZGVycyBoYW5kbGVkIGl0LCB0aGVuIGp1c3Qgc2lnbmFsIHJlYWR5KClcbiAgICAgIEByZWFkeSgpXG5cbiAgcmVhZHk6IC0+XG4gICAgQF9ldmVudCAncmVhZHknXG5cbiAgcmVuZGVyZWQ6IC0+XG4gICAgQF9ldmVudCAncmVuZGVyZWQnLCB7Y2xpZW50OiBAfVxuXG4gIGxpc3RlbjogKGxpc3RlbmVyKSAtPlxuICAgIGlmIGxpc3RlbmVyXG4gICAgICBAX2xpc3RlbmVycy5wdXNoIGxpc3RlbmVyXG5cbiAgbG9nOiAoZXZlbnQsIGV2ZW50RGF0YSkgLT5cbiAgICBpZiAoQGFwcE9wdGlvbnMubG9nKVxuICAgICAgQGFwcE9wdGlvbnMubG9nIGV2ZW50LCBldmVudERhdGFcblxuICBhdXRvUHJvdmlkZXI6IChjYXBhYmlsaXR5KSAtPlxuICAgIGZvciBwcm92aWRlciBpbiBAc3RhdGUuYXZhaWxhYmxlUHJvdmlkZXJzXG4gICAgICByZXR1cm4gcHJvdmlkZXIgaWYgcHJvdmlkZXIuY2FuQXV0byBjYXBhYmlsaXR5XG5cbiAgYXBwZW5kTWVudUl0ZW06IChpdGVtKSAtPlxuICAgIEBfdWkuYXBwZW5kTWVudUl0ZW0gaXRlbTsgQFxuXG4gIHByZXBlbmRNZW51SXRlbTogKGl0ZW0pIC0+XG4gICAgQF91aS5wcmVwZW5kTWVudUl0ZW0gaXRlbTsgQFxuXG4gIHJlcGxhY2VNZW51SXRlbTogKGtleSwgaXRlbSkgLT5cbiAgICBAX3VpLnJlcGxhY2VNZW51SXRlbSBrZXksIGl0ZW07IEBcblxuICBpbnNlcnRNZW51SXRlbUJlZm9yZTogKGtleSwgaXRlbSkgLT5cbiAgICBAX3VpLmluc2VydE1lbnVJdGVtQmVmb3JlIGtleSwgaXRlbTsgQFxuXG4gIGluc2VydE1lbnVJdGVtQWZ0ZXI6IChrZXksIGl0ZW0pIC0+XG4gICAgQF91aS5pbnNlcnRNZW51SXRlbUFmdGVyIGtleSwgaXRlbTsgQFxuXG4gIHNldE1lbnVCYXJJbmZvOiAoaW5mbykgLT5cbiAgICBAX3VpLnNldE1lbnVCYXJJbmZvIGluZm9cblxuICBuZXdGaWxlOiAoY2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIEBfY2xvc2VDdXJyZW50RmlsZSgpXG4gICAgQF9yZXNldFN0YXRlKClcbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IFwiXCJcbiAgICBAX2V2ZW50ICduZXdlZEZpbGUnLCB7Y29udGVudDogXCJcIn1cblxuICBuZXdGaWxlRGlhbG9nOiAoY2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIGlmIEBuZXdGaWxlT3BlbnNJbk5ld1RhYlxuICAgICAgd2luZG93Lm9wZW4gQGdldEN1cnJlbnRVcmwoaWYgQG5ld0ZpbGVBZGRzTmV3VG9RdWVyeSB0aGVuIFwiI25ld1wiIGVsc2UgbnVsbCksICdfYmxhbmsnXG4gICAgZWxzZSBpZiBAc3RhdGUuZGlydHlcbiAgICAgIGlmIEBfYXV0b1NhdmVJbnRlcnZhbCBhbmQgQHN0YXRlLm1ldGFkYXRhXG4gICAgICAgIEBzYXZlKClcbiAgICAgICAgQG5ld0ZpbGUoKVxuICAgICAgZWxzZVxuICAgICAgICBAY29uZmlybSB0cignfkNPTkZJUk0uTkVXX0ZJTEUnKSwgPT4gQG5ld0ZpbGUoKVxuICAgIGVsc2VcbiAgICAgIEBuZXdGaWxlKClcblxuICBvcGVuRmlsZTogKG1ldGFkYXRhLCBjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgaWYgbWV0YWRhdGE/LnByb3ZpZGVyPy5jYW4gJ2xvYWQnLCBtZXRhZGF0YVxuICAgICAgQF9ldmVudCAnd2lsbE9wZW5GaWxlJywge29wOiBcIm9wZW5GaWxlXCJ9XG4gICAgICBtZXRhZGF0YS5wcm92aWRlci5sb2FkIG1ldGFkYXRhLCAoZXJyLCBjb250ZW50KSA9PlxuICAgICAgICByZXR1cm4gQGFsZXJ0KGVyciwgPT4gQHJlYWR5KCkpIGlmIGVyclxuICAgICAgICAjIHNob3VsZCB3YWl0IHRvIGNsb3NlIGN1cnJlbnQgZmlsZSB1bnRpbCBjbGllbnQgc2lnbmFscyBvcGVuIGlzIGNvbXBsZXRlXG4gICAgICAgIEBfY2xvc2VDdXJyZW50RmlsZSgpXG4gICAgICAgIEBfZmlsZU9wZW5lZCBjb250ZW50LCBtZXRhZGF0YSwge29wZW5lZENvbnRlbnQ6IGNvbnRlbnQuY2xvbmUoKX0sIEBfZ2V0SGFzaFBhcmFtcyBtZXRhZGF0YVxuICAgICAgICBjYWxsYmFjaz8gY29udGVudCwgbWV0YWRhdGFcbiAgICAgICAgbWV0YWRhdGEucHJvdmlkZXIuZmlsZU9wZW5lZCBjb250ZW50LCBtZXRhZGF0YVxuICAgIGVsc2VcbiAgICAgIEBvcGVuRmlsZURpYWxvZyBjYWxsYmFja1xuXG4gIG9wZW5GaWxlRGlhbG9nOiAoY2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIHNob3dEaWFsb2cgPSA9PlxuICAgICAgQF91aS5vcGVuRmlsZURpYWxvZyAobWV0YWRhdGEpID0+XG4gICAgICAgIEBvcGVuRmlsZSBtZXRhZGF0YSwgY2FsbGJhY2tcbiAgICBpZiBub3QgQHN0YXRlLmRpcnR5XG4gICAgICBzaG93RGlhbG9nKClcbiAgICBlbHNlXG4gICAgICBAY29uZmlybSB0cignfkNPTkZJUk0uT1BFTl9GSUxFJyksIHNob3dEaWFsb2dcblxuICBjbG9zZUZpbGU6IChjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgQF9jbG9zZUN1cnJlbnRGaWxlKClcbiAgICBAX3Jlc2V0U3RhdGUoKVxuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gXCJcIlxuICAgIEBfZXZlbnQgJ2Nsb3NlZEZpbGUnLCB7Y29udGVudDogXCJcIn1cbiAgICBjYWxsYmFjaz8oKVxuXG4gIGNsb3NlRmlsZURpYWxvZzogKGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBpZiBub3QgQHN0YXRlLmRpcnR5XG4gICAgICBAY2xvc2VGaWxlIGNhbGxiYWNrXG4gICAgZWxzZVxuICAgICAgQGNvbmZpcm0gdHIoJ35DT05GSVJNLkNMT1NFX0ZJTEUnKSwgPT4gQGNsb3NlRmlsZSBjYWxsYmFja1xuXG4gIGltcG9ydERhdGE6IChkYXRhLCBjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgQF9ldmVudCAnaW1wb3J0ZWREYXRhJywgZGF0YVxuICAgIGNhbGxiYWNrPyBkYXRhXG5cbiAgaW1wb3J0RGF0YURpYWxvZzogKGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBAX3VpLmltcG9ydERhdGFEaWFsb2cgKGRhdGEpID0+XG4gICAgICBAaW1wb3J0RGF0YSBkYXRhLCBjYWxsYmFja1xuXG4gIHJlYWRMb2NhbEZpbGU6IChmaWxlLCBjYWxsYmFjaz1udWxsKSAtPlxuICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIub25sb2FkID0gKGxvYWRlZCkgLT5cbiAgICAgIGNhbGxiYWNrPyB7bmFtZTogZmlsZS5uYW1lLCBjb250ZW50OiBsb2FkZWQudGFyZ2V0LnJlc3VsdH1cbiAgICByZWFkZXIucmVhZEFzVGV4dCBmaWxlXG5cbiAgb3BlbkxvY2FsRmlsZTogKGZpbGUsIGNhbGxiYWNrPW51bGwpIC0+XG4gICAgQF9ldmVudCAnd2lsbE9wZW5GaWxlJywge29wOiBcIm9wZW5Mb2NhbEZpbGVcIn1cbiAgICBAcmVhZExvY2FsRmlsZSBmaWxlLCAoZGF0YSkgPT5cbiAgICAgIGNvbnRlbnQgPSBjbG91ZENvbnRlbnRGYWN0b3J5LmNyZWF0ZUVudmVsb3BlZENsb3VkQ29udGVudCBkYXRhLmNvbnRlbnRcbiAgICAgIG1ldGFkYXRhID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lXG4gICAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgQF9maWxlT3BlbmVkIGNvbnRlbnQsIG1ldGFkYXRhLCB7b3BlbmVkQ29udGVudDogY29udGVudC5jbG9uZSgpfVxuICAgICAgY2FsbGJhY2s/IGNvbnRlbnQsIG1ldGFkYXRhXG5cbiAgaW1wb3J0TG9jYWxGaWxlOiAoZmlsZSwgY2FsbGJhY2s9bnVsbCkgLT5cbiAgICBAcmVhZExvY2FsRmlsZSBmaWxlLCAoZGF0YSkgPT5cbiAgICAgIEBpbXBvcnREYXRhIGRhdGEsIGNhbGxiYWNrXG5cbiAgb3BlblNoYXJlZENvbnRlbnQ6IChpZCkgLT5cbiAgICBAX2V2ZW50ICd3aWxsT3BlbkZpbGUnLCB7b3A6IFwib3BlblNoYXJlZENvbnRlbnRcIn1cbiAgICBAc3RhdGUuc2hhcmVQcm92aWRlcj8ubG9hZFNoYXJlZENvbnRlbnQgaWQsIChlcnIsIGNvbnRlbnQsIG1ldGFkYXRhKSA9PlxuICAgICAgcmV0dXJuIEBhbGVydChlcnIsID0+IEByZWFkeSgpKSBpZiBlcnJcbiAgICAgIEBfZmlsZU9wZW5lZCBjb250ZW50LCBtZXRhZGF0YSwge292ZXJ3cml0YWJsZTogZmFsc2UsIG9wZW5lZENvbnRlbnQ6IGNvbnRlbnQuY2xvbmUoKX1cblxuICAjIG11c3QgYmUgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIHVzZXIgYWN0aW9uIChlLmcuIGNsaWNrKSB0byBhdm9pZCBwb3B1cCBibG9ja2Vyc1xuICBwYXJzZVVybEF1dGhvcml6ZUFuZE9wZW46IC0+XG4gICAgaWYgQGFwcE9wdGlvbnMuaGFzaFBhcmFtcz8uZmlsZVBhcmFtcz9cbiAgICAgIFtwcm92aWRlck5hbWUsIHByb3ZpZGVyUGFyYW1zXSA9IEBhcHBPcHRpb25zLmhhc2hQYXJhbXMuZmlsZVBhcmFtcy5zcGxpdCAnOidcbiAgICAgIHByb3ZpZGVyID0gQHByb3ZpZGVyc1twcm92aWRlck5hbWVdXG4gICAgICBpZiBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5hdXRob3JpemUgPT5cbiAgICAgICAgICBAb3BlblByb3ZpZGVyRmlsZSBwcm92aWRlck5hbWUgcHJvdmlkZXJQYXJhbXNcblxuICBjb25maXJtQXV0aG9yaXplQW5kT3BlbjogKHByb3ZpZGVyLCBwcm92aWRlclBhcmFtcykgLT5cbiAgICAjIHRyaWdnZXIgYXV0aG9yaXplKCkgZnJvbSBjb25maXJtYXRpb24gZGlhbG9nIHRvIGF2b2lkIHBvcHVwIGJsb2NrZXJzXG4gICAgQGNvbmZpcm0gdHIoXCJ+Q09ORklSTS5BVVRIT1JJWkVfT1BFTlwiKSwgPT5cbiAgICAgIHByb3ZpZGVyLmF1dGhvcml6ZSA9PlxuICAgICAgICBAX2V2ZW50ICd3aWxsT3BlbkZpbGUnLCB7b3A6IFwiY29uZmlybUF1dGhvcml6ZUFuZE9wZW5cIn1cbiAgICAgICAgcHJvdmlkZXIub3BlblNhdmVkIHByb3ZpZGVyUGFyYW1zLCAoZXJyLCBjb250ZW50LCBtZXRhZGF0YSkgPT5cbiAgICAgICAgICByZXR1cm4gQGFsZXJ0KGVycikgaWYgZXJyXG4gICAgICAgICAgQF9maWxlT3BlbmVkIGNvbnRlbnQsIG1ldGFkYXRhLCB7b3BlbmVkQ29udGVudDogY29udGVudC5jbG9uZSgpfSwgQF9nZXRIYXNoUGFyYW1zIG1ldGFkYXRhXG4gICAgICAgICAgcHJvdmlkZXIuZmlsZU9wZW5lZCBjb250ZW50LCBtZXRhZGF0YVxuXG4gIG9wZW5Qcm92aWRlckZpbGU6IChwcm92aWRlck5hbWUsIHByb3ZpZGVyUGFyYW1zKSAtPlxuICAgIHByb3ZpZGVyID0gQHByb3ZpZGVyc1twcm92aWRlck5hbWVdXG4gICAgaWYgcHJvdmlkZXJcbiAgICAgIHByb3ZpZGVyLmF1dGhvcml6ZWQgKGF1dGhvcml6ZWQpID0+XG4gICAgICAgICMgd2UgY2FuIG9wZW4gdGhlIGRvY3VtZW50IHdpdGhvdXQgYXV0aG9yaXphdGlvbiBpbiBzb21lIGNhc2VzXG4gICAgICAgIGlmIGF1dGhvcml6ZWQgb3Igbm90IHByb3ZpZGVyLmlzQXV0aG9yaXphdGlvblJlcXVpcmVkKClcbiAgICAgICAgICBAX2V2ZW50ICd3aWxsT3BlbkZpbGUnLCB7b3A6IFwib3BlblByb3ZpZGVyRmlsZVwifVxuICAgICAgICAgIHByb3ZpZGVyLm9wZW5TYXZlZCBwcm92aWRlclBhcmFtcywgKGVyciwgY29udGVudCwgbWV0YWRhdGEpID0+XG4gICAgICAgICAgICByZXR1cm4gQGFsZXJ0KGVyciwgPT4gQHJlYWR5KCkpIGlmIGVyclxuICAgICAgICAgICAgQF9maWxlT3BlbmVkIGNvbnRlbnQsIG1ldGFkYXRhLCB7b3BlbmVkQ29udGVudDogY29udGVudC5jbG9uZSgpfSwgQF9nZXRIYXNoUGFyYW1zIG1ldGFkYXRhXG4gICAgICAgICAgICBwcm92aWRlci5maWxlT3BlbmVkIGNvbnRlbnQsIG1ldGFkYXRhXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAY29uZmlybUF1dGhvcml6ZUFuZE9wZW4ocHJvdmlkZXIsIHByb3ZpZGVyUGFyYW1zKVxuICAgIGVsc2VcbiAgICAgIEBhbGVydCB0cihcIn5BTEVSVC5OT19QUk9WSURFUlwiKSwgPT4gQHJlYWR5KClcblxuICBvcGVuVXJsRmlsZTogKHVybCkgLT5cbiAgICBAdXJsUHJvdmlkZXIub3BlbkZpbGVGcm9tVXJsIHVybCwgKGVyciwgY29udGVudCwgbWV0YWRhdGEpID0+XG4gICAgICBAX2V2ZW50ICd3aWxsT3BlbkZpbGUnLCB7b3A6IFwib3BlblVybEZpbGVcIn1cbiAgICAgIHJldHVybiBAYWxlcnQoZXJyLCA9PiBAcmVhZHkoKSkgaWYgZXJyXG4gICAgICBAX2ZpbGVPcGVuZWQgY29udGVudCwgbWV0YWRhdGEsIHtvcGVuZWRDb250ZW50OiBjb250ZW50LmNsb25lKCl9LCBAX2dldEhhc2hQYXJhbXMgbWV0YWRhdGFcblxuICBjcmVhdGVOZXdJbkZvbGRlcjogKHByb3ZpZGVyTmFtZSwgZm9sZGVyKSAtPlxuICAgIHByb3ZpZGVyID0gQHByb3ZpZGVyc1twcm92aWRlck5hbWVdXG4gICAgaWYgcHJvdmlkZXIgYW5kIHByb3ZpZGVyLmNhbiAnc2V0Rm9sZGVyJywgQHN0YXRlLm1ldGFkYXRhXG4gICAgICBpZiBub3QgQHN0YXRlLm1ldGFkYXRhP1xuICAgICAgICBAc3RhdGUubWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlclxuXG4gICAgICBAc3RhdGUubWV0YWRhdGEucGFyZW50ID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgICAgdHlwZTogQ2xvdWRNZXRhZGF0YS5Gb2xkZXJcbiAgICAgICAgcHJvdmlkZXJEYXRhOlxuICAgICAgICAgIGlkOiBmb2xkZXJcblxuICAgICAgQF91aS5lZGl0SW5pdGlhbEZpbGVuYW1lKClcbiAgICBAX2V2ZW50ICduZXdlZEZpbGUnLCB7Y29udGVudDogXCJcIn1cblxuICBzZXRJbml0aWFsRmlsZW5hbWU6IChmaWxlbmFtZSkgLT5cbiAgICBAc3RhdGUubWV0YWRhdGEucmVuYW1lIGZpbGVuYW1lXG4gICAgQHNhdmUoKVxuXG4gIGlzU2F2ZUluUHJvZ3Jlc3M6IC0+XG4gICAgQHN0YXRlLnNhdmluZz9cblxuICBjb25maXJtQXV0aG9yaXplQW5kU2F2ZTogKHN0cmluZ0NvbnRlbnQsIGNhbGxiYWNrKSAtPlxuICAgICMgdHJpZ2dlciBhdXRob3JpemUoKSBmcm9tIGNvbmZpcm1hdGlvbiBkaWFsb2cgdG8gYXZvaWQgcG9wdXAgYmxvY2tlcnNcbiAgICBAY29uZmlybSB0cihcIn5DT05GSVJNLkFVVEhPUklaRV9TQVZFXCIpLCA9PlxuICAgICAgQHN0YXRlLm1ldGFkYXRhLnByb3ZpZGVyLmF1dGhvcml6ZSA9PlxuICAgICAgICBAc2F2ZUZpbGUgc3RyaW5nQ29udGVudCwgQHN0YXRlLm1ldGFkYXRhLCBjYWxsYmFja1xuXG4gIHNhdmU6IChjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgQF9ldmVudCAnZ2V0Q29udGVudCcsIHsgc2hhcmVkOiBAX3NoYXJlZE1ldGFkYXRhKCkgfSwgKHN0cmluZ0NvbnRlbnQpID0+XG4gICAgICBAc2F2ZUNvbnRlbnQgc3RyaW5nQ29udGVudCwgY2FsbGJhY2tcblxuICBzYXZlQ29udGVudDogKHN0cmluZ0NvbnRlbnQsIGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBwcm92aWRlciA9IEBzdGF0ZS5tZXRhZGF0YT8ucHJvdmlkZXIgb3IgQGF1dG9Qcm92aWRlciAnc2F2ZSdcbiAgICBpZiBwcm92aWRlcj9cbiAgICAgIHByb3ZpZGVyLmF1dGhvcml6ZWQgKGlzQXV0aG9yaXplZCkgPT5cbiAgICAgICAgIyB3ZSBjYW4gc2F2ZSB0aGUgZG9jdW1lbnQgd2l0aG91dCBhdXRob3JpemF0aW9uIGluIHNvbWUgY2FzZXNcbiAgICAgICAgaWYgaXNBdXRob3JpemVkIG9yIG5vdCBwcm92aWRlci5pc0F1dGhvcml6YXRpb25SZXF1aXJlZCgpXG4gICAgICAgICAgQHNhdmVGaWxlIHN0cmluZ0NvbnRlbnQsIEBzdGF0ZS5tZXRhZGF0YSwgY2FsbGJhY2tcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEBjb25maXJtQXV0aG9yaXplQW5kU2F2ZSBzdHJpbmdDb250ZW50LCBjYWxsYmFja1xuICAgIGVsc2VcbiAgICAgIEBzYXZlRmlsZURpYWxvZyBzdHJpbmdDb250ZW50LCBjYWxsYmFja1xuXG4gIHNhdmVGaWxlOiAoc3RyaW5nQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICAjIG11c3QgYmUgYWJsZSB0byAncmVzYXZlJyB0byBzYXZlIHNpbGVudGx5LCBpLmUuIHdpdGhvdXQgc2F2ZSBkaWFsb2dcbiAgICBpZiBtZXRhZGF0YT8ucHJvdmlkZXI/LmNhbigncmVzYXZlJywgbWV0YWRhdGEpXG4gICAgICBAc2F2ZUZpbGVOb0RpYWxvZyBzdHJpbmdDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcbiAgICBlbHNlXG4gICAgICBAc2F2ZUZpbGVEaWFsb2cgc3RyaW5nQ29udGVudCwgY2FsbGJhY2tcblxuICBzYXZlRmlsZU5vRGlhbG9nOiAoc3RyaW5nQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBAX3NldFN0YXRlXG4gICAgICBzYXZpbmc6IG1ldGFkYXRhXG4gICAgY3VycmVudENvbnRlbnQgPSBAX2NyZWF0ZU9yVXBkYXRlQ3VycmVudENvbnRlbnQgc3RyaW5nQ29udGVudCwgbWV0YWRhdGFcbiAgICBtZXRhZGF0YS5wcm92aWRlci5zYXZlIGN1cnJlbnRDb250ZW50LCBtZXRhZGF0YSwgKGVyciwgc3RhdHVzQ29kZSkgPT5cbiAgICAgIGlmIGVyclxuICAgICAgICAjIGRpc2FibGUgYXV0b3NhdmUgb24gc2F2ZSBmYWlsdXJlOyBjbGVhciBcIlNhdmluZy4uLlwiIG1lc3NhZ2VcbiAgICAgICAgbWV0YWRhdGEuYXV0b1NhdmVEaXNhYmxlZCA9IHRydWVcbiAgICAgICAgQF9zZXRTdGF0ZSB7IG1ldGFkYXRhOiBtZXRhZGF0YSwgc2F2aW5nOiBudWxsIH1cbiAgICAgICAgaWYgc3RhdHVzQ29kZSBpcyA0MDNcbiAgICAgICAgICByZXR1cm4gQGNvbmZpcm1BdXRob3JpemVBbmRTYXZlIHN0cmluZ0NvbnRlbnQsIGNhbGxiYWNrXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gQGFsZXJ0KGVycilcbiAgICAgIGlmIEBzdGF0ZS5tZXRhZGF0YSBpc250IG1ldGFkYXRhXG4gICAgICAgIEBfY2xvc2VDdXJyZW50RmlsZSgpXG4gICAgICAjIHJlZW5hYmxlIGF1dG9zYXZlIG9uIHNhdmUgc3VjY2VzcyBpZiB0aGlzIGlzbid0IGEgbG9jYWwgZmlsZSBzYXZlXG4gICAgICBkZWxldGUgbWV0YWRhdGEuYXV0b1NhdmVEaXNhYmxlZCBpZiBtZXRhZGF0YS5hdXRvU2F2ZURpc2FibGVkP1xuICAgICAgQF9maWxlQ2hhbmdlZCAnc2F2ZWRGaWxlJywgY3VycmVudENvbnRlbnQsIG1ldGFkYXRhLCB7c2F2ZWQ6IHRydWV9LCBAX2dldEhhc2hQYXJhbXMgbWV0YWRhdGFcbiAgICAgIGNhbGxiYWNrPyBjdXJyZW50Q29udGVudCwgbWV0YWRhdGFcblxuICBzYXZlRmlsZURpYWxvZzogKHN0cmluZ0NvbnRlbnQgPSBudWxsLCBjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgQF91aS5zYXZlRmlsZURpYWxvZyAobWV0YWRhdGEpID0+XG4gICAgICBAX2RpYWxvZ1NhdmUgc3RyaW5nQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrXG5cbiAgc2F2ZUZpbGVBc0RpYWxvZzogKHN0cmluZ0NvbnRlbnQgPSBudWxsLCBjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgQF91aS5zYXZlRmlsZUFzRGlhbG9nIChtZXRhZGF0YSkgPT5cbiAgICAgIEBfZGlhbG9nU2F2ZSBzdHJpbmdDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcblxuICBjcmVhdGVDb3B5OiAoc3RyaW5nQ29udGVudCA9IG51bGwsIGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBzYXZlQW5kT3BlbkNvcHkgPSAoc3RyaW5nQ29udGVudCkgPT5cbiAgICAgIEBzYXZlQ29waWVkRmlsZSBzdHJpbmdDb250ZW50LCBAc3RhdGUubWV0YWRhdGE/Lm5hbWUsIChlcnIsIGNvcHlQYXJhbXMpID0+XG4gICAgICAgIHJldHVybiBjYWxsYmFjaz8gZXJyIGlmIGVyclxuICAgICAgICB3aW5kb3cub3BlbiBAZ2V0Q3VycmVudFVybCBcIiNjb3B5PSN7Y29weVBhcmFtc31cIlxuICAgICAgICBjYWxsYmFjaz8gY29weVBhcmFtc1xuICAgIGlmIHN0cmluZ0NvbnRlbnQgaXMgbnVsbFxuICAgICAgQF9ldmVudCAnZ2V0Q29udGVudCcsIHt9LCAoc3RyaW5nQ29udGVudCkgLT5cbiAgICAgICAgc2F2ZUFuZE9wZW5Db3B5IHN0cmluZ0NvbnRlbnRcbiAgICBlbHNlXG4gICAgICBzYXZlQW5kT3BlbkNvcHkgc3RyaW5nQ29udGVudFxuXG4gIHNhdmVDb3BpZWRGaWxlOiAoc3RyaW5nQ29udGVudCwgbmFtZSwgY2FsbGJhY2spIC0+XG4gICAgdHJ5XG4gICAgICBwcmVmaXggPSAnY2ZtLWNvcHk6OidcbiAgICAgIG1heENvcHlOdW1iZXIgPSAwXG4gICAgICBmb3Igb3duIGtleSBvZiB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgICAgIGlmIGtleS5zdWJzdHIoMCwgcHJlZml4Lmxlbmd0aCkgaXMgcHJlZml4XG4gICAgICAgICAgY29weU51bWJlciA9IHBhcnNlSW50KGtleS5zdWJzdHIocHJlZml4Lmxlbmd0aCksIDEwKVxuICAgICAgICAgIG1heENvcHlOdW1iZXIgPSBNYXRoLm1heChtYXhDb3B5TnVtYmVyLCBjb3B5TnVtYmVyKVxuICAgICAgbWF4Q29weU51bWJlcisrXG4gICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5XG4gICAgICAgIG5hbWU6IGlmIG5hbWU/Lmxlbmd0aCA+IDAgdGhlbiBcIkNvcHkgb2YgI3tuYW1lfVwiIGVsc2UgXCJDb3B5IG9mIFVudGl0bGVkIERvY3VtZW50XCJcbiAgICAgICAgc3RyaW5nQ29udGVudDogc3RyaW5nQ29udGVudFxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtIFwiI3twcmVmaXh9I3ttYXhDb3B5TnVtYmVyfVwiLCB2YWx1ZVxuICAgICAgY2FsbGJhY2s/IG51bGwsIG1heENvcHlOdW1iZXJcbiAgICBjYXRjaCBlXG4gICAgICBjYWxsYmFjayBcIlVuYWJsZSB0byB0ZW1wb3JhcmlseSBzYXZlIGNvcGllZCBmaWxlXCJcblxuICBvcGVuQ29waWVkRmlsZTogKGNvcHlQYXJhbXMpIC0+XG4gICAgQF9ldmVudCAnd2lsbE9wZW5GaWxlJywge29wOiBcIm9wZW5Db3BpZWRGaWxlXCJ9XG4gICAgdHJ5XG4gICAgICBrZXkgPSBcImNmbS1jb3B5Ojoje2NvcHlQYXJhbXN9XCJcbiAgICAgIGNvcGllZCA9IEpTT04ucGFyc2Ugd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtIGtleVxuICAgICAgY29udGVudCA9IGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGNvcGllZC5zdHJpbmdDb250ZW50XG4gICAgICBtZXRhZGF0YSA9IG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICAgIG5hbWU6IGNvcGllZC5uYW1lXG4gICAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIlwiXG4gICAgICBAX2ZpbGVPcGVuZWQgY29udGVudCwgbWV0YWRhdGEsIHtkaXJ0eTogdHJ1ZSwgb3BlbmVkQ29udGVudDogY29udGVudC5jbG9uZSgpfVxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtIGtleVxuICAgIGNhdGNoIGVcbiAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIGxvYWQgY29waWVkIGZpbGVcIlxuXG4gIF9zaGFyZWRNZXRhZGF0YTogLT5cbiAgICBAc3RhdGUuY3VycmVudENvbnRlbnQ/LmdldFNoYXJlZE1ldGFkYXRhKCkgb3Ige31cblxuICBzaGFyZUdldExpbms6IC0+XG4gICAgQF91aS5zaGFyZURpYWxvZyBAXG5cbiAgc2hhcmVVcGRhdGU6IC0+XG4gICAgQHNoYXJlID0+IEBhbGVydCAodHIgXCJ+U0hBUkVfVVBEQVRFLk1FU1NBR0VcIiksICh0ciBcIn5TSEFSRV9VUERBVEUuVElUTEVcIilcblxuICB0b2dnbGVTaGFyZTogKGNhbGxiYWNrKSAtPlxuICAgIGlmIEBpc1NoYXJlZCgpXG4gICAgICBAdW5zaGFyZSBjYWxsYmFja1xuICAgIGVsc2VcbiAgICAgIEBzaGFyZSBjYWxsYmFja1xuXG4gIGlzU2hhcmVkOiAtPlxuICAgIEBzdGF0ZS5jdXJyZW50Q29udGVudD8uZ2V0KFwic2hhcmVkRG9jdW1lbnRJZFwiKSBhbmQgbm90IEBzdGF0ZS5jdXJyZW50Q29udGVudD8uZ2V0KFwiaXNVbnNoYXJlZFwiKVxuXG4gIGNhbkVkaXRTaGFyZWQ6IC0+XG4gICAgYWNjZXNzS2V5cyA9IEBzdGF0ZS5jdXJyZW50Q29udGVudD8uZ2V0KFwiYWNjZXNzS2V5c1wiKSBvciB7fVxuICAgIHNoYXJlRWRpdEtleSA9IEBzdGF0ZS5jdXJyZW50Q29udGVudD8uZ2V0KFwic2hhcmVFZGl0S2V5XCIpXG4gICAgKHNoYXJlRWRpdEtleSBvciBhY2Nlc3NLZXlzLnJlYWRXcml0ZSkgYW5kIG5vdCBAc3RhdGUuY3VycmVudENvbnRlbnQ/LmdldChcImlzVW5zaGFyZWRcIilcblxuICBzZXRTaGFyZVN0YXRlOiAoc2hhcmVkLCBjYWxsYmFjaykgLT5cbiAgICBpZiBAc3RhdGUuc2hhcmVQcm92aWRlclxuICAgICAgc2hhcmluZ01ldGFkYXRhID0gQHN0YXRlLnNoYXJlUHJvdmlkZXIuZ2V0U2hhcmluZ01ldGFkYXRhIHNoYXJlZFxuICAgICAgQF9ldmVudCAnZ2V0Q29udGVudCcsIHsgc2hhcmVkOiBzaGFyaW5nTWV0YWRhdGEgfSwgKHN0cmluZ0NvbnRlbnQpID0+XG4gICAgICAgIEBfc2V0U3RhdGVcbiAgICAgICAgICBzaGFyaW5nOiBzaGFyZWRcbiAgICAgICAgc2hhcmVkQ29udGVudCA9IGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IHN0cmluZ0NvbnRlbnRcbiAgICAgICAgc2hhcmVkQ29udGVudC5hZGRNZXRhZGF0YSBzaGFyaW5nTWV0YWRhdGFcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBAX2NyZWF0ZU9yVXBkYXRlQ3VycmVudENvbnRlbnQgc3RyaW5nQ29udGVudCwgQHN0YXRlLm1ldGFkYXRhXG4gICAgICAgIHNoYXJlZENvbnRlbnQuc2V0KCdkb2NOYW1lJywgY3VycmVudENvbnRlbnQuZ2V0KCdkb2NOYW1lJykpXG4gICAgICAgIGlmIHNoYXJlZFxuICAgICAgICAgIGN1cnJlbnRDb250ZW50LnJlbW92ZSAnaXNVbnNoYXJlZCdcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cnJlbnRDb250ZW50LnNldCAnaXNVbnNoYXJlZCcsIHRydWVcbiAgICAgICAgQHN0YXRlLnNoYXJlUHJvdmlkZXIuc2hhcmUgc2hhcmVkLCBjdXJyZW50Q29udGVudCwgc2hhcmVkQ29udGVudCwgQHN0YXRlLm1ldGFkYXRhLCAoZXJyLCBzaGFyZWRDb250ZW50SWQpID0+XG4gICAgICAgICAgcmV0dXJuIEBhbGVydChlcnIpIGlmIGVyclxuICAgICAgICAgIGNhbGxiYWNrPyBudWxsLCBzaGFyZWRDb250ZW50SWQsIGN1cnJlbnRDb250ZW50XG5cbiAgc2hhcmU6IChjYWxsYmFjaykgLT5cbiAgICBAc2V0U2hhcmVTdGF0ZSB0cnVlLCAoZXJyLCBzaGFyZWRDb250ZW50SWQsIGN1cnJlbnRDb250ZW50KSA9PlxuICAgICAgQF9maWxlQ2hhbmdlZCAnc2hhcmVkRmlsZScsIGN1cnJlbnRDb250ZW50LCBAc3RhdGUubWV0YWRhdGFcbiAgICAgIGNhbGxiYWNrPyBudWxsLCBzaGFyZWRDb250ZW50SWRcblxuICB1bnNoYXJlOiAoY2FsbGJhY2spIC0+XG4gICAgQHNldFNoYXJlU3RhdGUgZmFsc2UsIChlcnIsIHNoYXJlZENvbnRlbnRJZCwgY3VycmVudENvbnRlbnQpID0+XG4gICAgICBAX2ZpbGVDaGFuZ2VkICd1bnNoYXJlZEZpbGUnLCBjdXJyZW50Q29udGVudCwgQHN0YXRlLm1ldGFkYXRhXG4gICAgICBjYWxsYmFjaz8gbnVsbFxuXG4gIHJldmVydFRvU2hhcmVkOiAoY2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIGlkID0gQHN0YXRlLmN1cnJlbnRDb250ZW50Py5nZXQoXCJzaGFyZWREb2N1bWVudElkXCIpXG4gICAgaWYgaWQgYW5kIEBzdGF0ZS5zaGFyZVByb3ZpZGVyP1xuICAgICAgQHN0YXRlLnNoYXJlUHJvdmlkZXIubG9hZFNoYXJlZENvbnRlbnQgaWQsIChlcnIsIGNvbnRlbnQsIG1ldGFkYXRhKSA9PlxuICAgICAgICByZXR1cm4gQGFsZXJ0KGVycikgaWYgZXJyXG4gICAgICAgIEBzdGF0ZS5jdXJyZW50Q29udGVudC5jb3B5TWV0YWRhdGFUbyBjb250ZW50XG4gICAgICAgIGlmIG5vdCBtZXRhZGF0YS5uYW1lIGFuZCBkb2NOYW1lID0gY29udGVudC5nZXQoJ2RvY05hbWUnKVxuICAgICAgICAgIG1ldGFkYXRhLm5hbWUgPSBkb2NOYW1lXG4gICAgICAgIEBfZmlsZU9wZW5lZCBjb250ZW50LCBtZXRhZGF0YSwge2RpcnR5OiB0cnVlLCBvcGVuZWRDb250ZW50OiBjb250ZW50LmNsb25lKCl9XG4gICAgICAgIGNhbGxiYWNrPyBudWxsXG5cbiAgcmV2ZXJ0VG9TaGFyZWREaWFsb2c6IChjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgaWYgQHN0YXRlLmN1cnJlbnRDb250ZW50Py5nZXQoXCJzaGFyZWREb2N1bWVudElkXCIpIGFuZCBAc3RhdGUuc2hhcmVQcm92aWRlcj9cbiAgICAgIEBjb25maXJtIHRyKFwifkNPTkZJUk0uUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCIpLCA9PiBAcmV2ZXJ0VG9TaGFyZWQgY2FsbGJhY2tcblxuICBkb3dubG9hZERpYWxvZzogKGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICAjIHNob3VsZCBzaGFyZSBtZXRhZGF0YSBiZSBpbmNsdWRlZCBpbiBkb3dubG9hZGVkIGxvY2FsIGZpbGVzP1xuICAgIEBfZXZlbnQgJ2dldENvbnRlbnQnLCB7IHNoYXJlZDogQF9zaGFyZWRNZXRhZGF0YSgpIH0sIChjb250ZW50KSA9PlxuICAgICAgZW52ZWxvcGVkQ29udGVudCA9IGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGNvbnRlbnRcbiAgICAgIEBzdGF0ZS5jdXJyZW50Q29udGVudD8uY29weU1ldGFkYXRhVG8gZW52ZWxvcGVkQ29udGVudFxuICAgICAgQF91aS5kb3dubG9hZERpYWxvZyBAc3RhdGUubWV0YWRhdGE/Lm5hbWUsIGVudmVsb3BlZENvbnRlbnQsIGNhbGxiYWNrXG5cbiAgZ2V0RG93bmxvYWRCbG9iOiAoY29udGVudCwgaW5jbHVkZVNoYXJlSW5mbywgbWltZVR5cGU9J3RleHQvcGxhaW4nKSAtPlxuICAgIGlmIHR5cGVvZiBjb250ZW50IGlzIFwic3RyaW5nXCJcbiAgICAgIGlmIG1pbWVUeXBlLmluZGV4T2YoXCJpbWFnZVwiKSA+PSAwXG4gICAgICAgIGNvbnRlbnRUb1NhdmUgPSBiYXNlNjRBcnJheS50b0J5dGVBcnJheShjb250ZW50KVxuICAgICAgZWxzZVxuICAgICAgICBjb250ZW50VG9TYXZlID0gY29udGVudFxuXG4gICAgZWxzZSBpZiBpbmNsdWRlU2hhcmVJbmZvXG4gICAgICBjb250ZW50VG9TYXZlID0gSlNPTi5zdHJpbmdpZnkoY29udGVudC5nZXRDb250ZW50KCkpXG5cbiAgICBlbHNlICMgbm90IGluY2x1ZGVTaGFyZUluZm9cbiAgICAgICMgY2xvbmUgdGhlIGRvY3VtZW50IHNvIHdlIGNhbiBkZWxldGUgdGhlIHNoYXJlIGluZm8gYW5kIG5vdCBhZmZlY3QgdGhlIG9yaWdpbmFsXG4gICAgICBqc29uID0gY29udGVudC5jbG9uZSgpLmdldENvbnRlbnQoKVxuICAgICAgZGVsZXRlIGpzb24uc2hhcmVkRG9jdW1lbnRJZFxuICAgICAgZGVsZXRlIGpzb24uc2hhcmVFZGl0S2V5XG4gICAgICBkZWxldGUganNvbi5pc1Vuc2hhcmVkXG4gICAgICBkZWxldGUganNvbi5hY2Nlc3NLZXlzXG4gICAgICAjIENPREFQIG1vdmVzIHRoZSBrZXlzIGludG8gaXRzIG93biBuYW1lc3BhY2VcbiAgICAgIGRlbGV0ZSBqc29uLm1ldGFkYXRhLnNoYXJlZCBpZiBqc29uLm1ldGFkYXRhPy5zaGFyZWQ/XG4gICAgICBjb250ZW50VG9TYXZlID0gSlNPTi5zdHJpbmdpZnkoanNvbilcblxuICAgIG5ldyBCbG9iKFtjb250ZW50VG9TYXZlXSwge3R5cGU6IG1pbWVUeXBlfSlcblxuICBnZXREb3dubG9hZFVybDogKGNvbnRlbnQsIGluY2x1ZGVTaGFyZUluZm8sIG1pbWVUeXBlPSd0ZXh0L3BsYWluJykgLT5cbiAgICB3VVJMID0gd2luZG93LlVSTCBvciB3aW5kb3cud2Via2l0VVJMXG4gICAgd1VSTC5jcmVhdGVPYmplY3RVUkwoQGdldERvd25sb2FkQmxvYiBjb250ZW50LCBpbmNsdWRlU2hhcmVJbmZvLCBtaW1lVHlwZSkgaWYgd1VSTFxuXG4gIHJlbmFtZTogKG1ldGFkYXRhLCBuZXdOYW1lLCBjYWxsYmFjaykgLT5cbiAgICBkaXJ0eSA9IEBzdGF0ZS5kaXJ0eVxuICAgIF9yZW5hbWUgPSAobWV0YWRhdGEpID0+XG4gICAgICBAc3RhdGUuY3VycmVudENvbnRlbnQ/LmFkZE1ldGFkYXRhIGRvY05hbWU6IG1ldGFkYXRhLm5hbWVcbiAgICAgIEBfZmlsZUNoYW5nZWQgJ3JlbmFtZWRGaWxlJywgQHN0YXRlLmN1cnJlbnRDb250ZW50LCBtZXRhZGF0YSwge2RpcnR5OiBkaXJ0eX0sIEBfZ2V0SGFzaFBhcmFtcyBtZXRhZGF0YVxuICAgICAgY2FsbGJhY2s/IG5ld05hbWVcbiAgICBpZiBuZXdOYW1lIGlzbnQgQHN0YXRlLm1ldGFkYXRhPy5uYW1lXG4gICAgICBpZiBAc3RhdGUubWV0YWRhdGE/LnByb3ZpZGVyPy5jYW4gJ3JlbmFtZScsIG1ldGFkYXRhXG4gICAgICAgIEBzdGF0ZS5tZXRhZGF0YS5wcm92aWRlci5yZW5hbWUgQHN0YXRlLm1ldGFkYXRhLCBuZXdOYW1lLCAoZXJyLCBtZXRhZGF0YSkgPT5cbiAgICAgICAgICByZXR1cm4gQGFsZXJ0KGVycikgaWYgZXJyXG4gICAgICAgICAgX3JlbmFtZSBtZXRhZGF0YVxuICAgICAgZWxzZVxuICAgICAgICBpZiBtZXRhZGF0YVxuICAgICAgICAgIG1ldGFkYXRhLm5hbWUgPSBuZXdOYW1lXG4gICAgICAgICAgbWV0YWRhdGEuZmlsZW5hbWUgPSBuZXdOYW1lXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICAgICAgICBuYW1lOiBuZXdOYW1lXG4gICAgICAgICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkZpbGVcbiAgICAgICAgX3JlbmFtZSBtZXRhZGF0YVxuXG4gIHJlbmFtZURpYWxvZzogKGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBAX3VpLnJlbmFtZURpYWxvZyBAc3RhdGUubWV0YWRhdGE/Lm5hbWUsIChuZXdOYW1lKSA9PlxuICAgICAgQHJlbmFtZSBAc3RhdGUubWV0YWRhdGEsIG5ld05hbWUsIGNhbGxiYWNrXG5cbiAgcmV2ZXJ0VG9MYXN0T3BlbmVkOiAoY2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIEBfZXZlbnQgJ3dpbGxPcGVuRmlsZScsIHtvcDogXCJyZXZlcnRUb0xhc3RPcGVuZWRcIn1cbiAgICBpZiBAc3RhdGUub3BlbmVkQ29udGVudD8gYW5kIEBzdGF0ZS5tZXRhZGF0YVxuICAgICAgQF9maWxlT3BlbmVkIEBzdGF0ZS5vcGVuZWRDb250ZW50LCBAc3RhdGUubWV0YWRhdGEsIHtvcGVuZWRDb250ZW50OiBAc3RhdGUub3BlbmVkQ29udGVudC5jbG9uZSgpfVxuXG4gIHJldmVydFRvTGFzdE9wZW5lZERpYWxvZzogKGNhbGxiYWNrID0gbnVsbCkgLT5cbiAgICBpZiBAc3RhdGUub3BlbmVkQ29udGVudD8gYW5kIEBzdGF0ZS5tZXRhZGF0YVxuICAgICAgQGNvbmZpcm0gdHIoJ35DT05GSVJNLlJFVkVSVF9UT19MQVNUX09QRU5FRCcpLCA9PiBAcmV2ZXJ0VG9MYXN0T3BlbmVkIGNhbGxiYWNrXG4gICAgZWxzZVxuICAgICAgY2FsbGJhY2s/ICdObyBpbml0aWFsIG9wZW5lZCB2ZXJzaW9uIHdhcyBmb3VuZCBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZSdcblxuICBzYXZlU2Vjb25kYXJ5RmlsZUFzRGlhbG9nOiAoc3RyaW5nQ29udGVudCwgZXh0ZW5zaW9uLCBtaW1lVHlwZSwgY2FsbGJhY2spIC0+XG4gICAgaWYgKHByb3ZpZGVyID0gQGF1dG9Qcm92aWRlciAnZXhwb3J0JylcbiAgICAgIG1ldGFkYXRhID0geyBwcm92aWRlciwgZXh0ZW5zaW9uLCBtaW1lVHlwZSB9XG4gICAgICBAc2F2ZVNlY29uZGFyeUZpbGUgc3RyaW5nQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrXG4gICAgZWxzZVxuICAgICAgZGF0YSA9IHsgY29udGVudDogc3RyaW5nQ29udGVudCwgZXh0ZW5zaW9uLCBtaW1lVHlwZSB9XG4gICAgICBAX3VpLnNhdmVTZWNvbmRhcnlGaWxlQXNEaWFsb2cgZGF0YSwgKG1ldGFkYXRhKSA9PlxuICAgICAgICAjIHJlcGxhY2UgZGVmYXVsdHNcbiAgICAgICAgaWYgZXh0ZW5zaW9uXG4gICAgICAgICAgbWV0YWRhdGEuZmlsZW5hbWUgPSBDbG91ZE1ldGFkYXRhLm5ld0V4dGVuc2lvbiBtZXRhZGF0YS5maWxlbmFtZSwgZXh0ZW5zaW9uXG4gICAgICAgIGlmIG1pbWVUeXBlXG4gICAgICAgICAgbWV0YWRhdGEubWltZVR5cGUgPSBtaW1lVHlwZVxuXG4gICAgICAgIEBzYXZlU2Vjb25kYXJ5RmlsZSBzdHJpbmdDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcblxuICAjIFNhdmVzIGEgZmlsZSB0byBiYWNrZW5kLCBidXQgZG9lcyBub3QgdXBkYXRlIGN1cnJlbnQgbWV0YWRhdGEuXG4gICMgVXNlZCBlLmcuIHdoZW4gZXhwb3J0aW5nIC5jc3YgZmlsZXMgZnJvbSBDT0RBUFxuICBzYXZlU2Vjb25kYXJ5RmlsZTogKHN0cmluZ0NvbnRlbnQsIG1ldGFkYXRhLCBjYWxsYmFjayA9IG51bGwpIC0+XG4gICAgaWYgbWV0YWRhdGE/LnByb3ZpZGVyPy5jYW4gJ2V4cG9ydCcsIG1ldGFkYXRhXG4gICAgICBtZXRhZGF0YS5wcm92aWRlci5zYXZlQXNFeHBvcnQgc3RyaW5nQ29udGVudCwgbWV0YWRhdGEsIChlcnIsIHN0YXR1c0NvZGUpID0+XG4gICAgICAgIGlmIGVyclxuICAgICAgICAgIHJldHVybiBAYWxlcnQoZXJyKVxuICAgICAgICBjYWxsYmFjaz8gc3RyaW5nQ29udGVudCwgbWV0YWRhdGFcblxuICBkaXJ0eTogKGlzRGlydHkgPSB0cnVlKS0+XG4gICAgQF9zZXRTdGF0ZVxuICAgICAgZGlydHk6IGlzRGlydHlcbiAgICAgIHNhdmVkOiBAc3RhdGUuc2F2ZWQgYW5kIG5vdCBpc0RpcnR5XG4gICAgaWYgd2luZG93LnNlbGYgaXNudCB3aW5kb3cudG9wXG4gICAgICAjIHBvc3QgdG8gcGFyZW50IGFuZCBub3QgdG9wIHdpbmRvdyAobm90IGEgYnVnIGV2ZW4gdGhvdWdoIHdlIHRlc3QgZm9yIHNlbGYgaW5zdCB0b3AgYWJvdmUpXG4gICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHt0eXBlOiBcImNmbTo6c2V0RGlydHlcIiwgaXNEaXJ0eTogaXNEaXJ0eX0sIFwiKlwiKVxuXG4gIHNob3VsZEF1dG9TYXZlOiA9PlxuICAgIEBzdGF0ZS5kaXJ0eSBhbmRcbiAgICAgIG5vdCBAc3RhdGUubWV0YWRhdGE/LmF1dG9TYXZlRGlzYWJsZWQgYW5kXG4gICAgICBub3QgQGlzU2F2ZUluUHJvZ3Jlc3MoKSBhbmRcbiAgICAgIEBzdGF0ZS5tZXRhZGF0YT8ucHJvdmlkZXI/LmNhbiAncmVzYXZlJywgQHN0YXRlLm1ldGFkYXRhXG5cbiAgYXV0b1NhdmU6IChpbnRlcnZhbCkgLT5cbiAgICBpZiBAX2F1dG9TYXZlSW50ZXJ2YWxcbiAgICAgIGNsZWFySW50ZXJ2YWwgQF9hdXRvU2F2ZUludGVydmFsXG5cbiAgICAjIGluIGNhc2UgdGhlIGNhbGxlciB1c2VzIG1pbGxpc2Vjb25kc1xuICAgIGlmIGludGVydmFsID4gMTAwMFxuICAgICAgaW50ZXJ2YWwgPSBNYXRoLnJvdW5kKGludGVydmFsIC8gMTAwMClcbiAgICBpZiBpbnRlcnZhbCA+IDBcbiAgICAgIEBfYXV0b1NhdmVJbnRlcnZhbCA9IHNldEludGVydmFsICg9PiBAc2F2ZSgpIGlmIEBzaG91bGRBdXRvU2F2ZSgpKSwgKGludGVydmFsICogMTAwMClcblxuICBpc0F1dG9TYXZpbmc6IC0+XG4gICAgQF9hdXRvU2F2ZUludGVydmFsP1xuXG4gIGNoYW5nZUxhbmd1YWdlOiAobmV3TGFuZ0NvZGUsIGNhbGxiYWNrKSAtPlxuICAgIGlmIGNhbGxiYWNrXG4gICAgICBpZiBub3QgQHN0YXRlLmRpcnR5XG4gICAgICAgIGNhbGxiYWNrIG5ld0xhbmdDb2RlXG4gICAgICBlbHNlXG4gICAgICAgIEBjb25maXJtIHRyKCd+Q09ORklSTS5DSEFOR0VfTEFOR1VBR0UnKSwgLT4gY2FsbGJhY2sgbmV3TGFuZ0NvZGVcblxuICBzaG93QmxvY2tpbmdNb2RhbDogKG1vZGFsUHJvcHMpIC0+XG4gICAgQF91aS5zaG93QmxvY2tpbmdNb2RhbCBtb2RhbFByb3BzXG5cbiAgaGlkZUJsb2NraW5nTW9kYWw6IC0+XG4gICAgQF91aS5oaWRlQmxvY2tpbmdNb2RhbCgpXG5cbiAgZ2V0Q3VycmVudFVybDogKHF1ZXJ5U3RyaW5nID0gbnVsbCkgLT5cbiAgICBzdWZmaXggPSBpZiBxdWVyeVN0cmluZz8gdGhlbiBcIj8je3F1ZXJ5U3RyaW5nfVwiIGVsc2UgXCJcIlxuICAgICMgQ2hlY2sgYnJvd3NlciBzdXBwb3J0IGZvciBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4gKCYgd2luZG93LmxvY2F0aW9uLm9yaWdpbilcbiAgICBcIiN7ZG9jdW1lbnQubG9jYXRpb24ub3JpZ2lufSN7ZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWV9I3tzdWZmaXh9XCJcblxuICAjIFRha2VzIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHVybCBwYXJhbWV0ZXJzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgVVJMLlxuICAjIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzIGZyb20gdGhlIFVSTCBhbmQgdGhlbiB1c2VzIHRoZSBoaXN0b3J5IEFQSSdzXG4gICMgcHVzaFN0YXRlKCkgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgVVJMIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICAjIEFkYXB0ZWQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTY1NDQzNi5cbiAgcmVtb3ZlUXVlcnlQYXJhbXM6IChwYXJhbXMpIC0+XG4gICAgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICBoYXNoID0gdXJsLnNwbGl0KCcjJylcblxuICAgIGZvciBrZXkgaW4gcGFyYW1zXG4gICAgICByZSA9IG5ldyBSZWdFeHAoXCIoWz8mXSlcIiArIGtleSArIFwiPS4qPygmfCN8JCkoLiopXCIsIFwiZ1wiKVxuXG4gICAgICBpZiByZS50ZXN0KHVybClcbiAgICAgICAgaGFzaFswXSA9IGhhc2hbMF0ucmVwbGFjZShyZSwgJyQxJDMnKS5yZXBsYWNlKC8oJnxcXD8pJC8sICcnKVxuXG4gICAgdXJsID0gaGFzaFswXSArIGlmIGhhc2hbMV0/IHRoZW4gJyMnICsgaGFzaFsxXSBlbHNlICcnXG5cbiAgICBpZiB1cmwgaXNudCB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUgeyBvcmlnaW5hbFVybDogd2luZG93LmxvY2F0aW9uLmhyZWYgfSwgJycsIHVybFxuXG4gIGNvbmZpcm06IChtZXNzYWdlLCBjYWxsYmFjaykgLT5cbiAgICBAY29uZmlybURpYWxvZyB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGNhbGxiYWNrOiBjYWxsYmFjayB9XG5cbiAgY29uZmlybURpYWxvZzogKHBhcmFtcykgLT5cbiAgICBAX3VpLmNvbmZpcm1EaWFsb2cgcGFyYW1zXG5cbiAgYWxlcnQ6IChtZXNzYWdlLCB0aXRsZU9yQ2FsbGJhY2ssIGNhbGxiYWNrKSAtPlxuICAgIGlmIF8uaXNGdW5jdGlvbih0aXRsZU9yQ2FsbGJhY2spXG4gICAgICBjYWxsYmFjayA9IHRpdGxlT3JDYWxsYmFja1xuICAgICAgdGl0bGVPckNhbGxiYWNrID0gbnVsbFxuICAgIEBfdWkuYWxlcnREaWFsb2cgbWVzc2FnZSwgKHRpdGxlT3JDYWxsYmFjayBvciB0ciBcIn5DTElFTlRfRVJST1IuVElUTEVcIiksIGNhbGxiYWNrXG5cbiAgX2RpYWxvZ1NhdmU6IChzdHJpbmdDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgaWYgc3RyaW5nQ29udGVudCBpc250IG51bGxcbiAgICAgIEBzYXZlRmlsZU5vRGlhbG9nIHN0cmluZ0NvbnRlbnQsIG1ldGFkYXRhLCBjYWxsYmFja1xuICAgIGVsc2VcbiAgICAgIEBfZXZlbnQgJ2dldENvbnRlbnQnLCB7IHNoYXJlZDogQF9zaGFyZWRNZXRhZGF0YSgpIH0sIChzdHJpbmdDb250ZW50KSA9PlxuICAgICAgICBAc2F2ZUZpbGVOb0RpYWxvZyBzdHJpbmdDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcblxuICBfZmlsZUNoYW5nZWQ6ICh0eXBlLCBjb250ZW50LCBtZXRhZGF0YSwgYWRkaXRpb25hbFN0YXRlPXt9LCBoYXNoUGFyYW1zPW51bGwpIC0+XG4gICAgbWV0YWRhdGE/Lm92ZXJ3cml0YWJsZSA/PSB0cnVlXG4gICAgQF91cGRhdGVTdGF0ZSBjb250ZW50LCBtZXRhZGF0YSwgYWRkaXRpb25hbFN0YXRlLCBoYXNoUGFyYW1zXG4gICAgQF9ldmVudCB0eXBlLCB7IGNvbnRlbnQ6IGNvbnRlbnQ/LmdldENsaWVudENvbnRlbnQoKSwgc2hhcmVkOiBAX3NoYXJlZE1ldGFkYXRhKCkgfVxuXG4gIF9maWxlT3BlbmVkOiAoY29udGVudCwgbWV0YWRhdGEsIGFkZGl0aW9uYWxTdGF0ZT17fSwgaGFzaFBhcmFtcz1udWxsKSAtPlxuICAgIGV2ZW50RGF0YSA9IHsgY29udGVudDogY29udGVudD8uZ2V0Q2xpZW50Q29udGVudCgpIH1cbiAgICAjIHVwZGF0ZSBzdGF0ZSBiZWZvcmUgc2VuZGluZyAnb3BlbmVkRmlsZScgZXZlbnRzIHNvIHRoYXQgJ29wZW5lZEZpbGUnIGxpc3RlbmVycyB0aGF0XG4gICAgIyByZWZlcmVuY2Ugc3RhdGUgaGF2ZSB0aGUgdXBkYXRlZCBzdGF0ZSB2YWx1ZXNcbiAgICBAX3VwZGF0ZVN0YXRlIGNvbnRlbnQsIG1ldGFkYXRhLCBhZGRpdGlvbmFsU3RhdGUsIGhhc2hQYXJhbXNcbiAgICAjIGFkZCBtZXRhZGF0YSBjb250ZW50VHlwZSB0byBldmVudCBmb3IgQ09EQVAgdG8gbG9hZCB2aWEgcG9zdG1lc3NhZ2UgQVBJIChmb3IgU2FnZU1vZGVsZXIgc3RhbmRhbG9uZSlcbiAgICBjb250ZW50VHlwZSA9IG1ldGFkYXRhLm1pbWVUeXBlIG9yIG1ldGFkYXRhLmNvbnRlbnRUeXBlXG4gICAgZXZlbnREYXRhLm1ldGFkYXRhID0ge2NvbnRlbnRUeXBlfSBpZiBjb250ZW50VHlwZVxuICAgIEBfZXZlbnQgJ29wZW5lZEZpbGUnLCBldmVudERhdGEsIChpRXJyb3IsIGlTaGFyZWRNZXRhZGF0YSkgPT5cbiAgICAgIHJldHVybiBAYWxlcnQoaUVycm9yLCA9PiBAcmVhZHkoKSkgaWYgaUVycm9yXG5cbiAgICAgIG1ldGFkYXRhPy5vdmVyd3JpdGFibGUgPz0gdHJ1ZVxuICAgICAgaWYgbm90IEBhcHBPcHRpb25zLndyYXBGaWxlQ29udGVudFxuICAgICAgICBjb250ZW50LmFkZE1ldGFkYXRhIGlTaGFyZWRNZXRhZGF0YVxuICAgICAgIyBhbmQgdGhlbiB1cGRhdGUgc3RhdGUgYWdhaW4gZm9yIHRoZSBtZXRhZGF0YSBhbmQgY29udGVudCBjaGFuZ2VzXG4gICAgICBAX3VwZGF0ZVN0YXRlIGNvbnRlbnQsIG1ldGFkYXRhLCBhZGRpdGlvbmFsU3RhdGUsIGhhc2hQYXJhbXNcbiAgICAgIEByZWFkeSgpXG5cbiAgX3VwZGF0ZVN0YXRlOiAoY29udGVudCwgbWV0YWRhdGEsIGFkZGl0aW9uYWxTdGF0ZT17fSwgaGFzaFBhcmFtcz1udWxsKSAtPlxuICAgIHN0YXRlID1cbiAgICAgIGN1cnJlbnRDb250ZW50OiBjb250ZW50XG4gICAgICBtZXRhZGF0YTogbWV0YWRhdGFcbiAgICAgIHNhdmluZzogbnVsbFxuICAgICAgc2F2ZWQ6IGZhbHNlXG4gICAgICBkaXJ0eTogbm90IGFkZGl0aW9uYWxTdGF0ZS5zYXZlZCBhbmQgY29udGVudD8ucmVxdWlyZXNDb252ZXJzaW9uKClcbiAgICBmb3Igb3duIGtleSwgdmFsdWUgb2YgYWRkaXRpb25hbFN0YXRlXG4gICAgICBzdGF0ZVtrZXldID0gdmFsdWVcbiAgICBAX3NldFdpbmRvd1RpdGxlIG1ldGFkYXRhPy5uYW1lXG4gICAgaWYgaGFzaFBhcmFtcyBpc250IG51bGxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaFBhcmFtc1xuICAgIEBfc2V0U3RhdGUgc3RhdGVcblxuICBfZXZlbnQ6ICh0eXBlLCBkYXRhID0ge30sIGV2ZW50Q2FsbGJhY2sgPSBudWxsKSAtPlxuICAgIGV2ZW50ID0gbmV3IENsb3VkRmlsZU1hbmFnZXJDbGllbnRFdmVudCB0eXBlLCBkYXRhLCBldmVudENhbGxiYWNrLCBAc3RhdGVcbiAgICBmb3IgbGlzdGVuZXIgaW4gQF9saXN0ZW5lcnNcbiAgICAgIGxpc3RlbmVyIGV2ZW50XG4gICAgIyBXb3JrYXJvdW5kIHRvIGZpeCBodHRwczovL3d3dy5waXZvdGFsdHJhY2tlci5jb20vc3Rvcnkvc2hvdy8xNjIzOTI1ODBcbiAgICAjIENPREFQIHdpbGwgZmFpbCBvbiB0aGUgcmVuYW1lZEZpbGUgbWVzc2FnZSBiZWNhdXNlIHdlIGRvbid0IHNlbmQgdGhlIHN0YXRlIHdpdGhcbiAgICAjIHRoZSBwb3N0TWVzc2FnZSBldmVudHMgYW5kIENPREFQIGV4YW1pbmVzIHRoZSBzdGF0ZSB0byBnZXQgdGhlIG5ldyBuYW1lLlxuICAgICMgSSB0cmllZCBzZW5kaW5nIHRoZSBzdGF0ZSBidXQgdGhhdCBjYXVzZXMgQ09EQVAgdG8gcmVwbGFjZSBpdHMgc3RhdGUgd2hpY2ggYnJlYWtzIG90aGVyIHRoaW5ncy5cbiAgICAjIEEgcGVybWFuZW50IGZpeCBmb3IgdGhpcyB3b3VsZCBiZSB0byBzZW5kIHRoZSBuZXcgZmlsZW5hbWUgb3V0c2lkZSBvZiB0aGUgc3RhdGUgbWV0YWRhdGEuXG4gICAgc2tpcFBvc3RNZXNzYWdlID0gdHlwZSBpcyBcInJlbmFtZWRGaWxlXCJcbiAgICBpZiBAYXBwT3B0aW9ucz8uc2VuZFBvc3RNZXNzYWdlQ2xpZW50RXZlbnRzIGFuZCBAaWZyYW1lIGFuZCBub3Qgc2tpcFBvc3RNZXNzYWdlXG4gICAgICBldmVudC5wb3N0TWVzc2FnZShAaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG5cbiAgX3NldFN0YXRlOiAob3B0aW9ucykgLT5cbiAgICBmb3Igb3duIGtleSwgdmFsdWUgb2Ygb3B0aW9uc1xuICAgICAgQHN0YXRlW2tleV0gPSB2YWx1ZVxuICAgIEBfZXZlbnQgJ3N0YXRlQ2hhbmdlZCdcblxuICBfcmVzZXRTdGF0ZTogLT5cbiAgICBAX3NldFN0YXRlXG4gICAgICBvcGVuZWRDb250ZW50OiBudWxsXG4gICAgICBjdXJyZW50Q29udGVudDogbnVsbFxuICAgICAgbWV0YWRhdGE6IG51bGxcbiAgICAgIGRpcnR5OiBmYWxzZVxuICAgICAgc2F2aW5nOiBudWxsXG4gICAgICBzYXZlZDogZmFsc2VcblxuICBfY2xvc2VDdXJyZW50RmlsZTogLT5cbiAgICBpZiBAc3RhdGUubWV0YWRhdGE/LnByb3ZpZGVyPy5jYW4gJ2Nsb3NlJywgQHN0YXRlLm1ldGFkYXRhXG4gICAgICBAc3RhdGUubWV0YWRhdGEucHJvdmlkZXIuY2xvc2UgQHN0YXRlLm1ldGFkYXRhXG5cbiAgX2NyZWF0ZU9yVXBkYXRlQ3VycmVudENvbnRlbnQ6IChzdHJpbmdDb250ZW50LCBtZXRhZGF0YSA9IG51bGwpIC0+XG4gICAgaWYgQHN0YXRlLmN1cnJlbnRDb250ZW50P1xuICAgICAgY3VycmVudENvbnRlbnQgPSBAc3RhdGUuY3VycmVudENvbnRlbnRcbiAgICAgIGN1cnJlbnRDb250ZW50LnNldFRleHQgc3RyaW5nQ29udGVudFxuICAgIGVsc2VcbiAgICAgIGN1cnJlbnRDb250ZW50ID0gY2xvdWRDb250ZW50RmFjdG9yeS5jcmVhdGVFbnZlbG9wZWRDbG91ZENvbnRlbnQgc3RyaW5nQ29udGVudFxuICAgIGlmIG1ldGFkYXRhP1xuICAgICAgY3VycmVudENvbnRlbnQuYWRkTWV0YWRhdGEgZG9jTmFtZTogbWV0YWRhdGEubmFtZVxuICAgIGN1cnJlbnRDb250ZW50XG5cbiAgX3NldFdpbmRvd1RpdGxlOiAobmFtZSkgLT5cbiAgICBpZiBAYXBwT3B0aW9ucz8udWk/LndpbmRvd1RpdGxlU3VmZml4XG4gICAgICBkb2N1bWVudC50aXRsZSA9IFwiI3tpZiBuYW1lPy5sZW5ndGggPiAwIHRoZW4gbmFtZSBlbHNlICh0ciBcIn5NRU5VQkFSLlVOVElUTEVEX0RPQ1VNRU5UXCIpfSN7QGFwcE9wdGlvbnMudWkud2luZG93VGl0bGVTZXBhcmF0b3J9I3tAYXBwT3B0aW9ucy51aS53aW5kb3dUaXRsZVN1ZmZpeH1cIlxuXG4gIF9nZXRIYXNoUGFyYW1zOiAobWV0YWRhdGEpIC0+XG4gICAgaWYgbWV0YWRhdGE/LnByb3ZpZGVyPy5jYW5PcGVuU2F2ZWQoKSBhbmQgKG9wZW5TYXZlZFBhcmFtcyA9IG1ldGFkYXRhPy5wcm92aWRlcj8uZ2V0T3BlblNhdmVkUGFyYW1zIG1ldGFkYXRhKT9cbiAgICAgIFwiI2ZpbGU9I3ttZXRhZGF0YS5wcm92aWRlci51cmxEaXNwbGF5TmFtZSBvciBtZXRhZGF0YS5wcm92aWRlci5uYW1lfToje2VuY29kZVVSSUNvbXBvbmVudCBvcGVuU2F2ZWRQYXJhbXN9XCJcbiAgICBlbHNlIGlmIG1ldGFkYXRhPy5wcm92aWRlciBpbnN0YW5jZW9mIFVSTFByb3ZpZGVyIGFuZFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaC5pbmRleE9mKFwiI2ZpbGU9aHR0cFwiKSBpcyAwXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCAgICAjIGxlYXZlIGl0IGFsb25lXG4gICAgZWxzZSBcIlwiXG5cbiAgX3N0YXJ0UG9zdE1lc3NhZ2VMaXN0ZW5lcjogLT5cbiAgICAkKHdpbmRvdykub24gJ21lc3NhZ2UnLCAoZSkgPT5cbiAgICAgIG9lID0gZS5vcmlnaW5hbEV2ZW50XG4gICAgICBkYXRhID0gb2UuZGF0YSBvciB7fVxuICAgICAgcmVwbHkgPSAodHlwZSwgcGFyYW1zPXt9KSAtPlxuICAgICAgICBtZXNzYWdlID0gXy5tZXJnZSB7fSwgcGFyYW1zLCB7dHlwZTogdHlwZX1cbiAgICAgICAgb2Uuc291cmNlLnBvc3RNZXNzYWdlIG1lc3NhZ2UsIG9lLm9yaWdpblxuICAgICAgc3dpdGNoIG9lLmRhdGE/LnR5cGVcbiAgICAgICAgd2hlbiAnY2ZtOjpnZXRDb21tYW5kcydcbiAgICAgICAgICByZXBseSAnY2ZtOjpjb21tYW5kcycsIGNvbW1hbmRzOiBbJ2NmbTo6YXV0b3NhdmUnLCAnY2ZtOjpldmVudCcsICdjZm06OmV2ZW50OnJlcGx5JywgJ2NmbTo6c2V0RGlydHknLCAnY2ZtOjppZnJhbWVkQ2xpZW50Q29ubmVjdGVkJ11cbiAgICAgICAgd2hlbiAnY2ZtOjphdXRvc2F2ZSdcbiAgICAgICAgICBpZiBAc2hvdWxkQXV0b1NhdmUoKVxuICAgICAgICAgICAgQHNhdmUgLT4gcmVwbHkgJ2NmbTo6YXV0b3NhdmVkJywgc2F2ZWQ6IHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXBseSAnY2ZtOjphdXRvc2F2ZWQnLCBzYXZlZDogZmFsc2VcbiAgICAgICAgd2hlbiAnY2ZtOjpldmVudCdcbiAgICAgICAgICBAX2V2ZW50IGRhdGEuZXZlbnRUeXBlLCBkYXRhLmV2ZW50RGF0YSwgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrQXJncyA9IEpTT04uc3RyaW5naWZ5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICByZXBseSAnY2ZtOjpldmVudDpyZXBseScsIHtldmVudElkOiBkYXRhLmV2ZW50SWQsIGNhbGxiYWNrQXJnczogY2FsbGJhY2tBcmdzfVxuICAgICAgICB3aGVuICdjZm06OmV2ZW50OnJlcGx5J1xuICAgICAgICAgIGV2ZW50ID0gQ2xvdWRGaWxlTWFuYWdlckNsaWVudEV2ZW50LmV2ZW50c1tkYXRhLmV2ZW50SWRdXG4gICAgICAgICAgZXZlbnQ/LmNhbGxiYWNrPy5hcHBseShALCBKU09OLnBhcnNlKGRhdGEuY2FsbGJhY2tBcmdzKSlcbiAgICAgICAgd2hlbiAnY2ZtOjpzZXREaXJ0eSdcbiAgICAgICAgICBAZGlydHkgZGF0YS5pc0RpcnR5XG4gICAgICAgIHdoZW4gJ2NmbTo6aWZyYW1lZENsaWVudENvbm5lY3RlZCdcbiAgICAgICAgICBAcHJvY2Vzc1VybFBhcmFtcygpXG5cblxubW9kdWxlLmV4cG9ydHMgPVxuICBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50RXZlbnQ6IENsb3VkRmlsZU1hbmFnZXJDbGllbnRFdmVudFxuICBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50OiBDbG91ZEZpbGVNYW5hZ2VyQ2xpZW50XG4iLCIvKiBGaWxlU2F2ZXIuanNcbiAqIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICogMS4zLjJcbiAqIDIwMTYtMDYtMTYgMTg6MjU6MTlcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBNSVRcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSwgaW5kZW50OiA0LCBsYXhicmVhazogdHJ1ZSwgbGF4Y29tbWE6IHRydWUsIHNtYXJ0dGFiczogdHJ1ZSwgcGx1c3BsdXM6IHRydWUgKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9GaWxlU2F2ZXIuanMgKi9cblxudmFyIHNhdmVBcyA9IHNhdmVBcyB8fCAoZnVuY3Rpb24odmlldykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0Ly8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcblx0aWYgKHR5cGVvZiB2aWV3ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgWzEtOV1cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyXG5cdFx0ICBkb2MgPSB2aWV3LmRvY3VtZW50XG5cdFx0ICAvLyBvbmx5IGdldCBVUkwgd2hlbiBuZWNlc3NhcnkgaW4gY2FzZSBCbG9iLmpzIGhhc24ndCBvdmVycmlkZGVuIGl0IHlldFxuXHRcdCwgZ2V0X1VSTCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHZpZXcuVVJMIHx8IHZpZXcud2Via2l0VVJMIHx8IHZpZXc7XG5cdFx0fVxuXHRcdCwgc2F2ZV9saW5rID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG5cdFx0LCBjYW5fdXNlX3NhdmVfbGluayA9IFwiZG93bmxvYWRcIiBpbiBzYXZlX2xpbmtcblx0XHQsIGNsaWNrID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKTtcblx0XHRcdG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdCwgaXNfc2FmYXJpID0gL2NvbnN0cnVjdG9yL2kudGVzdCh2aWV3LkhUTUxFbGVtZW50KSB8fCB2aWV3LnNhZmFyaVxuXHRcdCwgaXNfY2hyb21lX2lvcyA9L0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5cdFx0LCB0aHJvd19vdXRzaWRlID0gZnVuY3Rpb24oZXgpIHtcblx0XHRcdCh2aWV3LnNldEltbWVkaWF0ZSB8fCB2aWV3LnNldFRpbWVvdXQpKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBleDtcblx0XHRcdH0sIDApO1xuXHRcdH1cblx0XHQsIGZvcmNlX3NhdmVhYmxlX3R5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG5cdFx0Ly8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuXHRcdCwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0ID0gMTAwMCAqIDQwIC8vIGluIG1zXG5cdFx0LCByZXZva2UgPSBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHR2YXIgcmV2b2tlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZpbGUgPT09IFwic3RyaW5nXCIpIHsgLy8gZmlsZSBpcyBhbiBvYmplY3QgVVJMXG5cdFx0XHRcdFx0Z2V0X1VSTCgpLnJldm9rZU9iamVjdFVSTChmaWxlKTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcblx0XHRcdFx0XHRmaWxlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0c2V0VGltZW91dChyZXZva2VyLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQpO1xuXHRcdH1cblx0XHQsIGRpc3BhdGNoID0gZnVuY3Rpb24oZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcblx0XHRcdGV2ZW50X3R5cGVzID0gW10uY29uY2F0KGV2ZW50X3R5cGVzKTtcblx0XHRcdHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuXHRcdFx0XHRpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHRocm93X291dHNpZGUoZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQsIGF1dG9fYm9tID0gZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0Ly8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcblx0XHRcdC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXG5cdFx0XHRpZiAoL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSwgYmxvYl0sIHt0eXBlOiBibG9iLnR5cGV9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBibG9iO1xuXHRcdH1cblx0XHQsIEZpbGVTYXZlciA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXG5cdFx0XHR2YXJcblx0XHRcdFx0ICBmaWxlc2F2ZXIgPSB0aGlzXG5cdFx0XHRcdCwgdHlwZSA9IGJsb2IudHlwZVxuXHRcdFx0XHQsIGZvcmNlID0gdHJ1ZSAgLy8gW0NDIDIwMTYtMTItMDVdIHR5cGUgPT09IGZvcmNlX3NhdmVhYmxlX3R5cGVcblx0XHRcdFx0LCBvYmplY3RfdXJsXG5cdFx0XHRcdCwgZGlzcGF0Y2hfYWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2goZmlsZXNhdmVyLCBcIndyaXRlc3RhcnQgcHJvZ3Jlc3Mgd3JpdGUgd3JpdGVlbmRcIi5zcGxpdChcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9uIGFueSBmaWxlc3lzIGVycm9ycyByZXZlcnQgdG8gc2F2aW5nIHdpdGggb2JqZWN0IFVSTHNcblx0XHRcdFx0LCBmc19lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICgoaXNfY2hyb21lX2lvcyB8fCAoZm9yY2UgJiYgaXNfc2FmYXJpKSkgJiYgdmlldy5GaWxlUmVhZGVyKSB7XG5cdFx0XHRcdFx0XHQvLyBTYWZhcmkgZG9lc24ndCBhbGxvdyBkb3dubG9hZGluZyBvZiBibG9iIHVybHNcblx0XHRcdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdFx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gaXNfY2hyb21lX2lvcyA/IHJlYWRlci5yZXN1bHQgOiByZWFkZXIucmVzdWx0LnJlcGxhY2UoL15kYXRhOlteO10qOy8sICdkYXRhOmF0dGFjaG1lbnQvZmlsZTsnKTtcblx0XHRcdFx0XHRcdFx0dmFyIHBvcHVwID0gdmlldy5vcGVuKHVybCwgJ19ibGFuaycpO1xuXHRcdFx0XHRcdFx0XHRpZighcG9wdXApIHZpZXcubG9jYXRpb24uaHJlZiA9IHVybDtcblx0XHRcdFx0XHRcdFx0dXJsPXVuZGVmaW5lZDsgLy8gcmVsZWFzZSByZWZlcmVuY2UgYmVmb3JlIGRpc3BhdGNoaW5nXG5cdFx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuXHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgY3JlYXRlIG1vcmUgb2JqZWN0IFVSTHMgdGhhbiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoIW9iamVjdF91cmwpIHtcblx0XHRcdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZm9yY2UpIHtcblx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBvcGVuZWQgPSB2aWV3Lm9wZW4ob2JqZWN0X3VybCwgXCJfYmxhbmtcIik7XG5cdFx0XHRcdFx0XHRpZiAoIW9wZW5lZCkge1xuXHRcdFx0XHRcdFx0XHQvLyBBcHBsZSBkb2VzIG5vdCBhbGxvdyB3aW5kb3cub3Blbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL1Rvb2xzL0NvbmNlcHR1YWwvU2FmYXJpRXh0ZW5zaW9uR3VpZGUvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzLmh0bWxcblx0XHRcdFx0XHRcdFx0dmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdH1cblx0XHRcdDtcblx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cblx0XHRcdGlmIChjYW5fdXNlX3NhdmVfbGluaykge1xuXHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzYXZlX2xpbmsuaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmRvd25sb2FkID0gbmFtZTtcblx0XHRcdFx0XHRjbGljayhzYXZlX2xpbmspO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdHJldm9rZShvYmplY3RfdXJsKTtcblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmc19lcnJvcigpO1xuXHRcdH1cblx0XHQsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuXHRcdCwgc2F2ZUFzID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdHJldHVybiBuZXcgRmlsZVNhdmVyKGJsb2IsIG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIiwgbm9fYXV0b19ib20pO1xuXHRcdH1cblx0O1xuXHQvLyBJRSAxMCsgKG5hdGl2ZSBzYXZlQXMpXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRuYW1lID0gbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiO1xuXG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBuYW1lKTtcblx0XHR9O1xuXHR9XG5cblx0RlNfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbigpe307XG5cdEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcblx0RlNfcHJvdG8uV1JJVElORyA9IDE7XG5cdEZTX3Byb3RvLkRPTkUgPSAyO1xuXG5cdEZTX3Byb3RvLmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZXN0YXJ0ID1cblx0RlNfcHJvdG8ub25wcm9ncmVzcyA9XG5cdEZTX3Byb3RvLm9ud3JpdGUgPVxuXHRGU19wcm90by5vbmFib3J0ID1cblx0RlNfcHJvdG8ub25lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuXHRcdG51bGw7XG5cblx0cmV0dXJuIHNhdmVBcztcbn0oXG5cdCAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcblx0fHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcblx0fHwgdGhpcy5jb250ZW50XG4pKTtcbi8vIGBzZWxmYCBpcyB1bmRlZmluZWQgaW4gRmlyZWZveCBmb3IgQW5kcm9pZCBjb250ZW50IHNjcmlwdCBjb250ZXh0XG4vLyB3aGlsZSBgdGhpc2AgaXMgbnNJQ29udGVudEZyYW1lTWVzc2FnZU1hbmFnZXJcbi8vIHdpdGggYW4gYXR0cmlidXRlIGBjb250ZW50YCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB3aW5kb3dcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMuc2F2ZUFzID0gc2F2ZUFzO1xufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkZWZpbmUgIT09IG51bGwpICYmIChkZWZpbmUuYW1kICE9PSBudWxsKSkge1xuICBkZWZpbmUoXCJGaWxlU2F2ZXIuanNcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNhdmVBcztcbiAgfSk7XG59XG4iLCJ7ZGl2LCBidXR0b24sIHNwYW59ID0gUmVhY3QuRE9NXG5cbmdldFF1ZXJ5UGFyYW0gPSByZXF1aXJlICcuLi91dGlscy9nZXQtcXVlcnktcGFyYW0nXG5nZXRIYXNoUGFyYW0gPSByZXF1aXJlICcuLi91dGlscy9nZXQtaGFzaC1wYXJhbSdcbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuaXNTdHJpbmcgPSByZXF1aXJlICcuLi91dGlscy9pcy1zdHJpbmcnXG5qaWZmID0gcmVxdWlyZSAnamlmZidcbnBha28gPSByZXF1aXJlICdwYWtvJ1xuXG5Qcm92aWRlckludGVyZmFjZSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLlByb3ZpZGVySW50ZXJmYWNlXG5jbG91ZENvbnRlbnRGYWN0b3J5ID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuY2xvdWRDb250ZW50RmFjdG9yeVxuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLkNsb3VkTWV0YWRhdGFcblxuRG9jdW1lbnRTdG9yZVVybCA9IHJlcXVpcmUgJy4vZG9jdW1lbnQtc3RvcmUtdXJsJ1xuUGF0Y2hhYmxlQ29udGVudCA9IHJlcXVpcmUgJy4vcGF0Y2hhYmxlLWNvbnRlbnQnXG5cbkRvY3VtZW50U3RvcmVBdXRob3JpemF0aW9uRGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSBSZWFjdC5jcmVhdGVDbGFzc1xuICBkaXNwbGF5TmFtZTogJ0RvY3VtZW50U3RvcmVBdXRob3JpemF0aW9uRGlhbG9nJ1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBkb2NTdG9yZUF2YWlsYWJsZTogZmFsc2VcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IC0+XG4gICAgQHByb3BzLnByb3ZpZGVyLl9vbkRvY1N0b3JlTG9hZGVkID0+XG4gICAgICBAc2V0U3RhdGUgZG9jU3RvcmVBdmFpbGFibGU6IHRydWVcblxuICBhdXRoZW50aWNhdGU6IC0+XG4gICAgQHByb3BzLnByb3ZpZGVyLmF1dGhvcml6ZSgpXG5cbiAgcmVuZGVyOiAtPlxuICAgIChkaXYge2NsYXNzTmFtZTogJ2RvY3VtZW50LXN0b3JlLWF1dGgnfSxcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2RvY3VtZW50LXN0b3JlLWNvbmNvcmQtbG9nbyd9LCAnJylcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2RvY3VtZW50LXN0b3JlLWZvb3Rlcid9LFxuICAgICAgICBpZiBAc3RhdGUuZG9jU3RvcmVBdmFpbGFibGVcbiAgICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAYXV0aGVudGljYXRlfSwgJ0xvZ2luIHRvIENvbmNvcmQnKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgJ1RyeWluZyB0byBsb2cgaW50byBDb25jb3JkLi4uJ1xuICAgICAgKVxuICAgIClcblxuY2xhc3MgRG9jdW1lbnRTdG9yZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2VcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgQG9wdGlvbnMuZGVwcmVjYXRpb25QaGFzZSA9IDNcbiAgICBzdXBlclxuICAgICAgbmFtZTogRG9jdW1lbnRTdG9yZVByb3ZpZGVyLk5hbWVcbiAgICAgIGRpc3BsYXlOYW1lOiBAb3B0aW9ucy5kaXNwbGF5TmFtZSBvciAodHIgJ35QUk9WSURFUi5ET0NVTUVOVF9TVE9SRScpXG4gICAgICB1cmxEaXNwbGF5TmFtZTogQG9wdGlvbnMudXJsRGlzcGxheU5hbWVcbiAgICAgIGNhcGFiaWxpdGllczpcbiAgICAgICAgc2F2ZTogQGlzTm90RGVwcmVjYXRlZCgnc2F2ZScpXG4gICAgICAgIHJlc2F2ZTogQGlzTm90RGVwcmVjYXRlZCgnc2F2ZScpXG4gICAgICAgIGV4cG9ydDogZmFsc2VcbiAgICAgICAgbG9hZDogQGlzTm90RGVwcmVjYXRlZCgnbG9hZCcpXG4gICAgICAgIGxpc3Q6IEBpc05vdERlcHJlY2F0ZWQoJ2xpc3QnKVxuICAgICAgICByZW1vdmU6IEBpc05vdERlcHJlY2F0ZWQoJ3JlbW92ZScpXG4gICAgICAgIHJlbmFtZTogQGlzTm90RGVwcmVjYXRlZCgncmVuYW1lJylcbiAgICAgICAgY2xvc2U6IGZhbHNlXG5cbiAgICBAdXJsUGFyYW1zID0ge1xuICAgICAgZG9jdW1lbnRTZXJ2ZXI6IGdldFF1ZXJ5UGFyYW0gXCJkb2N1bWVudFNlcnZlclwiXG4gICAgICByZWNvcmRpZDogZ2V0UXVlcnlQYXJhbSBcInJlY29yZGlkXCJcbiAgICAgIHJ1bktleTogZ2V0UXVlcnlQYXJhbSBcInJ1bktleVwiXG4gICAgICBkb2NOYW1lOiBnZXRRdWVyeVBhcmFtIFwiZG9jXCJcbiAgICAgIGRvY093bmVyOiBnZXRRdWVyeVBhcmFtIFwib3duZXJcIlxuICAgIH1cbiAgICAjIHF1ZXJ5IHBhcmFtcyB0aGF0IGNhbiBiZSByZW1vdmVkIGFmdGVyIGluaXRpYWwgcHJvY2Vzc2luZ1xuICAgIEByZW1vdmFibGVRdWVyeVBhcmFtcyA9IFsncmVjb3JkaWQnLCAnZG9jJywgJ293bmVyJ11cblxuICAgIEBkb2NTdG9yZVVybCA9IG5ldyBEb2N1bWVudFN0b3JlVXJsIEB1cmxQYXJhbXMuZG9jdW1lbnRTZXJ2ZXJcblxuICAgIEB1c2VyID0gbnVsbFxuXG4gICAgQHNhdmVkQ29udGVudCA9IG5ldyBQYXRjaGFibGVDb250ZW50KEBvcHRpb25zLnBhdGNoT2JqZWN0SGFzaClcblxuICBATmFtZTogJ2RvY3VtZW50U3RvcmUnXG5cbiAgY2FuOiAoY2FwYWJpbGl0eSwgbWV0YWRhdGEpIC0+XG4gICAgIyBsZWdhY3kgc2hhcmluZyBzdXBwb3J0IC0gY2FuJ3Qgc2F2ZSB0byBvbGQtc3R5bGUgc2hhcmVkIGRvY3VtZW50c1xuICAgIHJldHVybiBmYWxzZSBpZiAoKGNhcGFiaWxpdHkgaXMgJ3NhdmUnKSBvciAoY2FwYWJpbGl0eSBpcyAncmVzYXZlJykpIGFuZCBtZXRhZGF0YT8ucHJvdmlkZXJEYXRhPy5vd25lclxuICAgIHN1cGVyKGNhcGFiaWxpdHksIG1ldGFkYXRhKVxuXG4gICMgaWYgYSBydW5LZXkgaXMgc3BlY2lmaWVkLCB3ZSBkb24ndCBuZWVkIHRvIGF1dGhlbnRpY2F0ZSBhdCBhbGxcbiAgaXNBdXRob3JpemF0aW9uUmVxdWlyZWQ6IC0+XG4gICAgbm90IChAdXJsUGFyYW1zLnJ1bktleSBvciAoQHVybFBhcmFtcy5kb2NOYW1lIGFuZCBAdXJsUGFyYW1zLmRvY093bmVyKSlcblxuICBhdXRob3JpemVkOiAoQGF1dGhDYWxsYmFjaykgLT5cbiAgICBpZiBAYXV0aENhbGxiYWNrXG4gICAgICBpZiBAdXNlclxuICAgICAgICBAYXV0aENhbGxiYWNrIHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgQF9jaGVja0xvZ2luKClcbiAgICBlbHNlXG4gICAgICBAdXNlciBpc250IG51bGxcblxuICBhdXRob3JpemU6IChjb21wbGV0aW9uQ2FsbGJhY2spIC0+XG4gICAgQF9zaG93TG9naW5XaW5kb3coY29tcGxldGlvbkNhbGxiYWNrKVxuXG4gIF9vbkRvY1N0b3JlTG9hZGVkOiAoQGRvY1N0b3JlTG9hZGVkQ2FsbGJhY2spIC0+XG4gICAgaWYgQF9kb2NTdG9yZUxvYWRlZFxuICAgICAgQGRvY1N0b3JlTG9hZGVkQ2FsbGJhY2soKVxuXG4gIF9jaGVja0xvZ2luOiAtPlxuICAgIGxvZ2dlZEluID0gKHVzZXIpID0+XG4gICAgICBAdXNlciA9IHVzZXJcbiAgICAgIEBfZG9jU3RvcmVMb2FkZWQgPSB0cnVlXG4gICAgICBAZG9jU3RvcmVMb2FkZWRDYWxsYmFjaz8oKVxuICAgICAgaWYgdXNlclxuICAgICAgICBAX2xvZ2luV2luZG93Py5jbG9zZSgpXG4gICAgICBAYXV0aENhbGxiYWNrICh1c2VyIGlzbnQgbnVsbCkgaWYgQGF1dGhDYWxsYmFja1xuXG4gICAgJC5hamF4XG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICB1cmw6IEBkb2NTdG9yZVVybC5jaGVja0xvZ2luKClcbiAgICAgIHhockZpZWxkczpcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT4gbG9nZ2VkSW4gZGF0YVxuICAgICAgZXJyb3I6IC0+IGxvZ2dlZEluIG51bGxcblxuICBfbG9naW5XaW5kb3c6IG51bGxcblxuICBfc2hvd0xvZ2luV2luZG93OiAoY29tcGxldGlvbkNhbGxiYWNrKSAtPlxuICAgIGlmIEBfbG9naW5XaW5kb3cgYW5kIG5vdCBAX2xvZ2luV2luZG93LmNsb3NlZFxuICAgICAgQF9sb2dpbldpbmRvdy5mb2N1cygpXG4gICAgZWxzZVxuXG4gICAgICBjb21wdXRlU2NyZWVuTG9jYXRpb24gPSAodywgaCkgLT5cbiAgICAgICAgc2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0IG9yIHNjcmVlbi5sZWZ0XG4gICAgICAgIHNjcmVlblRvcCAgPSB3aW5kb3cuc2NyZWVuVG9wICBvciBzY3JlZW4udG9wXG4gICAgICAgIHdpZHRoICA9IHdpbmRvdy5pbm5lcldpZHRoICBvciBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggIG9yIHNjcmVlbi53aWR0aFxuICAgICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgb3IgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCBvciBzY3JlZW4uaGVpZ2h0XG5cbiAgICAgICAgbGVmdCA9ICgod2lkdGggLyAyKSAtICh3IC8gMikpICsgc2NyZWVuTGVmdFxuICAgICAgICB0b3AgPSAoKGhlaWdodCAvIDIpIC0gKGggLyAyKSkgKyBzY3JlZW5Ub3BcbiAgICAgICAgcmV0dXJuIHtsZWZ0LCB0b3B9XG5cbiAgICAgIHdpZHRoID0gMTAwMFxuICAgICAgaGVpZ2h0ID0gNDgwXG4gICAgICBwb3NpdGlvbiA9IGNvbXB1dGVTY3JlZW5Mb2NhdGlvbiB3aWR0aCwgaGVpZ2h0XG4gICAgICB3aW5kb3dGZWF0dXJlcyA9IFtcbiAgICAgICAgJ3dpZHRoPScgKyB3aWR0aFxuICAgICAgICAnaGVpZ2h0PScgKyBoZWlnaHRcbiAgICAgICAgJ3RvcD0nICsgcG9zaXRpb24udG9wIG9yIDIwMFxuICAgICAgICAnbGVmdD0nICsgcG9zaXRpb24ubGVmdCBvciAyMDBcbiAgICAgICAgJ2RlcGVuZGVudD15ZXMnXG4gICAgICAgICdyZXNpemFibGU9bm8nXG4gICAgICAgICdsb2NhdGlvbj1ubydcbiAgICAgICAgJ2RpYWxvZz15ZXMnXG4gICAgICAgICdtZW51YmFyPW5vJ1xuICAgICAgXVxuXG4gICAgICBAX2xvZ2luV2luZG93ID0gd2luZG93Lm9wZW4oQGRvY1N0b3JlVXJsLmF1dGhvcml6ZSgpLCAnYXV0aCcsIHdpbmRvd0ZlYXR1cmVzLmpvaW4oKSlcblxuICAgICAgaWYgQF9sb2dpbldpbmRvd1xuICAgICAgICBwb2xsQWN0aW9uID0gPT5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGlmIChAX2xvZ2luV2luZG93LmxvY2F0aW9uLmhvc3QgaXMgd2luZG93LmxvY2F0aW9uLmhvc3QpXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwgcG9sbFxuICAgICAgICAgICAgICBAX2xvZ2luV2luZG93LmNsb3NlKClcbiAgICAgICAgICAgICAgQF9jaGVja0xvZ2luKClcbiAgICAgICAgICAgICAgY29tcGxldGlvbkNhbGxiYWNrKCkgaWYgY29tcGxldGlvbkNhbGxiYWNrXG4gICAgICAgICAgY2F0Y2ggZVxuICAgICAgICAgICAgIyBjb25zb2xlLmxvZyBlXG5cbiAgICAgICAgcG9sbCA9IHNldEludGVydmFsIHBvbGxBY3Rpb24sIDIwMFxuXG4gICAgQF9sb2dpbldpbmRvd1xuXG4gIHJlbmRlckF1dGhvcml6YXRpb25EaWFsb2c6IC0+XG4gICAgKERvY3VtZW50U3RvcmVBdXRob3JpemF0aW9uRGlhbG9nIHtwcm92aWRlcjogQCwgYXV0aENhbGxiYWNrOiBAYXV0aENhbGxiYWNrfSlcblxuICByZW5kZXJVc2VyOiAtPlxuICAgIGlmIEB1c2VyXG4gICAgICAoc3BhbiB7fSwgKHNwYW4ge2NsYXNzTmFtZTogJ2RvY3VtZW50LXN0b3JlLWljb24nfSksIEB1c2VyLm5hbWUpXG4gICAgZWxzZVxuICAgICAgbnVsbFxuXG4gIGZpbHRlclRhYkNvbXBvbmVudDogKGNhcGFiaWxpdHksIGRlZmF1bHRDb21wb25lbnQpIC0+XG4gICAgIyBhbGxvdyB0aGUgc2F2ZSBlbHNld2hlcmUgYnV0dG9uIHRvIGhpZGUgdGhlIGRvY3VtZW50IHByb3ZpZGVyIHRhYiBpbiBzYXZlXG4gICAgaWYgY2FwYWJpbGl0eSBpcyAnc2F2ZScgYW5kIEBkaXNhYmxlRm9yTmV4dFNhdmVcbiAgICAgIEBkaXNhYmxlRm9yTmV4dFNhdmUgPSBmYWxzZVxuICAgICAgbnVsbFxuICAgIGVsc2VcbiAgICAgIGRlZmF1bHRDb21wb25lbnRcblxuICBpc05vdERlcHJlY2F0ZWQ6IChjYXBhYmlsaXR5KSAtPlxuICAgIGlmIGNhcGFiaWxpdHkgaXMgJ3NhdmUnXG4gICAgICBAb3B0aW9ucy5kZXByZWNhdGlvblBoYXNlIDwgMlxuICAgIGVsc2VcbiAgICAgIEBvcHRpb25zLmRlcHJlY2F0aW9uUGhhc2UgPCAzXG5cbiAgZGVwcmVjYXRpb25NZXNzYWdlOiAtPlxuICAgIFwiXCJcIlxuICAgICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGxlZnRcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDEwcHggMDtcIj5cbiAgICAgICAgICA8c3Ryb25nPiN7dHIgfkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uU0hVVF9ET1dOX01FU1NBR0V9PC9zdHJvbmc+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDEwcHggMDtcIj5cbiAgICAgICAgICAje3RyIH5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLlBMRUFTRV9TQVZFX0VMU0VXSEVSRX1cbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgXCJcIlwiXG5cbiAgb25Qcm92aWRlclRhYlNlbGVjdGVkOiAoY2FwYWJpbGl0eSkgLT5cbiAgICBpZiBjYXBhYmlsaXR5IGlzICdzYXZlJyBhbmQgQGRlcHJlY2F0aW9uTWVzc2FnZSgpXG4gICAgICBAY2xpZW50LmFsZXJ0IEBkZXByZWNhdGlvbk1lc3NhZ2UoKSwgKHRyICd+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5BTEVSVF9TQVZFX1RJVExFJylcblxuICBoYW5kbGVVcmxQYXJhbXM6IC0+XG4gICAgaWYgQHVybFBhcmFtcy5yZWNvcmRpZFxuICAgICAgQGNsaWVudC5vcGVuUHJvdmlkZXJGaWxlIEBuYW1lLCB7IGlkOiBAdXJsUGFyYW1zLnJlY29yZGlkIH1cbiAgICAgIHRydWUgIyBzaWduYWwgdGhhdCB0aGUgcHJvdmlkZXIgaXMgaGFuZGxpbmcgdGhlIHBhcmFtc1xuICAgIGVsc2UgaWYgQHVybFBhcmFtcy5kb2NOYW1lIGFuZCBAdXJsUGFyYW1zLmRvY093bmVyXG4gICAgICBAY2xpZW50Lm9wZW5Qcm92aWRlckZpbGUgQG5hbWUsIHsgbmFtZTogQHVybFBhcmFtcy5kb2NOYW1lLCBvd25lcjogQHVybFBhcmFtcy5kb2NPd25lciB9XG4gICAgICB0cnVlICMgc2lnbmFsIHRoYXQgdGhlIHByb3ZpZGVyIGlzIGhhbmRsaW5nIHRoZSBwYXJhbXNcbiAgICBlbHNlXG4gICAgICBmYWxzZVxuXG4gIGxpc3Q6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgJC5hamF4XG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICB1cmw6IEBkb2NTdG9yZVVybC5saXN0RG9jdW1lbnRzKClcbiAgICAgIGNvbnRleHQ6IEBcbiAgICAgIHhockZpZWxkczpcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgbGlzdCA9IFtdXG4gICAgICAgIGZvciBvd24ga2V5LCBmaWxlIG9mIGRhdGFcbiAgICAgICAgICBpZiBAbWF0Y2hlc0V4dGVuc2lvbiBmaWxlLm5hbWVcbiAgICAgICAgICAgIGxpc3QucHVzaCBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgcHJvdmlkZXJEYXRhOiB7aWQ6IGZpbGUuaWR9XG4gICAgICAgICAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgICAgICAgICBwcm92aWRlcjogQFxuICAgICAgICBjYWxsYmFjayBudWxsLCBsaXN0XG4gICAgICBlcnJvcjogLT5cbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgW11cbiAgICAgIHN0YXR1c0NvZGU6XG4gICAgICAgIDQwMzogPT5cbiAgICAgICAgICBAdXNlciA9IG51bGxcbiAgICAgICAgICBAYXV0aENhbGxiYWNrIGZhbHNlXG5cbiAgbG9hZDogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICB3aXRoQ3JlZGVudGlhbHMgPSB1bmxlc3MgbWV0YWRhdGEuc2hhcmVkQ29udGVudElkIHRoZW4gdHJ1ZSBlbHNlIGZhbHNlXG4gICAgcmVjb3JkaWQgPSBtZXRhZGF0YS5wcm92aWRlckRhdGE/LmlkIG9yIG1ldGFkYXRhLnNoYXJlZENvbnRlbnRJZFxuICAgIHJlcXVlc3REYXRhID0ge31cbiAgICByZXF1ZXN0RGF0YS5yZWNvcmRpZCA9IHJlY29yZGlkIGlmIHJlY29yZGlkXG4gICAgcmVxdWVzdERhdGEucnVuS2V5ID0gQHVybFBhcmFtcy5ydW5LZXkgaWYgQHVybFBhcmFtcy5ydW5LZXlcbiAgICBpZiBub3QgcmVjb3JkaWRcbiAgICAgIHJlcXVlc3REYXRhLnJlY29yZG5hbWUgPSBtZXRhZGF0YS5wcm92aWRlckRhdGE/Lm5hbWUgaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5uYW1lXG4gICAgICByZXF1ZXN0RGF0YS5vd25lciA9IG1ldGFkYXRhLnByb3ZpZGVyRGF0YT8ub3duZXIgaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5vd25lclxuICAgICQuYWpheFxuICAgICAgdXJsOiBAZG9jU3RvcmVVcmwubG9hZERvY3VtZW50KClcbiAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgIGRhdGE6IHJlcXVlc3REYXRhXG4gICAgICBjb250ZXh0OiBAXG4gICAgICB4aHJGaWVsZHM6XG4gICAgICAgIHt3aXRoQ3JlZGVudGlhbHN9XG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgY29udGVudCA9IGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGRhdGFcblxuICAgICAgICAjIGZvciBkb2N1bWVudHMgbG9hZGVkIGJ5IGlkIG9yIG90aGVyIG1lYW5zIChiZXNpZGVzIG5hbWUpLFxuICAgICAgICAjIGNhcHR1cmUgdGhlIG5hbWUgZm9yIHVzZSBpbiB0aGUgQ0ZNIGludGVyZmFjZS5cbiAgICAgICAgIyAnZG9jTmFtZScgYXQgdGhlIHRvcCBsZXZlbCBmb3IgQ0ZNLXdyYXBwZWQgZG9jdW1lbnRzXG4gICAgICAgICMgJ25hbWUnIGF0IHRoZSB0b3AgbGV2ZWwgZm9yIHVud3JhcHBlZCBkb2N1bWVudHMgKGUuZy4gQ09EQVApXG4gICAgICAgICMgJ25hbWUnIGF0IHRoZSB0b3AgbGV2ZWwgb2YgJ2NvbnRlbnQnIGZvciB3cmFwcGVkIENPREFQIGRvY3VtZW50c1xuICAgICAgICBtZXRhZGF0YS5yZW5hbWUgbWV0YWRhdGEubmFtZSBvciBtZXRhZGF0YS5wcm92aWRlckRhdGEubmFtZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kb2NOYW1lIG9yIGRhdGEubmFtZSBvciBkYXRhLmNvbnRlbnQ/Lm5hbWVcbiAgICAgICAgaWYgbWV0YWRhdGEubmFtZVxuICAgICAgICAgIGNvbnRlbnQuYWRkTWV0YWRhdGEgZG9jTmFtZTogbWV0YWRhdGEuZmlsZW5hbWVcblxuICAgICAgICBjYWxsYmFjayBudWxsLCBjb250ZW50XG4gICAgICBzdGF0dXNDb2RlOlxuICAgICAgICA0MDM6ID0+XG4gICAgICAgICAgQHVzZXIgPSBudWxsXG4gICAgICAgICAgY2FsbGJhY2sgdHIoXCJ+RE9DU1RPUkUuTE9BRF80MDNfRVJST1JcIiwge2ZpbGVuYW1lOiBtZXRhZGF0YS5uYW1lIG9yICd0aGUgZmlsZSd9KSwgNDAzXG5cbiAgICAgIGVycm9yOiAoanFYSFIpIC0+XG4gICAgICAgIHJldHVybiBpZiBqcVhIUi5zdGF0dXMgaXMgNDAzICMgbGV0IHN0YXR1c0NvZGUgaGFuZGxlciBkZWFsIHdpdGggaXRcbiAgICAgICAgbWVzc2FnZSA9IGlmIG1ldGFkYXRhLnNoYXJlZENvbnRlbnRJZFxuICAgICAgICAgIHRyIFwifkRPQ1NUT1JFLkxPQURfU0hBUkVEXzQwNF9FUlJPUlwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ciBcIn5ET0NTVE9SRS5MT0FEXzQwNF9FUlJPUlwiLCB7ZmlsZW5hbWU6IG1ldGFkYXRhLm5hbWUgb3IgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5pZCBvciAndGhlIGZpbGUnfVxuICAgICAgICBjYWxsYmFjayBtZXNzYWdlXG5cbiAgc2F2ZTogKGNsb3VkQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIGNvbnRlbnQgPSBjbG91ZENvbnRlbnQuZ2V0Q29udGVudCgpXG5cbiAgICAjIFNlZSBpZiB3ZSBjYW4gcGF0Y2hcbiAgICBwYXRjaFJlc3VsdHMgPSBAc2F2ZWRDb250ZW50LmNyZWF0ZVBhdGNoKGNvbnRlbnQsIEBvcHRpb25zLnBhdGNoIGFuZCBtZXRhZGF0YS5vdmVyd3JpdGFibGUpXG5cbiAgICBpZiBwYXRjaFJlc3VsdHMuc2hvdWxkUGF0Y2ggYW5kIG5vdCBwYXRjaFJlc3VsdHMuZGlmZkxlbmd0aFxuICAgICAgIyBubyByZWFzb24gdG8gcGF0Y2ggaWYgdGhlcmUgYXJlIG5vIGRpZmZzXG4gICAgICBjYWxsYmFjayBudWxsICMgbm8gZXJyb3IgaW5kaWNhdGVzIHN1Y2Nlc3NcbiAgICAgIHJldHVyblxuXG4gICAgcGFyYW1zID0ge31cbiAgICBpZiBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWQgdGhlbiBwYXJhbXMucmVjb3JkaWQgPSBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWRcblxuICAgIGlmIG5vdCBwYXRjaFJlc3VsdHMuc2hvdWxkUGF0Y2ggYW5kIG1ldGFkYXRhLmZpbGVuYW1lXG4gICAgICBwYXJhbXMucmVjb3JkbmFtZSA9IG1ldGFkYXRhLmZpbGVuYW1lXG5cbiAgICAjIElmIHdlIGFyZSBzYXZpbmcgZm9yIHRoZSBmaXJzdCB0aW1lIGFzIGEgc3R1ZGVudCBpbiBhIExBUkEgYWN0aXZpdHksIHRoZW4gd2UgZG8gbm90IGhhdmVcbiAgICAjIGF1dGhvcml6YXRpb24gb24gdGhlIGN1cnJlbnQgZG9jdW1lbnQuIEhvd2V2ZXIsIHdlIHNob3VsZCBoYXZlIGEgcnVuS2V5IHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAjIFdoZW4gd2Ugc2F2ZSB3aXRoIHRoaXMgcnVuS2V5LCB0aGUgZG9jdW1lbnQgd2lsbCBzYXZlIG91ciBjaGFuZ2VzIHRvIGEgY29weSBvZiB0aGUgZG9jdW1lbnQsXG4gICAgIyBvd25lZCBieSB1cy5cbiAgICAjXG4gICAgIyBXaGVuIHdlIHN1Y2Nlc3NmdWxseSBzYXZlLCB3ZSB3aWxsIGdldCB0aGUgaWQgb2YgdGhlIG5ldyBkb2N1bWVudCBpbiB0aGUgcmVzcG9uc2UsIGFuZCB1c2VcbiAgICAjIHRoaXMgaWQgZm9yIGZ1dHVyZSBzYXZpbmcuIFdlIGNhbiB0aGVuIHNhdmUgdmlhIHBhdGNoZXMsIGFuZCBkb24ndCBuZWVkIHRoZSBydW5LZXkuXG4gICAgaWYgQHVybFBhcmFtcy5ydW5LZXlcbiAgICAgIHBhcmFtcy5ydW5LZXkgPSBAdXJsUGFyYW1zLnJ1bktleVxuXG4gICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgdXJsID0gaWYgcGF0Y2hSZXN1bHRzLnNob3VsZFBhdGNoIFxcXG4gICAgICAgICAgICB0aGVuIEBkb2NTdG9yZVVybC5wYXRjaERvY3VtZW50KHBhcmFtcykgXFxcbiAgICAgICAgICAgIGVsc2UgQGRvY1N0b3JlVXJsLnNhdmVEb2N1bWVudChwYXJhbXMpXG5cbiAgICBsb2dEYXRhID1cbiAgICAgIG9wZXJhdGlvbjogJ3NhdmUnXG4gICAgICBwcm92aWRlcjogJ0RvY3VtZW50U3RvcmVQcm92aWRlcidcbiAgICAgIHNob3VsZFBhdGNoOiBwYXRjaFJlc3VsdHMuc2hvdWxkUGF0Y2hcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICB1cmw6IHVybFxuICAgICAgcGFyYW1zOiBKU09OLnN0cmluZ2lmeShwYXJhbXMpXG4gICAgICBjb250ZW50OiBwYXRjaFJlc3VsdHMuc2VuZENvbnRlbnQuc3Vic3RyKDAsIDUxMilcbiAgICBAY2xpZW50LmxvZyAnc2F2ZScsIGxvZ0RhdGFcblxuICAgICQuYWpheFxuICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgdHlwZTogbWV0aG9kXG4gICAgICB1cmw6IHVybFxuICAgICAgZGF0YTogcGFrby5kZWZsYXRlIHBhdGNoUmVzdWx0cy5zZW5kQ29udGVudFxuICAgICAgY29udGVudFR5cGU6IHBhdGNoUmVzdWx0cy5taW1lVHlwZVxuICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlXG4gICAgICBiZWZvcmVTZW5kOiAoeGhyKSAtPlxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1FbmNvZGluZycsICdkZWZsYXRlJylcbiAgICAgIGNvbnRleHQ6IEBcbiAgICAgIHhockZpZWxkczpcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgQHNhdmVkQ29udGVudC51cGRhdGVDb250ZW50KGlmIEBvcHRpb25zLnBhdGNoIHRoZW4gXy5jbG9uZURlZXAoY29udGVudCkgZWxzZSBudWxsKVxuICAgICAgICBpZiBkYXRhLmlkIHRoZW4gbWV0YWRhdGEucHJvdmlkZXJEYXRhLmlkID0gZGF0YS5pZFxuXG4gICAgICAgIGNhbGxiYWNrIG51bGwsIGRhdGFcbiAgICAgIHN0YXR1c0NvZGU6XG4gICAgICAgIDQwMzogPT5cbiAgICAgICAgICBAdXNlciA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayB0cihcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiLCB7ZmlsZW5hbWU6IG1ldGFkYXRhLm5hbWV9KSwgNDAzXG4gICAgICBlcnJvcjogKGpxWEhSKSAtPlxuICAgICAgICB0cnlcbiAgICAgICAgICByZXR1cm4gaWYganFYSFIuc3RhdHVzIGlzIDQwMyAjIGxldCBzdGF0dXNDb2RlIGhhbmRsZXIgZGVhbCB3aXRoIGl0XG4gICAgICAgICAgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZSBqcVhIUi5yZXNwb25zZVRleHRcbiAgICAgICAgICBpZiByZXNwb25zZUpzb24ubWVzc2FnZSBpcyAnZXJyb3IuZHVwbGljYXRlJ1xuICAgICAgICAgICAgY2FsbGJhY2sgdHIgXCJ+RE9DU1RPUkUuU0FWRV9EVVBMSUNBVEVfRVJST1JcIiwge2ZpbGVuYW1lOiBtZXRhZGF0YS5uYW1lfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxiYWNrIHRyIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JfV0lUSF9NRVNTQUdFXCIsIHtmaWxlbmFtZTogbWV0YWRhdGEubmFtZSwgbWVzc2FnZTogcmVzcG9uc2VKc29uLm1lc3NhZ2V9XG4gICAgICAgIGNhdGNoXG4gICAgICAgICAgY2FsbGJhY2sgdHIgXCJ+RE9DU1RPUkUuU0FWRV9FUlJPUlwiLCB7ZmlsZW5hbWU6IG1ldGFkYXRhLm5hbWV9XG5cbiAgcmVtb3ZlOiAobWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgICQuYWpheFxuICAgICAgdXJsOiBAZG9jU3RvcmVVcmwuZGVsZXRlRG9jdW1lbnQoKVxuICAgICAgZGF0YTpcbiAgICAgICAgcmVjb3JkbmFtZTogbWV0YWRhdGEuZmlsZW5hbWVcbiAgICAgIGNvbnRleHQ6IEBcbiAgICAgIHhockZpZWxkczpcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgZGF0YVxuICAgICAgc3RhdHVzQ29kZTpcbiAgICAgICAgNDAzOiA9PlxuICAgICAgICAgIEB1c2VyID0gbnVsbFxuICAgICAgICAgIGNhbGxiYWNrIHRyKFwifkRPQ1NUT1JFLlJFTU9WRV80MDNfRVJST1JcIiwge2ZpbGVuYW1lOiBtZXRhZGF0YS5uYW1lfSksIDQwM1xuICAgICAgZXJyb3I6IChqcVhIUikgLT5cbiAgICAgICAgcmV0dXJuIGlmIGpxWEhSLnN0YXR1cyBpcyA0MDMgIyBsZXQgc3RhdHVzQ29kZSBoYW5kbGVyIGRlYWwgd2l0aCBpdFxuICAgICAgICBjYWxsYmFjayB0ciBcIn5ET0NTVE9SRS5SRU1PVkVfRVJST1JcIiwge2ZpbGVuYW1lOiBtZXRhZGF0YS5uYW1lfVxuXG4gIHJlbmFtZTogKG1ldGFkYXRhLCBuZXdOYW1lLCBjYWxsYmFjaykgLT5cbiAgICAkLmFqYXhcbiAgICAgIHVybDogQGRvY1N0b3JlVXJsLnJlbmFtZURvY3VtZW50KClcbiAgICAgIGRhdGE6XG4gICAgICAgIHJlY29yZGlkOiBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWRcbiAgICAgICAgbmV3UmVjb3JkbmFtZTogQ2xvdWRNZXRhZGF0YS53aXRoRXh0ZW5zaW9uIG5ld05hbWVcbiAgICAgIGNvbnRleHQ6IEBcbiAgICAgIHhockZpZWxkczpcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgbWV0YWRhdGEucmVuYW1lIG5ld05hbWVcbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgbWV0YWRhdGFcbiAgICAgIHN0YXR1c0NvZGU6XG4gICAgICAgIDQwMzogPT5cbiAgICAgICAgICBAdXNlciA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayB0cihcIn5ET0NTVE9SRS5SRU5BTUVfNDAzX0VSUk9SXCIsIHtmaWxlbmFtZTogbWV0YWRhdGEubmFtZX0pLCA0MDNcbiAgICAgIGVycm9yOiAoanFYSFIpIC0+XG4gICAgICAgIHJldHVybiBpZiBqcVhIUi5zdGF0dXMgaXMgNDAzICMgbGV0IHN0YXR1c0NvZGUgaGFuZGxlciBkZWFsIHdpdGggaXRcbiAgICAgICAgY2FsbGJhY2sgdHIgXCJ+RE9DU1RPUkUuUkVOQU1FX0VSUk9SXCIsIHtmaWxlbmFtZTogbWV0YWRhdGEubmFtZX1cblxuICBjYW5PcGVuU2F2ZWQ6IC0+IHRydWVcblxuICBvcGVuU2F2ZWQ6IChvcGVuU2F2ZWRQYXJhbXMsIGNhbGxiYWNrKSAtPlxuICAgIHByb3ZpZGVyRGF0YSA9IGlmIHR5cGVvZiBvcGVuU2F2ZWRQYXJhbXMgaXMgXCJvYmplY3RcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgIHRoZW4gb3BlblNhdmVkUGFyYW1zIFxcXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IGlkOiBvcGVuU2F2ZWRQYXJhbXMgfVxuICAgIG1ldGFkYXRhID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgcHJvdmlkZXI6IEBcbiAgICAgIHByb3ZpZGVyRGF0YTogcHJvdmlkZXJEYXRhXG5cbiAgICBAbG9hZCBtZXRhZGF0YSwgKGVyciwgY29udGVudCkgPT5cbiAgICAgIEBjbGllbnQucmVtb3ZlUXVlcnlQYXJhbXMgQHJlbW92YWJsZVF1ZXJ5UGFyYW1zXG4gICAgICBjYWxsYmFjayBlcnIsIGNvbnRlbnQsIG1ldGFkYXRhXG5cbiAgZ2V0T3BlblNhdmVkUGFyYW1zOiAobWV0YWRhdGEpIC0+XG4gICAgbWV0YWRhdGEucHJvdmlkZXJEYXRhLmlkXG5cbiAgZmlsZU9wZW5lZDogKGNvbnRlbnQsIG1ldGFkYXRhKSAtPlxuICAgIGRlcHJlY2F0aW9uUGhhc2UgPSBAb3B0aW9ucy5kZXByZWNhdGlvblBoYXNlIG9yIDBcbiAgICBmcm9tTGFyYSA9ICEhZ2V0UXVlcnlQYXJhbShcImxhdW5jaEZyb21MYXJhXCIpIG9yICEhZ2V0SGFzaFBhcmFtKFwibGFyYVwiKVxuICAgIHJldHVybiBpZiBub3QgZGVwcmVjYXRpb25QaGFzZSBvciBmcm9tTGFyYVxuICAgIEBjbGllbnQuY29uZmlybURpYWxvZyB7XG4gICAgICB0aXRsZTogdHIgJ35DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fU0FWRV9USVRMRSdcbiAgICAgIG1lc3NhZ2U6IEBkZXByZWNhdGlvbk1lc3NhZ2UoKVxuICAgICAgeWVzVGl0bGU6IHRyICd+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfRUxTRVdIRVJFJ1xuICAgICAgbm9UaXRsZTogdHIgJ35DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fRE9fSVRfTEFURVInXG4gICAgICBoaWRlTm9CdXR0b246IGRlcHJlY2F0aW9uUGhhc2UgPj0gM1xuICAgICAgY2FsbGJhY2s6ID0+XG4gICAgICAgIEBkaXNhYmxlRm9yTmV4dFNhdmUgPSB0cnVlXG4gICAgICAgIEBjbGllbnQuc2F2ZUZpbGVBc0RpYWxvZygpXG4gICAgICByZWplY3RDYWxsYmFjazogPT5cbiAgICAgICAgaWYgZGVwcmVjYXRpb25QaGFzZSA+IDFcbiAgICAgICAgICBAY2xpZW50LmFwcE9wdGlvbnMuYXV0b1NhdmVJbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRTdG9yZVByb3ZpZGVyXG4iLCJDbG91ZE1ldGFkYXRhID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuRG9jdW1lbnRTdG9yZVVybCA9IHJlcXVpcmUgJy4vZG9jdW1lbnQtc3RvcmUtdXJsJ1xucGFrbyA9IHJlcXVpcmUgJ3Bha28nXG5cbiNcbiMgQSB1dGlsaXR5IGNsYXNzIGZvciBwcm92aWRpbmcgc2hhcmluZyBmdW5jdGlvbmFsaXR5IHZpYSB0aGUgQ29uY29yZCBEb2N1bWVudCBTdG9yZS5cbiMgT3JpZ2luYWxseSwgc2hhcmluZyB3YXMgd3JhcHBlZCBpbnRvIHRoZSBQcm92aWRlciBpbnRlcmZhY2UsIGJ1dCBzaW5jZSB3ZSBoYXZlIG5vXG4jIHBsYW5zIHRvIGV4dGVuZCBzaGFyaW5nIHN1cHBvcnQgdG8gYXJiaXRyYXJ5IHByb3ZpZGVycyBsaWtlIEdvb2dsZSBEcml2ZSwgaXQgc2VlbXNcbiMgY2xlYW5lciB0byBicmVhayBvdXQgdGhlIHNoYXJpbmcgZnVuY3Rpb25hbGl0eSBpbnRvIGl0cyBvd24gY2xhc3MuXG4jXG5jbGFzcyBEb2N1bWVudFN0b3JlU2hhcmVQcm92aWRlclxuXG4gIGNvbnN0cnVjdG9yOiAoQGNsaWVudCwgQHByb3ZpZGVyKSAtPlxuICAgIEBkb2NTdG9yZVVybCA9IEBwcm92aWRlci5kb2NTdG9yZVVybFxuXG4gIGxvYWRTaGFyZWRDb250ZW50OiAoaWQsIGNhbGxiYWNrKSAtPlxuICAgIHNoYXJlZE1ldGFkYXRhID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgIHNoYXJlZENvbnRlbnRJZDogaWRcbiAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgb3ZlcndyaXRhYmxlOiBmYWxzZVxuICAgIEBwcm92aWRlci5sb2FkIHNoYXJlZE1ldGFkYXRhLCAoZXJyLCBjb250ZW50KSAtPlxuICAgICAgY2FsbGJhY2sgZXJyLCBjb250ZW50LCBzaGFyZWRNZXRhZGF0YVxuXG4gIGdldFNoYXJpbmdNZXRhZGF0YTogKHNoYXJlZCkgLT5cbiAgICB7IF9wZXJtaXNzaW9uczogaWYgc2hhcmVkIHRoZW4gMSBlbHNlIDAgfVxuXG4gIHNoYXJlOiAoc2hhcmVkLCBtYXN0ZXJDb250ZW50LCBzaGFyZWRDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG5cbiAgICAjIGRvY3VtZW50IElEIGlzIHN0b3JlZCBpbiBtYXN0ZXJDb250ZW50XG4gICAgZG9jdW1lbnRJRCA9IG1hc3RlckNvbnRlbnQuZ2V0KCdzaGFyZWREb2N1bWVudElkJylcblxuICAgICMgbmV3ZXIgVjIgZG9jdW1lbnRzIGhhdmUgJ2FjY2Vzc0tleXMnOyBsZWdhY3kgVjEgZG9jdW1lbnRzIGhhdmUgJ3NoYXJlZEVkaXRLZXknc1xuICAgICMgd2hpY2ggYXJlIGFjdHVhbGx5IFYxICdydW5LZXkncyB1bmRlciBhbiBhc3N1bWVkIG5hbWUgKHRvIHByb3RlY3QgdGhlaXIgaWRlbnRpdHk/KVxuICAgIGFjY2Vzc0tleXMgPSBtYXN0ZXJDb250ZW50LmdldCgnYWNjZXNzS2V5cycpXG4gICAgcnVuS2V5ID0gbWFzdGVyQ29udGVudC5nZXQoJ3NoYXJlRWRpdEtleScpXG5cbiAgICBhY2Nlc3NLZXkgPSBhY2Nlc3NLZXlzPy5yZWFkV3JpdGUgb3IgcnVuS2V5XG5cbiAgICBwYXJhbXMgPSB7c2hhcmVkOiBzaGFyZWR9XG4gICAgaWYgYWNjZXNzS2V5XG4gICAgICBwYXJhbXMuYWNjZXNzS2V5ID0gJ1JXOjonICsgYWNjZXNzS2V5XG5cbiAgICAjIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGRvY3VtZW50SUQgYW5kIHNvbWUgZm9ybSBvZiBhY2Nlc3NLZXksXG4gICAgIyB0aGVuIHdlIG11c3QgYmUgdXBkYXRpbmcgYW4gZXhpc3Rpbmcgc2hhcmVkIGRvY3VtZW50XG4gICAgaWYgZG9jdW1lbnRJRCBhbmQgYWNjZXNzS2V5XG4gICAgICB7bWV0aG9kLCB1cmx9ID0gQGRvY1N0b3JlVXJsLnYyU2F2ZURvY3VtZW50KGRvY3VtZW50SUQsIHBhcmFtcylcbiAgICAgICQuYWpheFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIHR5cGU6IG1ldGhvZFxuICAgICAgICB1cmw6IHVybFxuICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nICMgRG9jdW1lbnQgU3RvcmUgcmVxdWlyZXMgSlNPTiBjdXJyZW50bHlcbiAgICAgICAgZGF0YTogcGFrby5kZWZsYXRlIHNoYXJlZENvbnRlbnQuZ2V0Q29udGVudEFzSlNPTigpXG4gICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZVxuICAgICAgICBiZWZvcmVTZW5kOiAoeGhyKSAtPlxuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LUVuY29kaW5nJywgJ2RlZmxhdGUnKVxuICAgICAgICBjb250ZXh0OiBAXG4gICAgICAgIHhockZpZWxkczpcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWVcbiAgICAgICAgc3VjY2VzczogKGRhdGEpIC0+XG4gICAgICAgICAgIyBvbiBzdWNjZXNzZnVsIHNoYXJlL3NhdmUsIGNhcHR1cmUgdGhlIHNoYXJlZERvY3VtZW50SWQgYW5kIHNoYXJlRWRpdEtleVxuICAgICAgICAgIGlmIHJ1bktleSBhbmQgbm90IGFjY2Vzc0tleXM/XG4gICAgICAgICAgICBtYXN0ZXJDb250ZW50LmFkZE1ldGFkYXRhXG4gICAgICAgICAgICAgIGFjY2Vzc0tleXM6IHsgcmVhZFdyaXRlOiBydW5LZXkgfVxuICAgICAgICAgIGNhbGxiYWNrIG51bGwsIGRhdGEuaWRcbiAgICAgICAgZXJyb3I6IChqcVhIUikgLT5cbiAgICAgICAgICBkb2NOYW1lID0gbWV0YWRhdGE/LmZpbGVuYW1lIG9yICdkb2N1bWVudCdcbiAgICAgICAgICBjYWxsYmFjayBcIlVuYWJsZSB0byB1cGRhdGUgc2hhcmVkICcje2RvY05hbWV9J1wiXG5cbiAgICAjIGlmIHdlIGRvbid0IGhhdmUgYSBkb2N1bWVudCBJRCBhbmQgc29tZSBmb3JtIG9mIGFjY2Vzc0tleSxcbiAgICAjIHRoZW4gd2UgbXVzdCBjcmVhdGUgYSBuZXcgc2hhcmVkIGRvY3VtZW50IHdoZW4gc2hhcmluZyBpcyBiZWluZyBlbmFibGVkXG4gICAgZWxzZSBpZiBzaGFyZWRcbiAgICAgIHBhcmFtcy5zaGFyZWQgPSB0cnVlXG4gICAgICB7bWV0aG9kLCB1cmx9ID0gQGRvY1N0b3JlVXJsLnYyQ3JlYXRlRG9jdW1lbnQocGFyYW1zKVxuICAgICAgJC5hamF4XG4gICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgdHlwZTogbWV0aG9kXG4gICAgICAgIHVybDogdXJsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicgIyBEb2N1bWVudCBTdG9yZSByZXF1aXJlcyBKU09OIGN1cnJlbnRseVxuICAgICAgICBkYXRhOiBwYWtvLmRlZmxhdGUgc2hhcmVkQ29udGVudC5nZXRDb250ZW50QXNKU09OKClcbiAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlXG4gICAgICAgIGJlZm9yZVNlbmQ6ICh4aHIpIC0+XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnLCAnZGVmbGF0ZScpXG4gICAgICAgIGNvbnRleHQ6IEBcbiAgICAgICAgeGhyRmllbGRzOlxuICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxuICAgICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgICAjIG9uIHN1Y2Nlc3NmdWwgc2hhcmUvc2F2ZSwgY2FwdHVyZSB0aGUgc2hhcmVkRG9jdW1lbnRJZCBhbmQgYWNjZXNzS2V5c1xuICAgICAgICAgIG1hc3RlckNvbnRlbnQuYWRkTWV0YWRhdGFcbiAgICAgICAgICAgIHNoYXJlZERvY3VtZW50SWQ6IGRhdGEuaWRcbiAgICAgICAgICAgIGFjY2Vzc0tleXM6IHsgcmVhZE9ubHk6IGRhdGEucmVhZEFjY2Vzc0tleSwgcmVhZFdyaXRlOiBkYXRhLnJlYWRXcml0ZUFjY2Vzc0tleSB9XG4gICAgICAgICAgY2FsbGJhY2sgbnVsbCwgZGF0YS5pZFxuICAgICAgICBlcnJvcjogKGpxWEhSKSAtPlxuICAgICAgICAgIGRvY05hbWUgPSBtZXRhZGF0YT8uZmlsZW5hbWUgb3IgJ2RvY3VtZW50J1xuICAgICAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIHNoYXJlICcje2RvY05hbWV9J1wiXG4gICAgZWxzZVxuICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gdW5zaGFyZSAnI3tkb2NOYW1lfSdcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50U3RvcmVTaGFyZVByb3ZpZGVyXG4iLCIjXG4jIFRoaXMgdXRpbGl0eSBjbGFzcyBzaW1wbGlmaWVzIHdvcmtpbmcgd2l0aCBkb2N1bWVudCBzdG9yZSBVUkxzXG4jXG5cbiMgZGVmYXVsdCBkb2N1bWVudCBzdG9yZSBVUkwgaWYgY2xpZW50IGRvZXNuJ3QgcHJvdmlkZSBvbmVcbmRlZmF1bHREb2NTdG9yZVVybCA9IFwiLy9kb2N1bWVudC1zdG9yZS5jb25jb3JkLm9yZ1wiXG5cbmNsYXNzIERvY3VtZW50U3RvcmVVcmxcblxuICBjb25zdHJ1Y3RvcjogKGRvY1N0b3JlVXJsKSAtPlxuICAgIEBkb2NTdG9yZVVybCA9IGRvY1N0b3JlVXJsIG9yIGRlZmF1bHREb2NTdG9yZVVybFxuICAgICMgZWxpbWluYXRlIHRyYWlsaW5nIHNsYXNoZXNcbiAgICBAZG9jU3RvcmVVcmwgPSBAZG9jU3RvcmVVcmwucmVwbGFjZSgvXFwvKyQvLCAnJylcblxuICBhZGRQYXJhbXM6ICh1cmwsIHBhcmFtcykgLT5cbiAgICByZXR1cm4gdXJsIHVubGVzcyBwYXJhbXNcbiAgICBrdnAgPSBbXVxuICAgIGZvciBrZXksIHZhbHVlIG9mIHBhcmFtc1xuICAgICAga3ZwLnB1c2ggW2tleSwgdmFsdWVdLm1hcChlbmNvZGVVUkkpLmpvaW4gXCI9XCJcbiAgICByZXR1cm4gdXJsICsgXCI/XCIgKyBrdnAuam9pbiBcIiZcIlxuXG4gICNcbiAgIyBWZXJzaW9uIDEgQVBJXG4gICNcbiAgYXV0aG9yaXplOiAocGFyYW1zKSAtPlxuICAgIEBhZGRQYXJhbXMgXCIje0Bkb2NTdG9yZVVybH0vdXNlci9hdXRoZW50aWNhdGVcIiwgcGFyYW1zXG5cbiAgY2hlY2tMb2dpbjogKHBhcmFtcykgLT5cbiAgICBAYWRkUGFyYW1zIFwiI3tAZG9jU3RvcmVVcmx9L3VzZXIvaW5mb1wiLCBwYXJhbXNcblxuICBsaXN0RG9jdW1lbnRzOiAocGFyYW1zKSAtPlxuICAgIEBhZGRQYXJhbXMgXCIje0Bkb2NTdG9yZVVybH0vZG9jdW1lbnQvYWxsXCIsIHBhcmFtc1xuXG4gIGxvYWREb2N1bWVudDogKHBhcmFtcykgLT5cbiAgICBAYWRkUGFyYW1zIFwiI3tAZG9jU3RvcmVVcmx9L2RvY3VtZW50L29wZW5cIiwgcGFyYW1zXG5cbiAgc2F2ZURvY3VtZW50OiAocGFyYW1zKSAtPlxuICAgIEBhZGRQYXJhbXMgXCIje0Bkb2NTdG9yZVVybH0vZG9jdW1lbnQvc2F2ZVwiLCBwYXJhbXNcblxuICBwYXRjaERvY3VtZW50OiAocGFyYW1zKSAtPlxuICAgIEBhZGRQYXJhbXMgXCIje0Bkb2NTdG9yZVVybH0vZG9jdW1lbnQvcGF0Y2hcIiwgcGFyYW1zXG5cbiAgZGVsZXRlRG9jdW1lbnQ6IChwYXJhbXMpIC0+XG4gICAgQGFkZFBhcmFtcyBcIiN7QGRvY1N0b3JlVXJsfS9kb2N1bWVudC9kZWxldGVcIiwgcGFyYW1zXG5cbiAgcmVuYW1lRG9jdW1lbnQ6IChwYXJhbXMpIC0+XG4gICAgQGFkZFBhcmFtcyBcIiN7QGRvY1N0b3JlVXJsfS9kb2N1bWVudC9yZW5hbWVcIiwgcGFyYW1zXG5cbiAgI1xuICAjIFZlcnNpb24gMiBBUElcbiAgI1xuICB2MkRvY3VtZW50OiAoaWQsIHBhcmFtcykgLT5cbiAgICBAYWRkUGFyYW1zIFwiI3tAZG9jU3RvcmVVcmx9L3YyL2RvY3VtZW50cy8je2lkfVwiLCBwYXJhbXNcblxuICB2MkNyZWF0ZURvY3VtZW50OiAocGFyYW1zKSAtPlxuICAgIHsgbWV0aG9kOiAnUE9TVCcsIHVybDogQHYyRG9jdW1lbnQoJycsIHBhcmFtcykgfVxuICAgIFxuICB2MkxvYWREb2N1bWVudDogKGlkLCBwYXJhbXMpIC0+XG4gICAgeyBtZXRob2Q6ICdHRVQnLCB1cmw6IEB2MkRvY3VtZW50KGlkLCBwYXJhbXMpIH1cbiAgICBcbiAgdjJTYXZlRG9jdW1lbnQ6IChpZCwgcGFyYW1zKSAtPlxuICAgIHsgbWV0aG9kOiAnUFVUJywgdXJsOiBAdjJEb2N1bWVudChpZCwgcGFyYW1zKSB9XG4gICAgXG4gIHYyUGF0Y2hEb2N1bWVudDogKGlkLCBwYXJhbXMpIC0+XG4gICAgeyBtZXRob2Q6ICdQQVRDSCcsIHVybDogQHYyRG9jdW1lbnQoaWQsIHBhcmFtcykgfVxuICAgIFxuICAjIE5vdCBpbXBsZW1lbnRlZCBieSB0aGUgc2VydmVyXG4gICMgdjJEZWxldGVEb2N1bWVudDogKGlkLCBwYXJhbXMpIC0+XG4gICMgICB7IG1ldGhvZDogJ0RFTEVURScsIHVybDogQHYyRG9jdW1lbnQoaWQsIHBhcmFtcykgfVxuICAgIFxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudFN0b3JlVXJsXG4iLCJ7ZGl2LCBidXR0b24sIHNwYW59ID0gUmVhY3QuRE9NXG5cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuaXNTdHJpbmcgPSByZXF1aXJlICcuLi91dGlscy9pcy1zdHJpbmcnXG5qc2RpZmYgPSByZXF1aXJlICdkaWZmJ1xuXG5Qcm92aWRlckludGVyZmFjZSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLlByb3ZpZGVySW50ZXJmYWNlXG5jbG91ZENvbnRlbnRGYWN0b3J5ID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuY2xvdWRDb250ZW50RmFjdG9yeVxuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLkNsb3VkTWV0YWRhdGFcblxuR29vZ2xlRHJpdmVBdXRob3JpemF0aW9uRGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSBSZWFjdC5jcmVhdGVDbGFzc1xuICBkaXNwbGF5TmFtZTogJ0dvb2dsZURyaXZlQXV0aG9yaXphdGlvbkRpYWxvZydcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgbG9hZGVkR0FQSTogd2luZG93Ll9Mb2FkZWRHQVBJQ2xpZW50c1xuXG4gICMgU2VlIGNvbW1lbnRzIGluIEF1dGhvcml6ZU1peGluIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGUgaXNzdWVzIGhlcmUuXG4gICMgVGhlIHNob3J0IHZlcnNpb24gaXMgdGhhdCB3ZSBuZWVkIHRvIG1haW50YWluIHN5bmNocm9uaXplZCBpbnN0YW5jZSB2YXJpYWJsZVxuICAjIGFuZCBzdGF0ZSB0byB0cmFjayBhdXRob3JpemF0aW9uIHN0YXR1cyB3aGlsZSBhdm9pZGluZyBjYWxsaW5nIHNldFN0YXRlIG9uXG4gICMgdW5tb3VudGVkIGNvbXBvbmVudHMsIHdoaWNoIGRvZXNuJ3Qgd29yayBhbmQgdHJpZ2dlcnMgYSBSZWFjdCB3YXJuaW5nLlxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogLT5cbiAgICBAcHJvcHMucHJvdmlkZXIuX2xvYWRlZEdBUEkgPT5cbiAgICAgIGlmIEBfaXNNb3VudGVkXG4gICAgICAgIEBzZXRTdGF0ZSBsb2FkZWRHQVBJOiB0cnVlXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgQF9pc01vdW50ZWQgPSB0cnVlXG4gICAgaWYgQHN0YXRlLmxvYWRlZEdBUEkgaXNudCB3aW5kb3cuX0xvYWRlZEdBUElDbGllbnRzXG4gICAgICBAc2V0U3RhdGUgbG9hZGVkR0FQSTogd2luZG93Ll9Mb2FkZWRHQVBJQ2xpZW50c1xuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIEBfaXNNb3VudGVkID0gZmFsc2VcblxuICBhdXRoZW50aWNhdGU6IC0+XG4gICAgQHByb3BzLnByb3ZpZGVyLmF1dGhvcml6ZSBHb29nbGVEcml2ZVByb3ZpZGVyLlNIT1dfUE9QVVBcblxuICByZW5kZXI6IC0+XG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnZ29vZ2xlLWRyaXZlLWF1dGgnfSxcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2dvb2dsZS1kcml2ZS1jb25jb3JkLWxvZ28nfSwgJycpXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdnb29nbGUtZHJpdmUtZm9vdGVyJ30sXG4gICAgICAgIGlmIHdpbmRvdy5fTG9hZGVkR0FQSUNsaWVudHMgb3IgQHN0YXRlLmxvYWRlZEdBUElcbiAgICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAYXV0aGVudGljYXRlfSwgKHRyIFwifkdPT0dMRV9EUklWRS5MT0dJTl9CVVRUT05fTEFCRUxcIikpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAodHIgXCJ+R09PR0xFX0RSSVZFLkNPTk5FQ1RJTkdfTUVTU0FHRVwiKVxuICAgICAgKVxuICAgIClcblxuY2xhc3MgR29vZ2xlRHJpdmVQcm92aWRlciBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlXG5cbiAgY29uc3RydWN0b3I6IChAb3B0aW9ucyA9IHt9LCBAY2xpZW50KSAtPlxuICAgIHN1cGVyXG4gICAgICBuYW1lOiBHb29nbGVEcml2ZVByb3ZpZGVyLk5hbWVcbiAgICAgIGRpc3BsYXlOYW1lOiBAb3B0aW9ucy5kaXNwbGF5TmFtZSBvciAodHIgJ35QUk9WSURFUi5HT09HTEVfRFJJVkUnKVxuICAgICAgdXJsRGlzcGxheU5hbWU6IEBvcHRpb25zLnVybERpc3BsYXlOYW1lXG4gICAgICBjYXBhYmlsaXRpZXM6XG4gICAgICAgIHNhdmU6IHRydWVcbiAgICAgICAgcmVzYXZlOiB0cnVlXG4gICAgICAgIGV4cG9ydDogdHJ1ZVxuICAgICAgICBsb2FkOiB0cnVlXG4gICAgICAgIGxpc3Q6IHRydWVcbiAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgICByZW5hbWU6IHRydWVcbiAgICAgICAgY2xvc2U6IHRydWVcbiAgICAgICAgc2V0Rm9sZGVyOiB0cnVlXG5cbiAgICBAYXV0aFRva2VuID0gbnVsbFxuICAgIEB1c2VyID0gbnVsbFxuICAgIEBjbGllbnRJZCA9IEBvcHRpb25zLmNsaWVudElkXG4gICAgaWYgbm90IEBjbGllbnRJZFxuICAgICAgdGhyb3cgbmV3IEVycm9yICh0ciBcIn5HT09HTEVfRFJJVkUuRVJST1JfTUlTU0lOR19DTElFTlRJRFwiKVxuICAgIEBzY29wZXMgPSBAb3B0aW9ucy5zY29wZXMgb3IgW1xuICAgICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUnXG4gICAgICAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kcml2ZS5pbnN0YWxsJ1xuICAgICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuZmlsZSdcbiAgICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3VzZXJpbmZvLnByb2ZpbGUnXG4gICAgXVxuICAgIEBtaW1lVHlwZSA9IEBvcHRpb25zLm1pbWVUeXBlIG9yIFwidGV4dC9wbGFpblwiXG4gICAgQHJlYWRhYmxlTWltZXR5cGVzID0gQG9wdGlvbnMucmVhZGFibGVNaW1ldHlwZXNcbiAgICBAdXNlUmVhbFRpbWVBUEkgPSBAb3B0aW9ucy51c2VSZWFsVGltZUFQSSBvciBmYWxzZVxuICAgIGlmIEB1c2VSZWFsVGltZUFQSVxuICAgICAgQG1pbWVUeXBlICs9ICcrY2ZtX3JlYWx0aW1lJ1xuICAgIEBfbG9hZEdBUEkoKVxuXG4gIEBOYW1lOiAnZ29vZ2xlRHJpdmUnXG5cbiAgIyBhbGlhc2VzIGZvciBib29sZWFuIHBhcmFtZXRlciB0byBhdXRob3JpemVcbiAgQElNTUVESUFURSA9IHRydWVcbiAgQFNIT1dfUE9QVVAgPSBmYWxzZVxuXG4gIGF1dGhvcml6ZWQ6IChhdXRoQ2FsbGJhY2spIC0+XG4gICAgQGF1dGhDYWxsYmFjayA9IGF1dGhDYWxsYmFjayB1bmxlc3Mgbm90IGF1dGhDYWxsYmFjaz9cbiAgICBpZiBhdXRoQ2FsbGJhY2tcbiAgICAgIGlmIEBhdXRoVG9rZW5cbiAgICAgICAgYXV0aENhbGxiYWNrIHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgQGF1dGhvcml6ZSBHb29nbGVEcml2ZVByb3ZpZGVyLklNTUVESUFURVxuICAgIGVsc2VcbiAgICAgIEBhdXRoVG9rZW4gaXNudCBudWxsXG5cbiAgYXV0aG9yaXplOiAoaW1tZWRpYXRlKSAtPlxuICAgIEBfbG9hZGVkR0FQSSA9PlxuICAgICAgYXJncyA9XG4gICAgICAgIGNsaWVudF9pZDogQGNsaWVudElkXG4gICAgICAgIHNjb3BlOiBAc2NvcGVzXG4gICAgICAgIGltbWVkaWF0ZTogaW1tZWRpYXRlXG4gICAgICBnYXBpLmF1dGguYXV0aG9yaXplIGFyZ3MsIChhdXRoVG9rZW4pID0+XG4gICAgICAgIEBhdXRoVG9rZW4gPSBpZiBhdXRoVG9rZW4gYW5kIG5vdCBhdXRoVG9rZW4uZXJyb3IgdGhlbiBhdXRoVG9rZW4gZWxzZSBudWxsXG4gICAgICAgIEB1c2VyID0gbnVsbFxuICAgICAgICBAYXV0b1JlbmV3VG9rZW4gQGF1dGhUb2tlblxuICAgICAgICBpZiBAYXV0aFRva2VuXG4gICAgICAgICAgZ2FwaS5jbGllbnQub2F1dGgyLnVzZXJpbmZvLmdldCgpLmV4ZWN1dGUgKHVzZXIpID0+XG4gICAgICAgICAgICBAdXNlciA9IHVzZXJcbiAgICAgICAgQGF1dGhDYWxsYmFjaz8gQGF1dGhUb2tlbiBpc250IG51bGxcblxuICBhdXRvUmVuZXdUb2tlbjogKGF1dGhUb2tlbikgLT5cbiAgICBpZiBAX2F1dG9SZW5ld1RpbWVvdXRcbiAgICAgIGNsZWFyVGltZW91dCBAX2F1dG9SZW5ld1RpbWVvdXRcbiAgICBpZiBhdXRoVG9rZW4gYW5kIG5vdCBhdXRoVG9rZW4uZXJyb3JcbiAgICAgIEBfYXV0b1JlbmV3VGltZW91dCA9IHNldFRpbWVvdXQgKD0+IEBhdXRob3JpemUgR29vZ2xlRHJpdmVQcm92aWRlci5JTU1FRElBVEUpLCAocGFyc2VJbnQoYXV0aFRva2VuLmV4cGlyZXNfaW4sIDEwKSAqIDAuNzUpICogMTAwMFxuXG4gIHJlbmRlckF1dGhvcml6YXRpb25EaWFsb2c6IC0+XG4gICAgKEdvb2dsZURyaXZlQXV0aG9yaXphdGlvbkRpYWxvZyB7cHJvdmlkZXI6IEB9KVxuXG4gIHJlbmRlclVzZXI6IC0+XG4gICAgaWYgQHVzZXJcbiAgICAgIChzcGFuIHt9LCAoc3BhbiB7Y2xhc3NOYW1lOiAnZ2RyaXZlLWljb24nfSksIEB1c2VyLm5hbWUpXG4gICAgZWxzZVxuICAgICAgbnVsbFxuXG4gIHNhdmU6ICAoY29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIEBfbG9hZGVkR0FQSSA9PlxuICAgICAgaWYgQHVzZVJlYWxUaW1lQVBJXG4gICAgICAgIEBfc2F2ZVJlYWxUaW1lRmlsZSBjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcbiAgICAgIGVsc2VcbiAgICAgICAgQF9zYXZlRmlsZSBjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcblxuICBsb2FkOiAobWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIEBfbG9hZGVkR0FQSSA9PlxuICAgICAgaWYgQHVzZVJlYWxUaW1lQVBJXG4gICAgICAgIEBfbG9hZE9yQ3JlYXRlUmVhbFRpbWVGaWxlIG1ldGFkYXRhLCBjYWxsYmFja1xuICAgICAgZWxzZVxuICAgICAgICBAX2xvYWRGaWxlIG1ldGFkYXRhLCBjYWxsYmFja1xuXG4gIGxpc3Q6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgQF9sb2FkZWRHQVBJID0+XG4gICAgICBtaW1lVHlwZXNRdWVyeSA9IChcIm1pbWVUeXBlID0gJyN7bWltZVR5cGV9J1wiIGZvciBtaW1lVHlwZSBpbiBAcmVhZGFibGVNaW1ldHlwZXMpLmpvaW4gXCIgb3IgXCJcbiAgICAgIHJlcXVlc3QgPSBnYXBpLmNsaWVudC5kcml2ZS5maWxlcy5saXN0XG4gICAgICAgIHE6IHF1ZXJ5ID0gXCJ0cmFzaGVkID0gZmFsc2UgYW5kICgje21pbWVUeXBlc1F1ZXJ5fSBvciBtaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZm9sZGVyJykgYW5kICcje2lmIG1ldGFkYXRhIHRoZW4gbWV0YWRhdGEucHJvdmlkZXJEYXRhLmlkIGVsc2UgJ3Jvb3QnfScgaW4gcGFyZW50c1wiXG4gICAgICByZXF1ZXN0LmV4ZWN1dGUgKHJlc3VsdCkgPT5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEBfYXBpRXJyb3IocmVzdWx0LCAnVW5hYmxlIHRvIGxpc3QgZmlsZXMnKSkgaWYgbm90IHJlc3VsdCBvciByZXN1bHQuZXJyb3JcbiAgICAgICAgbGlzdCA9IFtdXG4gICAgICAgIGZvciBpdGVtIGluIHJlc3VsdD8uaXRlbXNcbiAgICAgICAgICB0eXBlID0gaWYgaXRlbS5taW1lVHlwZSBpcyAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLmZvbGRlcicgdGhlbiBDbG91ZE1ldGFkYXRhLkZvbGRlciBlbHNlIENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgICAgIGlmIHR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5Gb2xkZXIgb3IgQG1hdGNoZXNFeHRlbnNpb24gaXRlbS50aXRsZVxuICAgICAgICAgICAgbGlzdC5wdXNoIG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICAgICAgICAgIG5hbWU6IGl0ZW0udGl0bGVcbiAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICBwYXJlbnQ6IG1ldGFkYXRhXG4gICAgICAgICAgICAgIG92ZXJ3cml0YWJsZTogaXRlbS5lZGl0YWJsZVxuICAgICAgICAgICAgICBwcm92aWRlcjogQFxuICAgICAgICAgICAgICBwcm92aWRlckRhdGE6XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWRcbiAgICAgICAgbGlzdC5zb3J0IChhLCBiKSAtPlxuICAgICAgICAgIGxvd2VyQSA9IGEubmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgbG93ZXJCID0gYi5uYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICByZXR1cm4gLTEgaWYgbG93ZXJBIDwgbG93ZXJCXG4gICAgICAgICAgcmV0dXJuIDEgaWYgbG93ZXJBID4gbG93ZXJCXG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgbGlzdFxuXG4gIHJlbW92ZTogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICBAX2xvYWRlZEdBUEkgLT5cbiAgICAgIHJlcXVlc3QgPSBnYXBpLmNsaWVudC5kcml2ZS5maWxlcy5kZWxldGVcbiAgICAgICAgZmlsZUlkOiBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWRcbiAgICAgIHJlcXVlc3QuZXhlY3V0ZSAocmVzdWx0KSAtPlxuICAgICAgICBjYWxsYmFjaz8gcmVzdWx0Py5lcnJvciBvciBudWxsXG5cbiAgcmVuYW1lOiAobWV0YWRhdGEsIG5ld05hbWUsIGNhbGxiYWNrKSAtPlxuICAgIEBfbG9hZGVkR0FQSSAtPlxuICAgICAgcmVxdWVzdCA9IGdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLnBhdGNoXG4gICAgICAgIGZpbGVJZDogbWV0YWRhdGEucHJvdmlkZXJEYXRhLmlkXG4gICAgICAgIHJlc291cmNlOlxuICAgICAgICAgIHRpdGxlOiBDbG91ZE1ldGFkYXRhLndpdGhFeHRlbnNpb24gbmV3TmFtZVxuICAgICAgcmVxdWVzdC5leGVjdXRlIChyZXN1bHQpIC0+XG4gICAgICAgIGlmIHJlc3VsdD8uZXJyb3JcbiAgICAgICAgICBjYWxsYmFjaz8gcmVzdWx0LmVycm9yXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtZXRhZGF0YS5yZW5hbWUgbmV3TmFtZVxuICAgICAgICAgIGNhbGxiYWNrIG51bGwsIG1ldGFkYXRhXG5cbiAgY2xvc2U6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5yZWFsVGltZT8uZG9jP1xuICAgICAgbWV0YWRhdGEucHJvdmlkZXJEYXRhLnJlYWxUaW1lLmRvYy5jbG9zZSgpXG5cbiAgY2FuT3BlblNhdmVkOiAtPiB0cnVlXG5cbiAgb3BlblNhdmVkOiAob3BlblNhdmVkUGFyYW1zLCBjYWxsYmFjaykgLT5cbiAgICBtZXRhZGF0YSA9IG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkZpbGVcbiAgICAgIHByb3ZpZGVyOiBAXG4gICAgICBwcm92aWRlckRhdGE6XG4gICAgICAgIGlkOiBvcGVuU2F2ZWRQYXJhbXNcbiAgICBAbG9hZCBtZXRhZGF0YSwgKGVyciwgY29udGVudCkgLT5cbiAgICAgIGNhbGxiYWNrIGVyciwgY29udGVudCwgbWV0YWRhdGFcblxuICBnZXRPcGVuU2F2ZWRQYXJhbXM6IChtZXRhZGF0YSkgLT5cbiAgICBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWRcblxuICBpc0F1dGhvcml6YXRpb25SZXF1aXJlZDogLT5cbiAgICB0cnVlXG5cbiAgX2xvYWRHQVBJOiAtPlxuICAgIGlmIG5vdCB3aW5kb3cuX0xvYWRpbmdHQVBJXG4gICAgICB3aW5kb3cuX0xvYWRpbmdHQVBJID0gdHJ1ZVxuICAgICAgd2luZG93Ll9HQVBJT25Mb2FkID0gPT5cbiAgICAgICAgd2luZG93Ll9Mb2FkZWRHQVBJID0gdHJ1ZVxuICAgICAgICAjIHByZWxvYWQgY2xpZW50cyB0byBhdm9pZCB1c2VyIGRlbGF5IGxhdGVyXG4gICAgICAgIEBfbG9hZGVkR0FQSSAtPlxuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnc2NyaXB0J1xuICAgICAgc2NyaXB0LnNyYyA9ICdodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9jbGllbnQuanM/b25sb2FkPV9HQVBJT25Mb2FkJ1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCBzY3JpcHRcblxuICBfbG9hZGVkR0FQSTogKGNhbGxiYWNrKSAtPlxuICAgIGlmIHdpbmRvdy5fTG9hZGVkR0FQSUNsaWVudHNcbiAgICAgIGNhbGxiYWNrKClcbiAgICBlbHNlXG4gICAgICBzZWxmID0gQFxuICAgICAgY2hlY2sgPSAtPlxuICAgICAgICBpZiB3aW5kb3cuX0xvYWRlZEdBUElcbiAgICAgICAgICBnYXBpLmNsaWVudC5sb2FkICdkcml2ZScsICd2MicsIC0+XG4gICAgICAgICAgICBnYXBpLmNsaWVudC5sb2FkICdvYXV0aDInLCAndjInLCAtPlxuICAgICAgICAgICAgICBnYXBpLmxvYWQgJ2RyaXZlLXJlYWx0aW1lJywgLT5cbiAgICAgICAgICAgICAgICB3aW5kb3cuX0xvYWRlZEdBUElDbGllbnRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwgc2VsZlxuICAgICAgICBlbHNlXG4gICAgICAgICAgc2V0VGltZW91dCBjaGVjaywgMTBcbiAgICAgIHNldFRpbWVvdXQgY2hlY2ssIDEwXG5cbiAgX2xvYWRGaWxlOiAobWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIHJlcXVlc3QgPSBnYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXRcbiAgICAgIGZpbGVJZDogbWV0YWRhdGEucHJvdmlkZXJEYXRhLmlkXG4gICAgcmVxdWVzdC5leGVjdXRlIChmaWxlKSA9PlxuICAgICAgaWYgZmlsZT8uZG93bmxvYWRVcmxcbiAgICAgICAgbWV0YWRhdGEucmVuYW1lIGZpbGUudGl0bGVcbiAgICAgICAgbWV0YWRhdGEub3ZlcndyaXRhYmxlID0gZmlsZS5lZGl0YWJsZVxuICAgICAgICBtZXRhZGF0YS5wcm92aWRlckRhdGEgPSBpZDogZmlsZS5pZFxuICAgICAgICBtZXRhZGF0YS5taW1lVHlwZSA9IGZpbGUubWltZVR5cGVcbiAgICAgICAgaWYgbm90IG1ldGFkYXRhLnBhcmVudD8gYW5kIGZpbGUucGFyZW50cz8ubGVuZ3RoID4gMFxuICAgICAgICAgIG1ldGFkYXRhLnBhcmVudCA9IG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICAgICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkZvbGRlclxuICAgICAgICAgICAgcHJvdmlkZXI6IEBcbiAgICAgICAgICAgIHByb3ZpZGVyRGF0YTpcbiAgICAgICAgICAgICAgaWQ6IGZpbGUucGFyZW50c1swXS5pZFxuICAgICAgICB1cmwgPSBmaWxlLmRvd25sb2FkVXJsXG4gICAgICAgICMgdXNlIGFjY2Vzc190b2tlbiBhcyBxdWVyeSBwYXJhbWV0ZXIgaW5zdGVhZCBvZiBoZWFkZXIgdG8gYXZvaWQgQ09SUyByZXF1ZXN0IHdoaWNoIGJyZWFrcyBpbiBJRSAxMVxuICAgICAgICB1cmwgKz0gXCIje2lmIHVybC5pbmRleE9mKFwiP1wiKSBpcyAtMSB0aGVuIFwiP1wiIGVsc2UgXCImXCJ9YWNjZXNzX3Rva2VuPSN7ZW5jb2RlVVJJQ29tcG9uZW50KEBhdXRoVG9rZW4uYWNjZXNzX3Rva2VuKX1cIlxuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB4aHIub3BlbiAnR0VUJywgdXJsXG4gICAgICAgIHhoci5vbmxvYWQgPSAtPlxuICAgICAgICAgIGNhbGxiYWNrIG51bGwsIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgeGhyLm9uZXJyb3IgPSAtPlxuICAgICAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIGRvd25sb2FkIGZpbGUgY29udGVudFwiXG4gICAgICAgIHhoci5zZW5kKClcbiAgICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2sgQF9hcGlFcnJvciBmaWxlLCAnVW5hYmxlIHRvIGdldCBkb3dubG9hZCB1cmwnXG5cbiAgX3NhdmVGaWxlOiAoY29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIGJvdW5kYXJ5ID0gJy0tLS0tLS0zMTQxNTkyNjUzNTg5NzkzMjM4NDYnXG4gICAgbWltZVR5cGUgPSBtZXRhZGF0YS5taW1lVHlwZSBvciBAbWltZVR5cGVcbiAgICBoZWFkZXIgPSBKU09OLnN0cmluZ2lmeVxuICAgICAgdGl0bGU6IG1ldGFkYXRhLmZpbGVuYW1lXG4gICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgIHBhcmVudHM6IFt7aWQ6IGlmIG1ldGFkYXRhLnBhcmVudD8ucHJvdmlkZXJEYXRhPy5pZD8gdGhlbiBtZXRhZGF0YS5wYXJlbnQucHJvdmlkZXJEYXRhLmlkIGVsc2UgJ3Jvb3QnfV1cblxuICAgIFttZXRob2QsIHBhdGhdID0gaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5pZFxuICAgICAgWydQVVQnLCBcIi91cGxvYWQvZHJpdmUvdjIvZmlsZXMvI3ttZXRhZGF0YS5wcm92aWRlckRhdGEuaWR9XCJdXG4gICAgZWxzZVxuICAgICAgWydQT1NUJywgJy91cGxvYWQvZHJpdmUvdjIvZmlsZXMnXVxuXG4gICAgdHJhbnNmZXJFbmNvZGluZyA9IFwiXCJcbiAgICBpZiBtaW1lVHlwZS5pbmRleE9mKFwiaW1hZ2UvXCIpIGlzIDBcbiAgICAgICMgYXNzdW1lIHdlJ3JlIHRyYW5zZmVyaW5nIGFueSBpbWFnZXMgYXMgYmFzZTY0XG4gICAgICB0cmFuc2ZlckVuY29kaW5nID0gXCJcXHJcXG5Db250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiBiYXNlNjRcIlxuXG4gICAgYm9keSA9IFtcbiAgICAgIFwiXFxyXFxuLS0je2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxcclxcblxcclxcbiN7aGVhZGVyfVwiLFxuICAgICAgXCJcXHJcXG4tLSN7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1UeXBlOiAje21pbWVUeXBlfSN7dHJhbnNmZXJFbmNvZGluZ31cXHJcXG5cXHJcXG4je2NvbnRlbnQuZ2V0Q29udGVudEFzSlNPTj8oKSBvciBjb250ZW50fVwiLFxuICAgICAgXCJcXHJcXG4tLSN7Ym91bmRhcnl9LS1cIlxuICAgIF0uam9pbiAnJ1xuXG4gICAgcmVxdWVzdCA9IGdhcGkuY2xpZW50LnJlcXVlc3RcbiAgICAgIHBhdGg6IHBhdGhcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICBwYXJhbXM6IHt1cGxvYWRUeXBlOiAnbXVsdGlwYXJ0J31cbiAgICAgIGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT1cIicgKyBib3VuZGFyeSArICdcIid9XG4gICAgICBib2R5OiBib2R5XG5cbiAgICByZXF1ZXN0LmV4ZWN1dGUgKGZpbGUpID0+XG4gICAgICBpZiBjYWxsYmFja1xuICAgICAgICBpZiBmaWxlPy5lcnJvclxuICAgICAgICAgIGNhbGxiYWNrIFwiVW5hYmxlZCB0byB1cGxvYWQgZmlsZTogI3tmaWxlLmVycm9yLm1lc3NhZ2V9XCJcbiAgICAgICAgZWxzZSBpZiBmaWxlXG4gICAgICAgICAgbWV0YWRhdGEucHJvdmlkZXJEYXRhID0gaWQ6IGZpbGUuaWRcbiAgICAgICAgICBjYWxsYmFjayBudWxsLCBmaWxlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjYWxsYmFjayBAX2FwaUVycm9yIGZpbGUsICdVbmFibGVkIHRvIHVwbG9hZCBmaWxlJ1xuXG4gIF9sb2FkT3JDcmVhdGVSZWFsVGltZUZpbGU6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgc2VsZiA9IEBcbiAgICBmaWxlTG9hZGVkID0gKGRvYykgLT5cbiAgICAgIGNvbnRlbnQgPSBkb2MuZ2V0TW9kZWwoKS5nZXRSb290KCkuZ2V0ICdjb250ZW50J1xuICAgICAgaWYgbWV0YWRhdGEub3ZlcndyaXRhYmxlXG4gICAgICAgIHRocm93RXJyb3IgPSAoZSkgLT5cbiAgICAgICAgICBpZiBub3QgZS5pc0xvY2FsIGFuZCBlLnNlc3Npb25JZCBpc250IG1ldGFkYXRhLnByb3ZpZGVyRGF0YS5yZWFsVGltZS5zZXNzaW9uSWRcbiAgICAgICAgICAgIHNlbGYuY2xpZW50LnNob3dCbG9ja2luZ01vZGFsXG4gICAgICAgICAgICAgIHRpdGxlOiAnQ29uY3VycmVudCBFZGl0IExvY2snXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdBbiBlZGl0IHdhcyBtYWRlIHRvIHRoaXMgZmlsZSBmcm9tIGFub3RoZXIgYnJvd3NlciB3aW5kb3cuIFRoaXMgYXBwIGlzIG5vdyBsb2NrZWQgZm9yIGlucHV0LidcbiAgICAgICAgY29udGVudC5hZGRFdmVudExpc3RlbmVyIGdhcGkuZHJpdmUucmVhbHRpbWUuRXZlbnRUeXBlLlRFWFRfSU5TRVJURUQsIHRocm93RXJyb3JcbiAgICAgICAgY29udGVudC5hZGRFdmVudExpc3RlbmVyIGdhcGkuZHJpdmUucmVhbHRpbWUuRXZlbnRUeXBlLlRFWFRfREVMRVRFRCwgdGhyb3dFcnJvclxuICAgICAgZm9yIGNvbGxhYm9yYXRvciBpbiBkb2MuZ2V0Q29sbGFib3JhdG9ycygpXG4gICAgICAgIHNlc3Npb25JZCA9IGNvbGxhYm9yYXRvci5zZXNzaW9uSWQgaWYgY29sbGFib3JhdG9yLmlzTWVcbiAgICAgIG1ldGFkYXRhLnByb3ZpZGVyRGF0YS5yZWFsVGltZSA9XG4gICAgICAgIGRvYzogZG9jXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWRcbiAgICAgIGNhbGxiYWNrIG51bGwsIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGNvbnRlbnQuZ2V0VGV4dCgpXG5cbiAgICBpbml0ID0gKG1vZGVsKSAtPlxuICAgICAgY29udGVudCA9IG1vZGVsLmNyZWF0ZVN0cmluZyAnJ1xuICAgICAgbW9kZWwuZ2V0Um9vdCgpLnNldCAnY29udGVudCcsIGNvbnRlbnRcblxuICAgIGVycm9yID0gKGVycikgPT5cbiAgICAgIGlmIGVyci50eXBlIGlzICdUT0tFTl9SRUZSRVNIX1JFUVVJUkVEJ1xuICAgICAgICBAYXV0aG9yaXplIEdvb2dsZURyaXZlUHJvdmlkZXIuSU1NRURJQVRFXG4gICAgICBlbHNlXG4gICAgICAgIEBjbGllbnQuYWxlcnQgZXJyLm1lc3NhZ2VcblxuICAgIGlmIG1ldGFkYXRhLnByb3ZpZGVyRGF0YT8uaWRcbiAgICAgIHJlcXVlc3QgPSBnYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXRcbiAgICAgICAgZmlsZUlkOiBtZXRhZGF0YS5wcm92aWRlckRhdGEuaWRcbiAgICBlbHNlXG4gICAgICByZXF1ZXN0ID0gZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuaW5zZXJ0XG4gICAgICAgIHRpdGxlOiBtZXRhZGF0YS5maWxlbmFtZVxuICAgICAgICBtaW1lVHlwZTogQG1pbWVUeXBlXG4gICAgICAgIHBhcmVudHM6IFt7aWQ6IGlmIG1ldGFkYXRhLnBhcmVudD8ucHJvdmlkZXJEYXRhPy5pZD8gdGhlbiBtZXRhZGF0YS5wYXJlbnQucHJvdmlkZXJEYXRhLmlkIGVsc2UgJ3Jvb3QnfV1cblxuICAgIHJlcXVlc3QuZXhlY3V0ZSAoZmlsZSkgPT5cbiAgICAgIGlmIGZpbGU/LmlkXG4gICAgICAgIG1ldGFkYXRhLnJlbmFtZSBmaWxlLnRpdGxlXG4gICAgICAgIG1ldGFkYXRhLm92ZXJ3cml0YWJsZSA9IGZpbGUuZWRpdGFibGVcbiAgICAgICAgbWV0YWRhdGEucHJvdmlkZXJEYXRhID0gaWQ6IGZpbGUuaWRcbiAgICAgICAgZ2FwaS5kcml2ZS5yZWFsdGltZS5sb2FkIGZpbGUuaWQsIGZpbGVMb2FkZWQsIGluaXQsIGVycm9yXG4gICAgICBlbHNlXG4gICAgICAgIGNhbGxiYWNrIEBfYXBpRXJyb3IgZmlsZSwgJ1VuYWJsZSB0byBsb2FkIGZpbGUnXG5cbiAgX3NhdmVSZWFsVGltZUZpbGU6IChjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5tb2RlbFxuICAgICAgQF9kaWZmQW5kVXBkYXRlUmVhbFRpbWVNb2RlbCBjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcbiAgICBlbHNlXG4gICAgICBAX2xvYWRPckNyZWF0ZVJlYWxUaW1lRmlsZSBtZXRhZGF0YSwgKGVycikgPT5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrIGVyciBpZiBlcnJcbiAgICAgICAgQF9kaWZmQW5kVXBkYXRlUmVhbFRpbWVNb2RlbCBjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcblxuICBfZGlmZkFuZFVwZGF0ZVJlYWxUaW1lTW9kZWw6IChjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgaW5kZXggPSAwXG4gICAgcmVhbFRpbWVDb250ZW50ID0gbWV0YWRhdGEucHJvdmlkZXJEYXRhLnJlYWxUaW1lLmNvbnRlbnRcbiAgICBkaWZmcyA9IGpzZGlmZi5kaWZmQ2hhcnMgcmVhbFRpbWVDb250ZW50LmdldFRleHQoKSwgY29udGVudC5nZXRDb250ZW50QXNKU09OKClcbiAgICBmb3IgZGlmZiBpbiBkaWZmc1xuICAgICAgaWYgZGlmZi5yZW1vdmVkXG4gICAgICAgIHJlYWxUaW1lQ29udGVudC5yZW1vdmVSYW5nZSBpbmRleCwgaW5kZXggKyBkaWZmLnZhbHVlLmxlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBpZiBkaWZmLmFkZGVkXG4gICAgICAgICAgcmVhbFRpbWVDb250ZW50Lmluc2VydFN0cmluZyBpbmRleCwgZGlmZi52YWx1ZVxuICAgICAgICBpbmRleCArPSBkaWZmLmNvdW50XG4gICAgY2FsbGJhY2sgbnVsbFxuXG4gIF9hcGlFcnJvcjogKHJlc3VsdCwgcHJlZml4KSAtPlxuICAgIGlmIHJlc3VsdD8ubWVzc2FnZT9cbiAgICAgIFwiI3twcmVmaXh9OiAje3Jlc3VsdC5tZXNzYWdlfVwiXG4gICAgZWxzZVxuICAgICAgcHJlZml4XG5cbm1vZHVsZS5leHBvcnRzID0gR29vZ2xlRHJpdmVQcm92aWRlclxuIiwiUHJvdmlkZXJJbnRlcmZhY2UgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5Qcm92aWRlckludGVyZmFjZVxuY2xvdWRDb250ZW50RmFjdG9yeSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLmNsb3VkQ29udGVudEZhY3RvcnlcbkNsb3VkTWV0YWRhdGEgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5DbG91ZE1ldGFkYXRhXG5Eb2N1bWVudFN0b3JlVXJsID0gcmVxdWlyZSAnLi9kb2N1bWVudC1zdG9yZS11cmwnXG5QYXRjaGFibGVDb250ZW50ID0gcmVxdWlyZSAnLi9wYXRjaGFibGUtY29udGVudCdcbmdldFF1ZXJ5UGFyYW0gPSByZXF1aXJlICcuLi91dGlscy9nZXQtcXVlcnktcGFyYW0nXG5iYXNlNjQgPSAocmVxdWlyZSAnanMtYmFzZTY0JykuQmFzZTY0XG5wYWtvID0gcmVxdWlyZSAncGFrbydcblxuIyBUaGlzIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBsYXJhOi4uLiBwcm90b2NvbCB1c2VkIGZvciBkb2N1bWVudHMgbGF1bmNoZWRcbiMgZnJvbSBMQVJBLiBJdCBsb29rcyB1cCB0aGUgZG9jdW1lbnQgSUQgYW5kIGFjY2VzcyBrZXlzIGZyb20gdGhlIExBUkFcbiMgaW50ZXJhY3RpdmUgcnVuIHN0YXRlIGFuZCB0aGVuIHVzZXMgdGhlIFYyIERvY1N0b3JlIEFQSSB0byByZWFkL3dyaXRlXG4jIGRvY3VtZW50cyBmcm9tIHRoZSBDb25jb3JkIERvY3VtZW50IFN0b3JlLiBJdCBkb2VzIG5vdCBzdXBwb3J0IGFyYml0cmFyeVxuIyBvcGVuaW5nL3NhdmluZyBvZiBkb2N1bWVudHMgYW5kIHNvIHNob3VsZCBub3QgYXBwZWFyIGluIHRoZSBsaXN0IG9mXG4jIHBsYWNlcyB1c2VycyBjYW4gY2hvb3NlIHRvIG9wZW4vc2F2ZSBmaWxlcyBsaWtlIEdvb2dsZSBEcml2ZSBkb2VzLlxuXG5jbGFzcyBMYXJhUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckludGVyZmFjZVxuXG4gIEBOYW1lOiAnbGFyYSdcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgc3VwZXJcbiAgICAgIG5hbWU6IExhcmFQcm92aWRlci5OYW1lXG4gICAgICBjYXBhYmlsaXRpZXM6XG4gICAgICAgIHNhdmU6IHRydWVcbiAgICAgICAgcmVzYXZlOiB0cnVlXG4gICAgICAgIGV4cG9ydDogZmFsc2VcbiAgICAgICAgbG9hZDogdHJ1ZVxuICAgICAgICBsaXN0OiBmYWxzZVxuICAgICAgICByZW1vdmU6IGZhbHNlXG4gICAgICAgIHJlbmFtZTogZmFsc2VcbiAgICAgICAgY2xvc2U6IGZhbHNlXG5cbiAgICBAdXJsUGFyYW1zID0ge1xuICAgICAgZG9jdW1lbnRTZXJ2ZXI6IGdldFF1ZXJ5UGFyYW0gXCJkb2N1bWVudFNlcnZlclwiXG4gICAgICBsYXVuY2hGcm9tTGFyYTogZ2V0UXVlcnlQYXJhbSBcImxhdW5jaEZyb21MYXJhXCJcbiAgICB9XG4gICAgQHJlbW92YWJsZVF1ZXJ5UGFyYW1zID0gWydsYXVuY2hGcm9tTGFyYScsICdydW5Bc0d1ZXN0J11cblxuICAgIEBsYXJhUGFyYW1zID0gaWYgQHVybFBhcmFtcy5sYXVuY2hGcm9tTGFyYSB0aGVuIEBkZWNvZGVQYXJhbXMoQHVybFBhcmFtcy5sYXVuY2hGcm9tTGFyYSkgZWxzZSBudWxsXG4gICAgQG9wZW5TYXZlZFBhcmFtcyA9IG51bGxcbiAgICBAY29sbGFib3JhdG9yVXJscyA9IFtdXG5cbiAgICBAZG9jU3RvcmVVcmwgPSBuZXcgRG9jdW1lbnRTdG9yZVVybCBAdXJsUGFyYW1zLmRvY3VtZW50U2VydmVyXG5cbiAgICBAc2F2ZWRDb250ZW50ID0gbmV3IFBhdGNoYWJsZUNvbnRlbnQoQG9wdGlvbnMucGF0Y2hPYmplY3RIYXNoKVxuXG4gIGVuY29kZVBhcmFtczogKHBhcmFtcykgLT5cbiAgICBiYXNlNjQuZW5jb2RlVVJJKEpTT04uc3RyaW5naWZ5KHBhcmFtcykpXG5cbiAgZGVjb2RlUGFyYW1zOiAocGFyYW1zKSAtPlxuICAgIHRyeVxuICAgICAgZGVjb2RlZCA9IEpTT04ucGFyc2UoYmFzZTY0LmRlY29kZShwYXJhbXMpKVxuICAgIGNhdGNoIGVcbiAgICAgIGRlY29kZWQgPSBudWxsXG4gICAgZGVjb2RlZFxuXG4gIGhhbmRsZVVybFBhcmFtczogLT5cbiAgICBpZiBAbGFyYVBhcmFtc1xuICAgICAgQGNsaWVudC5vcGVuUHJvdmlkZXJGaWxlIEBuYW1lLCBAbGFyYVBhcmFtc1xuICAgICAgdHJ1ZSAjIHNpZ25hbCB0aGF0IHRoZSBwcm92aWRlciBpcyBoYW5kbGluZyB0aGUgcGFyYW1zXG4gICAgZWxzZVxuICAgICAgZmFsc2VcblxuICBsb2dMYXJhRGF0YTogKGxhcmFEYXRhKSAtPlxuICAgIGxhcmFEYXRhLmNvbGxhYm9yYXRvclVybHMgPSBAY29sbGFib3JhdG9yVXJscyBpZiBAY29sbGFib3JhdG9yVXJscz8ubGVuZ3RoXG4gICAgQG9wdGlvbnMubG9nTGFyYURhdGEgbGFyYURhdGEgaWYgQG9wdGlvbnMubG9nTGFyYURhdGFcbiAgICBAY2xpZW50LmxvZyAnbG9nTGFyYURhdGEnLCBsYXJhRGF0YVxuXG4gICMgZG9uJ3Qgc2hvdyBpbiBwcm92aWRlciBvcGVuL3NhdmUgZGlhbG9nc1xuICBmaWx0ZXJUYWJDb21wb25lbnQ6IChjYXBhYmlsaXR5LCBkZWZhdWx0Q29tcG9uZW50KSAtPlxuICAgIG51bGxcblxuICBleHRyYWN0UmF3RGF0YUZyb21SdW5TdGF0ZTogKHJ1blN0YXRlKSAtPlxuICAgIHJhd0RhdGEgPSBydW5TdGF0ZT8ucmF3X2RhdGEgb3Ige31cbiAgICBpZiB0eXBlb2YgcmF3RGF0YSBpcyBcInN0cmluZ1wiXG4gICAgICB0cnlcbiAgICAgICAgcmF3RGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSlcbiAgICAgIGNhdGNoIGVcbiAgICAgICAgcmF3RGF0YSA9IHt9XG4gICAgcmF3RGF0YVxuXG4gIGNhbjogKGNhcGFiaWxpdHksIG1ldGFkYXRhKSAtPlxuICAgIGhhc1JlYWRPbmx5QWNjZXNzID0gbWV0YWRhdGE/LnByb3ZpZGVyRGF0YT8uYWNjZXNzS2V5cz8ucmVhZE9ubHk/IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90IG1ldGFkYXRhPy5wcm92aWRlckRhdGE/LmFjY2Vzc0tleXM/LnJlYWRXcml0ZT9cbiAgICByZXF1aXJlc1dyaXRlQWNjZXNzID0gWydzYXZlJywgJ3Jlc2F2ZScsICdyZW1vdmUnLCAncmVuYW1lJ10uaW5kZXhPZihjYXBhYmlsaXR5KSA+PSAwXG4gICAgc3VwZXIoY2FwYWJpbGl0eSwgbWV0YWRhdGEpIGFuZCBub3QgKHJlcXVpcmVzV3JpdGVBY2Nlc3MgYW5kIGhhc1JlYWRPbmx5QWNjZXNzKVxuXG4gIGxvYWQ6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAge21ldGhvZCwgdXJsfSA9IEBkb2NTdG9yZVVybC52MkxvYWREb2N1bWVudChtZXRhZGF0YS5wcm92aWRlckRhdGE/LnJlY29yZGlkKVxuXG4gICAgaWYgbWV0YWRhdGEucHJvdmlkZXJEYXRhPy5hY2Nlc3NLZXlzPy5yZWFkT25seVxuICAgICAgYWNjZXNzS2V5ID0gJ1JPOjonICsgbWV0YWRhdGEucHJvdmlkZXJEYXRhLmFjY2Vzc0tleXMucmVhZE9ubHlcbiAgICBlbHNlIGlmIG1ldGFkYXRhLnByb3ZpZGVyRGF0YT8uYWNjZXNzS2V5cz8ucmVhZFdyaXRlXG4gICAgICBhY2Nlc3NLZXkgPSAnUlc6OicgKyBtZXRhZGF0YS5wcm92aWRlckRhdGEuYWNjZXNzS2V5cy5yZWFkV3JpdGVcblxuICAgICQuYWpheFxuICAgICAgdHlwZTogbWV0aG9kXG4gICAgICB1cmw6IHVybFxuICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgZGF0YTpcbiAgICAgICAgYWNjZXNzS2V5OiBhY2Nlc3NLZXlcbiAgICAgIGNvbnRleHQ6IEBcblxuICAgICAgc3VjY2VzczogKGRhdGEpID0+XG4gICAgICAgIEBsb2dMYXJhRGF0YSB7XG4gICAgICAgICAgb3BlcmF0aW9uOiAnb3BlbidcbiAgICAgICAgICBkb2N1bWVudElEOiBtZXRhZGF0YS5wcm92aWRlckRhdGE/LnJlY29yZGlkXG4gICAgICAgICAgZG9jdW1lbnRVcmw6IHVybFxuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBjbG91ZENvbnRlbnRGYWN0b3J5LmNyZWF0ZUVudmVsb3BlZENsb3VkQ29udGVudCBkYXRhXG5cbiAgICAgICAgIyBmb3IgZG9jdW1lbnRzIGxvYWRlZCBieSBpZCBvciBvdGhlciBtZWFucyAoYmVzaWRlcyBuYW1lKSxcbiAgICAgICAgIyBjYXB0dXJlIHRoZSBuYW1lIGZvciB1c2UgaW4gdGhlIENGTSBpbnRlcmZhY2UuXG4gICAgICAgICMgJ2RvY05hbWUnIGF0IHRoZSB0b3AgbGV2ZWwgZm9yIENGTS13cmFwcGVkIGRvY3VtZW50c1xuICAgICAgICAjICduYW1lJyBhdCB0aGUgdG9wIGxldmVsIGZvciB1bndyYXBwZWQgZG9jdW1lbnRzIChlLmcuIENPREFQKVxuICAgICAgICAjICduYW1lJyBhdCB0aGUgdG9wIGxldmVsIG9mICdjb250ZW50JyBmb3Igd3JhcHBlZCBDT0RBUCBkb2N1bWVudHNcbiAgICAgICAgbWV0YWRhdGEucmVuYW1lIG1ldGFkYXRhLm5hbWUgb3IgZGF0YS5kb2NOYW1lIG9yIGRhdGEubmFtZSBvciBkYXRhLmNvbnRlbnQ/Lm5hbWVcbiAgICAgICAgaWYgbWV0YWRhdGEubmFtZVxuICAgICAgICAgIGNvbnRlbnQuYWRkTWV0YWRhdGEgZG9jTmFtZTogbWV0YWRhdGEuZmlsZW5hbWVcblxuICAgICAgICBjYWxsYmFjayBudWxsLCBjb250ZW50XG5cbiAgICAgIGVycm9yOiAoanFYSFIpIC0+XG4gICAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIGxvYWQgI3ttZXRhZGF0YS5uYW1lIG9yIG1ldGFkYXRhLnByb3ZpZGVyRGF0YT8ucmVjb3JkaWQgb3IgJ2ZpbGUnfVwiXG5cbiAgc2F2ZTogKGNsb3VkQ29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrLCBkaXNhYmxlUGF0Y2gpIC0+XG4gICAgY29udGVudCA9IGNsb3VkQ29udGVudC5nZXRDb250ZW50KClcblxuICAgICMgU2VlIGlmIHdlIGNhbiBwYXRjaFxuICAgIGNhblBhdGNoID0gQG9wdGlvbnMucGF0Y2ggYW5kIG1ldGFkYXRhLm92ZXJ3cml0YWJsZSBhbmQgbm90IGRpc2FibGVQYXRjaFxuICAgIHBhdGNoUmVzdWx0cyA9IEBzYXZlZENvbnRlbnQuY3JlYXRlUGF0Y2goY29udGVudCwgY2FuUGF0Y2gpXG5cbiAgICBpZiBwYXRjaFJlc3VsdHMuc2hvdWxkUGF0Y2ggYW5kIG5vdCBwYXRjaFJlc3VsdHMuZGlmZkxlbmd0aFxuICAgICAgIyBubyByZWFzb24gdG8gcGF0Y2ggaWYgdGhlcmUgYXJlIG5vIGRpZmZzXG4gICAgICBjYWxsYmFjayBudWxsICMgbm8gZXJyb3IgaW5kaWNhdGVzIHN1Y2Nlc3NcbiAgICAgIHJldHVyblxuXG4gICAgcGFyYW1zID0ge31cbiAgICBpZiBub3QgcGF0Y2hSZXN1bHRzLnNob3VsZFBhdGNoIGFuZCBtZXRhZGF0YS5maWxlbmFtZVxuICAgICAgcGFyYW1zLnJlY29yZG5hbWUgPSBtZXRhZGF0YS5maWxlbmFtZVxuXG4gICAgaWYgKG1ldGFkYXRhPy5wcm92aWRlckRhdGE/LmFjY2Vzc0tleXM/LnJlYWRXcml0ZT8pXG4gICAgICBwYXJhbXMuYWNjZXNzS2V5ID0gJ1JXOjonICsgbWV0YWRhdGEucHJvdmlkZXJEYXRhLmFjY2Vzc0tleXMucmVhZFdyaXRlXG5cbiAgICB7bWV0aG9kLCB1cmx9ID0gaWYgcGF0Y2hSZXN1bHRzLnNob3VsZFBhdGNoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgdGhlbiBAZG9jU3RvcmVVcmwudjJQYXRjaERvY3VtZW50KG1ldGFkYXRhLnByb3ZpZGVyRGF0YS5yZWNvcmRpZCwgcGFyYW1zKSBcXFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgQGRvY1N0b3JlVXJsLnYyU2F2ZURvY3VtZW50KG1ldGFkYXRhLnByb3ZpZGVyRGF0YS5yZWNvcmRpZCwgcGFyYW1zKVxuXG4gICAgbG9nRGF0YSA9XG4gICAgICBvcGVyYXRpb246ICdzYXZlJ1xuICAgICAgcHJvdmlkZXI6ICdMYXJhUHJvdmlkZXInXG4gICAgICBzaG91bGRQYXRjaDogcGF0Y2hSZXN1bHRzLnNob3VsZFBhdGNoXG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgIyBlbGlkZSBhbGwgYnV0IGZpcnN0IHR3byBjaGFycyBvZiBhY2Nlc3NLZXlcbiAgICAgIHVybDogdXJsLnN1YnN0cigwLCB1cmwuaW5kZXhPZignYWNjZXNzS2V5JykgKyAxNikgKyAnLi4uJ1xuICAgICAgcGFyYW1zOiBKU09OLnN0cmluZ2lmeSh7IHJlY29yZG5hbWU6IHBhcmFtcy5yZWNvcmRuYW1lIH0pXG4gICAgICBjb250ZW50OiBwYXRjaFJlc3VsdHMuc2VuZENvbnRlbnQuc3Vic3RyKDAsIDUxMilcbiAgICBAY2xpZW50LmxvZyAnc2F2ZScsIGxvZ0RhdGFcblxuICAgICQuYWpheFxuICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgdHlwZTogbWV0aG9kXG4gICAgICB1cmw6IHVybFxuICAgICAgZGF0YTogcGFrby5kZWZsYXRlIHBhdGNoUmVzdWx0cy5zZW5kQ29udGVudFxuICAgICAgY29udGVudFR5cGU6IHBhdGNoUmVzdWx0cy5taW1lVHlwZVxuICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlXG4gICAgICBiZWZvcmVTZW5kOiAoeGhyKSAtPlxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1FbmNvZGluZycsICdkZWZsYXRlJylcbiAgICAgIGNvbnRleHQ6IEBcbiAgICAgIHN1Y2Nlc3M6IChkYXRhKSAtPlxuICAgICAgICBAc2F2ZWRDb250ZW50LnVwZGF0ZUNvbnRlbnQoaWYgQG9wdGlvbnMucGF0Y2ggdGhlbiBfLmNsb25lRGVlcChjb250ZW50KSBlbHNlIG51bGwpXG4gICAgICAgIGlmIGRhdGEucmVjb3JkaWQgdGhlbiBtZXRhZGF0YS5wcm92aWRlckRhdGEucmVjb3JkaWQgPSBkYXRhLnJlY29yZGlkXG5cbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgZGF0YVxuXG4gICAgICBlcnJvcjogKGpxWEhSKSAtPlxuICAgICAgICAjIGlmIHBhdGNoIGZhaWxzLCB0cnkgYSBmdWxsIHNhdmVcbiAgICAgICAgaWYgcGF0Y2hSZXN1bHRzLnNob3VsZFBhdGNoXG4gICAgICAgICAgQHNhdmUoY2xvdWRDb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2ssIHRydWUpXG4gICAgICAgICMgaWYgZnVsbCBzYXZlIGZhaWxzLCByZXR1cm4gZXJyb3IgbWVzc2FnZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICByZXNwb25zZUpzb24gPSBKU09OLnBhcnNlIGpxWEhSLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgaWYgcmVzcG9uc2VKc29uLm1lc3NhZ2UgaXMgJ2Vycm9yLmR1cGxpY2F0ZSdcbiAgICAgICAgICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gY3JlYXRlICN7bWV0YWRhdGEubmFtZX0uIEZpbGUgYWxyZWFkeSBleGlzdHMuXCJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gc2F2ZSAje21ldGFkYXRhLm5hbWV9OiBbI3tyZXNwb25zZUpzb24ubWVzc2FnZX1dXCJcbiAgICAgICAgICBjYXRjaFxuICAgICAgICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gc2F2ZSAje21ldGFkYXRhLm5hbWV9XCJcblxuICBjYW5PcGVuU2F2ZWQ6IC0+IHRydWVcblxuICBvcGVuU2F2ZWQ6IChvcGVuU2F2ZWRQYXJhbXMsIGNhbGxiYWNrKSAtPlxuICAgIG1ldGFkYXRhID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgcHJvdmlkZXI6IEBcblxuICAgIGlmIHR5cGVvZiBvcGVuU2F2ZWRQYXJhbXMgaXMgXCJzdHJpbmdcIlxuICAgICAgb3BlblNhdmVkUGFyYW1zID0gQGRlY29kZVBhcmFtcyBvcGVuU2F2ZWRQYXJhbXNcblxuICAgIEBvcGVuU2F2ZWRQYXJhbXMgPSBvcGVuU2F2ZWRQYXJhbXNcbiAgICBAY29sbGFib3JhdG9yVXJscyA9IGlmIG9wZW5TYXZlZFBhcmFtcz8uY29sbGFib3JhdG9yVXJscz8ubGVuZ3RoID4gMCB0aGVuIG9wZW5TYXZlZFBhcmFtcy5jb2xsYWJvcmF0b3JVcmxzIGVsc2UgW11cblxuICAgIGxvYWRQcm92aWRlckZpbGUgPSAocHJvdmlkZXJEYXRhLCBjYWxsYmFjaykgPT5cbiAgICAgIG1ldGFkYXRhLnByb3ZpZGVyRGF0YSA9IHByb3ZpZGVyRGF0YVxuICAgICAgQGxvYWQgbWV0YWRhdGEsIChlcnIsIGNvbnRlbnQpID0+XG4gICAgICAgIEBjbGllbnQucmVtb3ZlUXVlcnlQYXJhbXMgQHJlbW92YWJsZVF1ZXJ5UGFyYW1zXG4gICAgICAgIGNhbGxiYWNrIGVyciwgY29udGVudCwgbWV0YWRhdGFcblxuICAgICNcbiAgICAjIGlmIHdlIGhhdmUgYSBkb2N1bWVudCBJRCB3ZSBjYW4ganVzdCBsb2FkIHRoZSBkb2N1bWVudFxuICAgICNcbiAgICByZXR1cm4gbG9hZFByb3ZpZGVyRmlsZSBvcGVuU2F2ZWRQYXJhbXMsIGNhbGxiYWNrIGlmIG9wZW5TYXZlZFBhcmFtcz8ucmVjb3JkaWRcblxuICAgICNcbiAgICAjIFByb2Nlc3MgdGhlIGluaXRpYWwgcnVuIHN0YXRlIHJlc3BvbnNlXG4gICAgI1xuICAgIHByb2Nlc3NJbml0aWFsUnVuU3RhdGUgPSAocnVuU3RhdGVVcmwsIHNvdXJjZUlELCByZWFkT25seUtleSwgcnVuU3RhdGUpID0+XG4gICAgICBleGlzdGluZ1J1blN0YXRlID0gQGV4dHJhY3RSYXdEYXRhRnJvbVJ1blN0YXRlIHJ1blN0YXRlXG4gICAgICBkb2NTdG9yZSA9IGV4aXN0aW5nUnVuU3RhdGUuZG9jU3RvcmVcblxuICAgICAgaGF2ZUNvbGxhYm9yYXRvcnMgPSBAY29sbGFib3JhdG9yVXJscy5sZW5ndGggPiAwXG5cbiAgICAgIHVwZGF0ZUludGVyYWN0aXZlUnVuU3RhdGVzID0gKHVybHMsIG5ld0RvY1N0b3JlLCBjYWxsYmFjaykgLT5cblxuICAgICAgICBuZXdSdW5TdGF0ZSA9IF8uY2xvbmVEZWVwIGV4aXN0aW5nUnVuU3RhdGVcbiAgICAgICAgbmV3UnVuU3RhdGUuZG9jU3RvcmUgPSBuZXdEb2NTdG9yZVxuXG4gICAgICAgIHJhd0RhdGEgPSBKU09OLnN0cmluZ2lmeShuZXdSdW5TdGF0ZSlcbiAgICAgICAgbGVhcm5lclVybCA9IGlmIG5ld1J1blN0YXRlLmxlYXJuZXJfdXJsPyBhbmQgdHlwZW9mIG5ld1J1blN0YXRlLmxlYXJuZXJfdXJsIGlzIFwic3RyaW5nXCIgdGhlbiBuZXdSdW5TdGF0ZS5sZWFybmVyX3VybCBlbHNlIG51bGxcbiAgICAgICAgbGVhcm5lclBhcmFtID0gaWYgbGVhcm5lclVybCB0aGVuIFwiJmxlYXJuZXJfdXJsPSN7ZW5jb2RlVVJJQ29tcG9uZW50KGxlYXJuZXJVcmwpfVwiIGVsc2UgXCJcIlxuXG4gICAgICAgIHVwZGF0ZVJ1blN0YXRlID0gKHVybCwgZG9uZSkgLT5cbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdHlwZTogJ1BVVCdcbiAgICAgICAgICAgIHVybDogXCIje3VybH0/cmF3X2RhdGE9I3tlbmNvZGVVUklDb21wb25lbnQocmF3RGF0YSl9I3tsZWFybmVyUGFyYW19XCJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICAgIHhockZpZWxkczpcbiAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZG9uZSAoZGF0YSwgc3RhdHVzLCBqcVhIUikgLT5cbiAgICAgICAgICAgIGlmIGRhdGE/LnN1Y2Nlc3MgaXMgZmFsc2VcbiAgICAgICAgICAgICAgZG9uZShcIkNvdWxkIG5vdCBvcGVuIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQgYmVjYXVzZSBhbiBlcnJvciBvY2N1cnJlZCBbdXBkYXRlU3RhdGVdICgje2RhdGEubWVzc2FnZX0pXCIpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGRvbmUobnVsbClcbiAgICAgICAgICAuZmFpbCAoanFYSFIsIHN0YXR1cywgZXJyb3IpIC0+XG4gICAgICAgICAgICBkb25lKFwiQ291bGQgbm90IG9wZW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudCBiZWNhdXNlIGFuIGVycm9yIG9jY3VycmVkIFt1cGRhdGVTdGF0ZV1cIilcblxuICAgICAgICB1cmxRdWV1ZSA9IHVybHMuc2xpY2UoKVxuICAgICAgICBwcm9jZXNzUXVldWUgPSAtPlxuICAgICAgICAgIGlmIHVybFF1ZXVlLmxlbmd0aCBpcyAwXG4gICAgICAgICAgICBjYWxsYmFjayBudWxsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXJsID0gdXJsUXVldWUuc2hpZnQoKVxuICAgICAgICAgICAgdXBkYXRlUnVuU3RhdGUgdXJsLCAoZXJyKSAtPlxuICAgICAgICAgICAgICBpZiBlcnJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayBlcnJcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpXG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpXG5cbiAgICAgIHByb2Nlc3NDcmVhdGVSZXNwb25zZSA9IChjcmVhdGVSZXNwb25zZSkgPT5cbiAgICAgICAgZG9jU3RvcmUgPVxuICAgICAgICAgIHJlY29yZGlkOiBjcmVhdGVSZXNwb25zZS5pZFxuICAgICAgICAgIGFjY2Vzc0tleXM6XG4gICAgICAgICAgICByZWFkT25seTogY3JlYXRlUmVzcG9uc2UucmVhZEFjY2Vzc0tleVxuICAgICAgICAgICAgcmVhZFdyaXRlOiBjcmVhdGVSZXNwb25zZS5yZWFkV3JpdGVBY2Nlc3NLZXlcblxuICAgICAgICBjb2RhcFVybCA9IGlmIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gXFxcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiN7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0je3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX1cIiBcXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIFwiI3t3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8je3dpbmRvdy5sb2NhdGlvbi5ob3N0fSN7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfVwiXG4gICAgICAgIHJlcG9ydFVybExhcmFQYXJhbXMgPVxuICAgICAgICAgIHJlY29yZGlkOiBjcmVhdGVSZXNwb25zZS5pZFxuICAgICAgICAgIGFjY2Vzc0tleXM6XG4gICAgICAgICAgICByZWFkT25seTogY3JlYXRlUmVzcG9uc2UucmVhZEFjY2Vzc0tleVxuICAgICAgICBlbmNvZGVkTGFyYVBhcmFtcyA9IEBlbmNvZGVQYXJhbXMgcmVwb3J0VXJsTGFyYVBhcmFtc1xuICAgICAgICBleGlzdGluZ1J1blN0YXRlLmxhcmFfb3B0aW9ucyA/PSB7fVxuICAgICAgICBleGlzdGluZ1J1blN0YXRlLmxhcmFfb3B0aW9ucy5yZXBvcnRpbmdfdXJsID0gXCIje2NvZGFwVXJsfT9sYXVuY2hGcm9tTGFyYT0je2VuY29kZWRMYXJhUGFyYW1zfVwiXG5cbiAgICAgICMgQ2hlY2sgaWYgd2UgaGF2ZSBhIGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1biBzdGF0ZSBhbHJlYWR5ICgyYSkgb3Igbm90ICgyYilcbiAgICAgIGlmIGRvY1N0b3JlPy5yZWNvcmRpZD8gYW5kIChkb2NTdG9yZS5hY2Nlc3NLZXlzPy5yZWFkT25seT8gb3IgZG9jU3RvcmUuYWNjZXNzS2V5cz8ucmVhZFdyaXRlPylcblxuICAgICAgICBjbG9uZURvYyA9IChjYWxsYmFjaykgPT5cbiAgICAgICAgICBjcmVhdGVQYXJhbXMgPVxuICAgICAgICAgICAgc291cmNlOiBkb2NTdG9yZS5yZWNvcmRpZFxuICAgICAgICAgICAgYWNjZXNzS2V5OiBcIlJPOjoje2RvY1N0b3JlLmFjY2Vzc0tleXMucmVhZE9ubHl9XCJcbiAgICAgICAgICB7bWV0aG9kLCB1cmx9ID0gQGRvY1N0b3JlVXJsLnYyQ3JlYXRlRG9jdW1lbnQoY3JlYXRlUGFyYW1zKVxuICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiBtZXRob2RcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmRvbmUgKGNyZWF0ZVJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSKSA9PlxuICAgICAgICAgICAgbGFyYURhdGEgPSB7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbjogJ2Nsb25lJ1xuICAgICAgICAgICAgICBkb2N1bWVudElEOiBkb2NTdG9yZS5yZWNvcmRpZFxuICAgICAgICAgICAgICBkb2N1bWVudFVybDogdXJsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXJhRGF0YS5ydW5fcmVtb3RlX2VuZHBvaW50ID0gZXhpc3RpbmdSdW5TdGF0ZS5ydW5fcmVtb3RlX2VuZHBvaW50IGlmIGV4aXN0aW5nUnVuU3RhdGU/LnJ1bl9yZW1vdGVfZW5kcG9pbnQ/XG4gICAgICAgICAgICBAbG9nTGFyYURhdGEgbGFyYURhdGFcbiAgICAgICAgICAgIHByb2Nlc3NDcmVhdGVSZXNwb25zZSBjcmVhdGVSZXNwb25zZVxuICAgICAgICAgICAgY2FsbGJhY2sgbnVsbFxuICAgICAgICAgIC5mYWlsIChqcVhIUiwgc3RhdHVzLCBlcnJvcikgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrIFwiQ291bGQgbm90IG9wZW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudCBiZWNhdXNlIGFuIGVycm9yIG9jY3VycmVkIFtjcmVhdGVDb3B5XVwiXG5cbiAgICAgICAgc2V0Rm9sbG93ZXJzID0gKGVyciwgY2FsbGJhY2spID0+XG4gICAgICAgICAgaWYgZXJyXG4gICAgICAgICAgICBjYWxsYmFjayBlcnJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb2xsYWJvcmF0b3JQYXJhbXMgPSBfLmNsb25lRGVlcCBkb2NTdG9yZVxuICAgICAgICAgICAgY29sbGFib3JhdG9yUGFyYW1zLmNvbGxhYm9yYXRvciA9ICdmb2xsb3dlcidcbiAgICAgICAgICAgIHVwZGF0ZUludGVyYWN0aXZlUnVuU3RhdGVzIEBjb2xsYWJvcmF0b3JVcmxzLCBjb2xsYWJvcmF0b3JQYXJhbXMsIGNhbGxiYWNrXG5cbiAgICAgICAgYmVjb21lTGVhZGVyID0gKGVyciwgY2FsbGJhY2spIC0+XG4gICAgICAgICAgaWYgZXJyXG4gICAgICAgICAgICBjYWxsYmFjayBlcnJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2NTdG9yZS5jb2xsYWJvcmF0b3IgPSAnbGVhZGVyJ1xuICAgICAgICAgICAgdXBkYXRlSW50ZXJhY3RpdmVSdW5TdGF0ZXMgW3J1blN0YXRlVXJsXSwgZG9jU3RvcmUsIGNhbGxiYWNrXG5cbiAgICAgICAgcmVtb3ZlQ29sbGFib3JhdG9yID0gKGVyciwgY2FsbGJhY2spIC0+XG4gICAgICAgICAgaWYgZXJyXG4gICAgICAgICAgICBjYWxsYmFjayBlcnJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZG9jU3RvcmUuY29sbGFib3JhdG9yXG4gICAgICAgICAgICB1cGRhdGVJbnRlcmFjdGl2ZVJ1blN0YXRlcyBbcnVuU3RhdGVVcmxdLCBkb2NTdG9yZSwgY2FsbGJhY2tcblxuICAgICAgICBmaW5pc2hlZCA9IChlcnIpIC0+XG4gICAgICAgICAgaWYgZXJyXG4gICAgICAgICAgICBjYWxsYmFjayBlcnJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2FkUHJvdmlkZXJGaWxlIF8uY2xvbmVEZWVwKGRvY1N0b3JlKSwgY2FsbGJhY2tcblxuICAgICAgICAjIGlzIHRoaXMgYW4gZXhpc3RpbmcgY29sbGFib3JhdGVkIGRvY3VtZW50P1xuICAgICAgICBpZiBkb2NTdG9yZS5jb2xsYWJvcmF0b3JcbiAgICAgICAgICBpZiBkb2NTdG9yZS5jb2xsYWJvcmF0b3IgaXMgJ2xlYWRlcidcbiAgICAgICAgICAgIGlmIGhhdmVDb2xsYWJvcmF0b3JzXG4gICAgICAgICAgICAgICMgdGhlIGN1cnJlbnQgdXNlciBpcyBzdGlsbCB0aGUgbGVhZGVyIHNvIHVwZGF0ZSB0aGUgY29sbGFib3JhdG9yIHN0YXRlcyB0byBmb2xsb3cgdGhlIGxlYWRlciAoaW4gY2FzZSB0aGVyZSBhcmUgbmV3IGNvbGxhYm9yYXRvcnMpIGFuZCBsb2FkIHRoZSBleGlzdGluZyBkb2N1bWVudFxuICAgICAgICAgICAgICByZXR1cm4gc2V0Rm9sbG93ZXJzIG51bGwsIGZpbmlzaGVkXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICMgdGhlIGN1cnJlbnQgdXNlciBoYXMgZ29uZSBmcm9tIGxlYWRlciB0byBzb2xvIG1vZGUgc28gY2xvbmUgdGhlIGRvY3VtZW50IHRvIHByZXNlcnZlIHRoZSBjb2xsYWJvcmF0ZWQgZG9jdW1lbnQgYW5kIHVwZGF0ZSB0aGUgcnVuIHN0YXRlIHRvIHJlbW92ZSBjb2xsYWJvcmF0b3JcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lRG9jIChlcnIpIC0+IHJlbW92ZUNvbGxhYm9yYXRvcihlcnIsIGZpbmlzaGVkKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGhhdmVDb2xsYWJvcmF0b3JzXG4gICAgICAgICAgICAgICMgdGhlIGN1cnJlbnQgdXNlciBoYXMgc3dpdGNoZWQgZnJvbSBmb2xsb3dlciB0byBsZWFkZXIgc28gY2xvbmUgdGhlIGV4aXN0aW5nIGxlYWRlciBkb2N1bWVudCwgYmVjb21lIHRoZSBuZXcgbGVhZGVyIGFuZCB1cGRhdGUgdGhlIGZvbGxvd2VycyBhbmQgbG9hZCB0aGUgbmV3IGRvY3VtZW50XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZURvYyAoZXJyKSAtPiBiZWNvbWVMZWFkZXIoZXJyLCAoKGVycikgLT4gc2V0Rm9sbG93ZXJzKGVyciwgZmluaXNoZWQpKSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIyB0aGUgY3VycmVudCB1c2VyIGhhcyBzd2l0Y2hlZCBmcm9tIGZvbGxvd2VyIHRvIHNvbG8gbW9kZSBzbyBjbG9uZSB0aGUgZXhpc3RpbmcgbGVhZGVyIGRvY3VtZW50LCB1cGRhdGUgdGhlIHJ1biBzdGF0ZSB0byByZW1vdmUgdGhlIGNvbGxhYm9yYXRvciBhbmQgbG9hZCB0aGUgbmV3IGRvY3VtZW50XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZURvYyAoZXJyKSAtPiByZW1vdmVDb2xsYWJvcmF0b3IoZXJyLCBmaW5pc2hlZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGhhdmVDb2xsYWJvcmF0b3JzXG4gICAgICAgICAgICAjIHRoZSBjdXJyZW50IHVzZXIgaGFzIHN3aXRjaGVkIGZyb20gc29sbyBtb2RlIHRvIGxlYWRlciBzbyB1cGRhdGUgYm90aCB0aGUgdXNlcidzIGFuZCB0aGUgY29sbGFib3JhdG9ycyBydW4gc3RhdGVzIHVzaW5nIHRoZSBleGlzdGluZyBkb2N1bWVudFxuICAgICAgICAgICAgcmV0dXJuIGJlY29tZUxlYWRlciBudWxsLCAoZXJyKSAtPiBzZXRGb2xsb3dlcnMoZXJyLCBmaW5pc2hlZClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIHRoZSBjdXJyZW50IHVzZXIgaGFzIG9wZW5lZCBhbiBleGlzdGluZyBzb2xvIG1vZGUgZmlsZSBzbyBqdXN0IG9wZW4gaXRcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hlZCgpXG5cbiAgICAgICMgd2UgbmVlZCBhIHNvdXJjZUlEIHRvIGJlIGFibGUgdG8gY3JlYXRlIGEgY29weVxuICAgICAgaWYgbm90IHNvdXJjZUlEXG4gICAgICAgIGNhbGxiYWNrIFwiQ291bGQgbm90IG9wZW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudCBiZWNhdXNlIGFuIGVycm9yIG9jY3VycmVkIFtub1NvdXJjZV1cIlxuICAgICAgICByZXR1cm5cblxuICAgICAgIyAoMmIpIHJlcXVlc3QgYSBjb3B5IG9mIHRoZSBzaGFyZWQgZG9jdW1lbnRcbiAgICAgIGNyZWF0ZVBhcmFtcyA9IHsgc291cmNlOiBzb3VyY2VJRCB9XG4gICAgICAjIGFkZCBhIGtleSBpZiBnaXZlbiAoZm9yIGNvcHlpbmcgbGlua2VkIHJ1biBzdGF0ZXMpXG4gICAgICBpZiByZWFkT25seUtleVxuICAgICAgICBjcmVhdGVQYXJhbXMuYWNjZXNzS2V5ID0gXCJSTzo6I3tyZWFkT25seUtleX1cIlxuICAgICAge21ldGhvZCwgdXJsfSA9IEBkb2NTdG9yZVVybC52MkNyZWF0ZURvY3VtZW50KGNyZWF0ZVBhcmFtcylcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHR5cGU6IG1ldGhvZFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgfSlcbiAgICAgIC5kb25lIChjcmVhdGVSZXNwb25zZSwgc3RhdHVzLCBqcVhIUikgPT5cblxuICAgICAgICBwcm9jZXNzQ3JlYXRlUmVzcG9uc2UgY3JlYXRlUmVzcG9uc2VcbiAgICAgICAgaWYgaGF2ZUNvbGxhYm9yYXRvcnNcbiAgICAgICAgICBkb2NTdG9yZS5jb2xsYWJvcmF0b3IgPSAnbGVhZGVyJ1xuXG4gICAgICAgIHByb3ZpZGVyRGF0YSA9IF8ubWVyZ2Uoe30sIGRvY1N0b3JlLCB7IHVybDogcnVuU3RhdGVVcmwgfSlcbiAgICAgICAgdXBkYXRlRmluaXNoZWQgPSAtPiBsb2FkUHJvdmlkZXJGaWxlIHByb3ZpZGVyRGF0YSwgY2FsbGJhY2tcblxuICAgICAgICAjIHVwZGF0ZSB0aGUgb3duZXJzIGludGVyYWN0aXZlIHJ1biBzdGF0ZVxuICAgICAgICB1cGRhdGVJbnRlcmFjdGl2ZVJ1blN0YXRlcyBbcnVuU3RhdGVVcmxdLCBkb2NTdG9yZSwgKGVycikgPT5cbiAgICAgICAgICBpZiBlcnJcbiAgICAgICAgICAgIGNhbGxiYWNrIGVyclxuICAgICAgICAgIGVsc2UgaWYgaGF2ZUNvbGxhYm9yYXRvcnNcbiAgICAgICAgICAgIGRvY1N0b3JlLmNvbGxhYm9yYXRvciA9ICdmb2xsb3dlcidcbiAgICAgICAgICAgIHVwZGF0ZUludGVyYWN0aXZlUnVuU3RhdGVzIEBjb2xsYWJvcmF0b3JVcmxzLCBkb2NTdG9yZSwgKGVycikgLT5cbiAgICAgICAgICAgICAgaWYgZXJyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgZXJyXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB1cGRhdGVGaW5pc2hlZCgpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXBkYXRlRmluaXNoZWQoKVxuXG4gICAgICAuZmFpbCAoanFYSFIsIHN0YXR1cywgZXJyb3IpIC0+XG4gICAgICAgIGNhbGxiYWNrIFwiQ291bGQgbm90IG9wZW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudCBiZWNhdXNlIGFuIGVycm9yIG9jY3VycmVkIFtjcmVhdGVDb3B5XVwiXG5cbiAgICAjXG4gICAgIyBXZSBoYXZlIGEgcnVuIHN0YXRlIFVSTCBhbmQgYSBzb3VyY2UgZG9jdW1lbnQuIFdlIG11c3QgY29weSB0aGUgc291cmNlXG4gICAgIyBkb2N1bWVudCBhbmQgdXBkYXRlIHRoZSBydW4gc3RhdGUgYmVmb3JlIG9wZW5pbmcgdGhlIGNvcGllZCBkb2N1bWVudC5cbiAgICAjXG4gICAgaWYgb3BlblNhdmVkUGFyYW1zIGFuZCBvcGVuU2F2ZWRQYXJhbXMudXJsXG4gICAgICAjICgxKSByZXF1ZXN0IHRoZSBpbnRlcmFjdGl2ZSBydW4gc3RhdGVcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHR5cGU6ICdHRVQnXG4gICAgICAgIHVybDogb3BlblNhdmVkUGFyYW1zLnVybFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIHhockZpZWxkczpcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWVcbiAgICAgIH0pXG4gICAgICAuZG9uZSAoZGF0YSwgc3RhdHVzLCBqcVhIUikgPT5cbiAgICAgICAgbGFyYURhdGEgPSB7XG4gICAgICAgICAgb3BlcmF0aW9uOiAnb3BlbidcbiAgICAgICAgICBydW5TdGF0ZVVybDogb3BlblNhdmVkUGFyYW1zLnVybFxuICAgICAgICAgIGRvY3VtZW50SUQ6IG9wZW5TYXZlZFBhcmFtcy5zb3VyY2VcbiAgICAgICAgfVxuICAgICAgICBsYXJhRGF0YS5ydW5fcmVtb3RlX2VuZHBvaW50ID0gZGF0YS5ydW5fcmVtb3RlX2VuZHBvaW50IGlmIGRhdGE/LnJ1bl9yZW1vdGVfZW5kcG9pbnQ/XG4gICAgICAgIEBsb2dMYXJhRGF0YSBsYXJhRGF0YVxuICAgICAgICBwcm9jZXNzSW5pdGlhbFJ1blN0YXRlIG9wZW5TYXZlZFBhcmFtcy51cmwsIG9wZW5TYXZlZFBhcmFtcy5zb3VyY2UsIG9wZW5TYXZlZFBhcmFtcy5yZWFkT25seUtleSwgZGF0YVxuICAgICAgLmZhaWwgKGpxWEhSLCBzdGF0dXMsIGVycm9yKSAtPlxuICAgICAgICBjYWxsYmFjayBcIkNvdWxkIG5vdCBvcGVuIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQgYmVjYXVzZSBhbiBlcnJvciBvY2N1cnJlZCBbZ2V0U3RhdGVdXCJcblxuICAgICAgcmV0dXJuXG5cbiAgICBjYWxsYmFjayBcIkNhbm5vdCBvcGVuIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnRcIlxuXG4gIGdldE9wZW5TYXZlZFBhcmFtczogKG1ldGFkYXRhKSAtPlxuICAgIHBhcmFtcyA9IGlmIEBvcGVuU2F2ZWRQYXJhbXNcbiAgICAgIEBvcGVuU2F2ZWRQYXJhbXNcbiAgICBlbHNlIGlmIEBsYXJhUGFyYW1zXG4gICAgICB1cmw6IEBsYXJhUGFyYW1zLnVybFxuICAgICAgc291cmNlOiBAbGFyYVBhcmFtcy5zb3VyY2VcbiAgICBlbHNlXG4gICAgICBtZXRhZGF0YVxuICAgIEBlbmNvZGVQYXJhbXMgcGFyYW1zXG5cbm1vZHVsZS5leHBvcnRzID0gTGFyYVByb3ZpZGVyXG4iLCJ7ZGl2LCBpbnB1dCwgYnV0dG9ufSA9IFJlYWN0LkRPTVxudHIgPSByZXF1aXJlICcuLi91dGlscy90cmFuc2xhdGUnXG5cblByb3ZpZGVySW50ZXJmYWNlID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuUHJvdmlkZXJJbnRlcmZhY2VcbmNsb3VkQ29udGVudEZhY3RvcnkgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5jbG91ZENvbnRlbnRGYWN0b3J5XG5Mb2NhbEZpbGVMaXN0VGFiID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuLi92aWV3cy9sb2NhbC1maWxlLXRhYi1saXN0LXZpZXcnXG5Mb2NhbEZpbGVTYXZlVGFiID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuLi92aWV3cy9sb2NhbC1maWxlLXRhYi1zYXZlLXZpZXcnXG5cbmNsYXNzIExvY2FsRmlsZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2VcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgc3VwZXJcbiAgICAgIG5hbWU6IExvY2FsRmlsZVByb3ZpZGVyLk5hbWVcbiAgICAgIGRpc3BsYXlOYW1lOiBAb3B0aW9ucy5kaXNwbGF5TmFtZSBvciAodHIgJ35QUk9WSURFUi5MT0NBTF9GSUxFJylcbiAgICAgIGNhcGFiaWxpdGllczpcbiAgICAgICAgc2F2ZTogdHJ1ZVxuICAgICAgICByZXNhdmU6IGZhbHNlXG4gICAgICAgIGV4cG9ydDogdHJ1ZVxuICAgICAgICBsb2FkOiB0cnVlXG4gICAgICAgIGxpc3Q6IHRydWVcbiAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgICByZW5hbWU6IGZhbHNlXG4gICAgICAgIGNsb3NlOiBmYWxzZVxuXG4gIEBOYW1lOiAnbG9jYWxGaWxlJ1xuXG4gIGZpbHRlclRhYkNvbXBvbmVudDogKGNhcGFiaWxpdHksIGRlZmF1bHRDb21wb25lbnQpIC0+XG4gICAgaWYgY2FwYWJpbGl0eSBpcyAnbGlzdCdcbiAgICAgIExvY2FsRmlsZUxpc3RUYWJcbiAgICBlbHNlIGlmIChjYXBhYmlsaXR5IGlzICdzYXZlJykgb3IgKGNhcGFiaWxpdHkgaXMgJ2V4cG9ydCcpXG4gICAgICBMb2NhbEZpbGVTYXZlVGFiXG4gICAgZWxzZVxuICAgICAgZGVmYXVsdENvbXBvbmVudFxuXG4gIGxpc3Q6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgIyBub3QgcmVhbGx5IGltcGxlbWVudGVkIC0gd2UgZmxhZyBpdCBhcyBpbXBsZW1lbnRlZCBzbyB3ZSBzaG93IGluIHRoZSBsaXN0IGRpYWxvZ1xuXG4gIHNhdmU6IChjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgIyBub3QgcmVhbGx5IGltcGxlbWVudGVkIC0gd2UgZmxhZyBpdCBhcyBpbXBsZW1lbnRlZCBzbyB3ZSBjYW4gYWRkIHRoZSBkb3dubG9hZCBidXR0b24gdG8gdGhlIHNhdmUgZGlhbG9nXG4gICAgY2FsbGJhY2s/IG51bGxcblxuICBsb2FkOiAobWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIub25sb2FkID0gKGxvYWRlZCkgLT5cbiAgICAgIGNhbGxiYWNrIG51bGwsIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGxvYWRlZC50YXJnZXQucmVzdWx0XG4gICAgcmVhZGVyLnJlYWRBc1RleHQgbWV0YWRhdGEucHJvdmlkZXJEYXRhLmZpbGVcblxuICBjYW5PcGVuU2F2ZWQ6IC0+XG4gICAgIyB0aGlzIHByZXZlbnRzIHRoZSBoYXNoIHRvIGJlIHVwZGF0ZWRcbiAgICBmYWxzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRmlsZVByb3ZpZGVyXG4iLCJ0ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxuUHJvdmlkZXJJbnRlcmZhY2UgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5Qcm92aWRlckludGVyZmFjZVxuY2xvdWRDb250ZW50RmFjdG9yeSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLmNsb3VkQ29udGVudEZhY3RvcnlcbkNsb3VkTWV0YWRhdGEgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5DbG91ZE1ldGFkYXRhXG5cbmNsYXNzIExvY2FsU3RvcmFnZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2VcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgc3VwZXJcbiAgICAgIG5hbWU6IExvY2FsU3RvcmFnZVByb3ZpZGVyLk5hbWVcbiAgICAgIGRpc3BsYXlOYW1lOiBAb3B0aW9ucy5kaXNwbGF5TmFtZSBvciAodHIgJ35QUk9WSURFUi5MT0NBTF9TVE9SQUdFJylcbiAgICAgIHVybERpc3BsYXlOYW1lOiBAb3B0aW9ucy51cmxEaXNwbGF5TmFtZVxuICAgICAgY2FwYWJpbGl0aWVzOlxuICAgICAgICBzYXZlOiB0cnVlXG4gICAgICAgIHJlc2F2ZTogdHJ1ZVxuICAgICAgICBleHBvcnQ6IHRydWVcbiAgICAgICAgbG9hZDogdHJ1ZVxuICAgICAgICBsaXN0OiB0cnVlXG4gICAgICAgIHJlbW92ZTogdHJ1ZVxuICAgICAgICByZW5hbWU6IHRydWVcbiAgICAgICAgY2xvc2U6IGZhbHNlXG5cbiAgQE5hbWU6ICdsb2NhbFN0b3JhZ2UnXG4gIEBBdmFpbGFibGU6IC0+XG4gICAgcmVzdWx0ID0gdHJ5XG4gICAgICB0ZXN0ID0gJ0xvY2FsU3RvcmFnZVByb3ZpZGVyOjphdXRoJ1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdClcbiAgICAgIHRydWVcbiAgICBjYXRjaFxuICAgICAgZmFsc2VcblxuICBzYXZlOiAoY29udGVudCwgbWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIHRyeVxuICAgICAgZmlsZUtleSA9IEBfZ2V0S2V5KG1ldGFkYXRhLmZpbGVuYW1lKVxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtIGZpbGVLZXksIChjb250ZW50LmdldENvbnRlbnRBc0pTT04/KCkgb3IgY29udGVudClcbiAgICAgIGNhbGxiYWNrPyBudWxsXG4gICAgY2F0Y2ggZVxuICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gc2F2ZTogI3tlLm1lc3NhZ2V9XCJcblxuICBsb2FkOiAobWV0YWRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIHRyeVxuICAgICAgY29udGVudCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSBAX2dldEtleSBtZXRhZGF0YS5maWxlbmFtZVxuICAgICAgY2FsbGJhY2sgbnVsbCwgY2xvdWRDb250ZW50RmFjdG9yeS5jcmVhdGVFbnZlbG9wZWRDbG91ZENvbnRlbnQgY29udGVudFxuICAgIGNhdGNoIGVcbiAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIGxvYWQgJyN7bWV0YWRhdGEubmFtZX0nOiAje2UubWVzc2FnZX1cIlxuXG4gIGxpc3Q6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgbGlzdCA9IFtdXG4gICAgcHJlZml4ID0gQF9nZXRLZXkgKG1ldGFkYXRhPy5wYXRoKCkgb3IgW10pLmpvaW4gJy8nXG4gICAgZm9yIG93biBrZXkgb2Ygd2luZG93LmxvY2FsU3RvcmFnZVxuICAgICAgaWYga2V5LnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSBpcyBwcmVmaXhcbiAgICAgICAgW2ZpbGVuYW1lLCByZW1haW5kZXIuLi5dID0ga2V5LnN1YnN0cihwcmVmaXgubGVuZ3RoKS5zcGxpdCgnLycpXG4gICAgICAgIG5hbWUgPSBrZXkuc3Vic3RyKHByZWZpeC5sZW5ndGgpXG4gICAgICAgIGlmIEBtYXRjaGVzRXh0ZW5zaW9uIG5hbWVcbiAgICAgICAgICBsaXN0LnB1c2ggbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIHR5cGU6IGlmIHJlbWFpbmRlci5sZW5ndGggPiAwIHRoZW4gQ2xvdWRNZXRhZGF0YS5Gb2xkZXIgZWxzZSBDbG91ZE1ldGFkYXRhLkZpbGVcbiAgICAgICAgICAgIHBhcmVudDogbWV0YWRhdGFcbiAgICAgICAgICAgIHByb3ZpZGVyOiBAXG4gICAgY2FsbGJhY2sgbnVsbCwgbGlzdFxuXG4gIHJlbW92ZTogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICB0cnlcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSBAX2dldEtleShtZXRhZGF0YS5maWxlbmFtZSlcbiAgICAgIGNhbGxiYWNrPyBudWxsXG4gICAgY2F0Y2hcbiAgICAgIGNhbGxiYWNrPyAnVW5hYmxlIHRvIGRlbGV0ZSdcblxuICByZW5hbWU6IChtZXRhZGF0YSwgbmV3TmFtZSwgY2FsbGJhY2spIC0+XG4gICAgdHJ5XG4gICAgICBjb250ZW50ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtIEBfZ2V0S2V5IG1ldGFkYXRhLmZpbGVuYW1lXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0gQF9nZXRLZXkoQ2xvdWRNZXRhZGF0YS53aXRoRXh0ZW5zaW9uIG5ld05hbWUpLCBjb250ZW50XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0gQF9nZXRLZXkobWV0YWRhdGEuZmlsZW5hbWUpXG4gICAgICBtZXRhZGF0YS5yZW5hbWUgbmV3TmFtZVxuICAgICAgY2FsbGJhY2sgbnVsbCwgbWV0YWRhdGFcbiAgICBjYXRjaFxuICAgICAgY2FsbGJhY2s/ICdVbmFibGUgdG8gcmVuYW1lJ1xuXG4gIGNhbk9wZW5TYXZlZDogLT4gdHJ1ZVxuXG4gIG9wZW5TYXZlZDogKG9wZW5TYXZlZFBhcmFtcywgY2FsbGJhY2spIC0+XG4gICAgbWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgbmFtZTogb3BlblNhdmVkUGFyYW1zXG4gICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkZpbGVcbiAgICAgIHBhcmVudDogbnVsbFxuICAgICAgcHJvdmlkZXI6IEBcbiAgICBAbG9hZCBtZXRhZGF0YSwgKGVyciwgY29udGVudCkgLT5cbiAgICAgIGNhbGxiYWNrIGVyciwgY29udGVudCwgbWV0YWRhdGFcblxuICBnZXRPcGVuU2F2ZWRQYXJhbXM6IChtZXRhZGF0YSkgLT5cbiAgICBtZXRhZGF0YS5uYW1lXG5cbiAgX2dldEtleTogKG5hbWUgPSAnJykgLT5cbiAgICBcImNmbTo6I3tuYW1lLnJlcGxhY2UgL1xcdC9nLCAnICd9XCJcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFN0b3JhZ2VQcm92aWRlclxuIiwiI1xuIyBUaGlzIHV0aWxpdHkgY2xhc3Mgc2ltcGxpZmllcyB3b3JraW5nIHdpdGggZG9jdW1lbnQgc3RvcmUgVVJMc1xuI1xuXG5qaWZmID0gcmVxdWlyZSAnamlmZidcblxuY2xhc3MgUGF0Y2hhYmxlQ29udGVudFxuXG4gIGNvbnN0cnVjdG9yOiAoQHBhdGNoT2JqZWN0SGFzaCwgQHNhdmVkQ29udGVudCkgLT5cblxuICBjcmVhdGVQYXRjaDogKGNvbnRlbnQsIGNhblBhdGNoKSAtPlxuICAgIGRpZmYgPSBpZiBjYW5QYXRjaCBhbmQgQHNhdmVkQ29udGVudCB0aGVuIEBfY3JlYXRlRGlmZiBAc2F2ZWRDb250ZW50LCBjb250ZW50XG4gICAgcmVzdWx0ID1cbiAgICAgIHNob3VsZFBhdGNoOiBmYWxzZVxuICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgY29udGVudEpzb246IEpTT04uc3RyaW5naWZ5IGNvbnRlbnRcbiAgICAgIGRpZmZMZW5ndGg6IGRpZmYgYW5kIGRpZmYubGVuZ3RoXG4gICAgICBkaWZmSnNvbjogZGlmZiBhbmQgSlNPTi5zdHJpbmdpZnkgZGlmZlxuXG4gICAgIyBvbmx5IHBhdGNoIGlmIHRoZSBkaWZmIGlzIHNtYWxsZXIgdGhhbiBzYXZpbmcgdGhlIGVudGlyZSBmaWxlXG4gICAgIyBlLmcuIHdoZW4gbGFyZ2UgbnVtYmVycyBvZiBjYXNlcyBhcmUgZGVsZXRlZCB0aGUgZGlmZiBjYW4gYmUgbGFyZ2VyXG4gICAgaWYgY2FuUGF0Y2ggYW5kIHJlc3VsdC5kaWZmSnNvbj8gYW5kIHJlc3VsdC5kaWZmSnNvbi5sZW5ndGggPCByZXN1bHQuY29udGVudEpzb24ubGVuZ3RoXG4gICAgICByZXN1bHQuc2hvdWxkUGF0Y2ggPSB0cnVlXG4gICAgICByZXN1bHQuc2VuZENvbnRlbnQgPSByZXN1bHQuZGlmZkpzb25cbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uLXBhdGNoK2pzb24nXG4gICAgZWxzZVxuICAgICAgcmVzdWx0LnNlbmRDb250ZW50ID0gcmVzdWx0LmNvbnRlbnRKc29uXG5cbiAgICByZXN1bHRcblxuICB1cGRhdGVDb250ZW50OiAoY29udGVudCkgLT5cbiAgICBAc2F2ZWRDb250ZW50ID0gY29udGVudFxuXG4gIF9jcmVhdGVEaWZmOiAob2JqMSwgb2JqMikgLT5cbiAgICB0cnlcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGhhc2g6IEBwYXRjaE9iamVjdEhhc2ggaWYgdHlwZW9mIEBwYXRjaE9iamVjdEhhc2ggaXMgXCJmdW5jdGlvblwiXG4gICAgICAgIGludmVydGlibGU6IGZhbHNlICMgc21hbGxlciBwYXRjaGVzIGFyZSB3b3J0aCBtb3JlIHRoYW4gaW52ZXJ0aWJpbGl0eVxuICAgICAgfVxuICAgICAgIyBjbGVhbiBvYmplY3RzIGJlZm9yZSBkaWZmaW5nXG4gICAgICBjbGVhbmVkT2JqMSA9IEpTT04ucGFyc2UgSlNPTi5zdHJpbmdpZnkgb2JqMVxuICAgICAgY2xlYW5lZE9iajIgPSBKU09OLnBhcnNlIEpTT04uc3RyaW5naWZ5IG9iajJcbiAgICAgIGRpZmYgPSBqaWZmLmRpZmYoY2xlYW5lZE9iajEsIGNsZWFuZWRPYmoyLCBvcHRzKVxuICAgICAgcmV0dXJuIGRpZmZcbiAgICBjYXRjaFxuICAgICAgcmV0dXJuIG51bGxcbiAgICBcbm1vZHVsZS5leHBvcnRzID0gUGF0Y2hhYmxlQ29udGVudFxuIiwiUHJvdmlkZXJJbnRlcmZhY2UgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5Qcm92aWRlckludGVyZmFjZVxuZ2V0UXVlcnlQYXJhbSA9IHJlcXVpcmUgJy4uL3V0aWxzL2dldC1xdWVyeS1wYXJhbSdcblxuY2xhc3MgUG9zdE1lc3NhZ2VQcm92aWRlciBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlXG5cbiAgQE5hbWU6ICdwb3N0TWVzc2FnZSdcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgc3VwZXJcbiAgICAgIGNhcGFiaWxpdGllczpcbiAgICAgICAgc2F2ZTogZmFsc2VcbiAgICAgICAgcmVzYXZlOiBmYWxzZVxuICAgICAgICBleHBvcnQ6IGlmIGdldFF1ZXJ5UGFyYW0gXCJzYXZlU2Vjb25kYXJ5RmlsZVZpYVBvc3RNZXNzYWdlXCIgdGhlbiAnYXV0bycgZWxzZSBmYWxzZVxuICAgICAgICBsb2FkOiBmYWxzZVxuICAgICAgICBsaXN0OiBmYWxzZVxuICAgICAgICByZW1vdmU6IGZhbHNlXG4gICAgICAgIHJlbmFtZTogZmFsc2VcbiAgICAgICAgY2xvc2U6IGZhbHNlXG5cbiAgY2FuT3BlblNhdmVkOiAtPiBmYWxzZVxuXG4gIHNhdmVBc0V4cG9ydDogKGNvbnRlbnQsIG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgIGFjdGlvbjogXCJzYXZlU2Vjb25kYXJ5RmlsZVwiLFxuICAgICAgZXh0ZW5zaW9uOiBtZXRhZGF0YS5leHRlbnNpb24sXG4gICAgICBtaW1lVHlwZTogbWV0YWRhdGEubWltZVR5cGUsXG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSwgXCIqXCIpXG4gICAgY2FsbGJhY2s/IG51bGxcblxubW9kdWxlLmV4cG9ydHMgPSBQb3N0TWVzc2FnZVByb3ZpZGVyXG4iLCJ7ZGl2fSA9IFJlYWN0LkRPTVxuXG5pc1N0cmluZyA9IHJlcXVpcmUgJy4uL3V0aWxzL2lzLXN0cmluZydcblxuY2xhc3MgQ2xvdWRGaWxlXG4gIGNvbnN0cnVjdG9yOiAob3B0aW9ucykgLT5cbiAgICB7QGNvbnRlbnQsIEBtZXRhZGF0YX0gPSBvcHRpb25zXG5cbmNsYXNzIENsb3VkTWV0YWRhdGFcbiAgY29uc3RydWN0b3I6IChvcHRpb25zKSAtPlxuICAgIHtAbmFtZSwgQHR5cGUsIEBkZXNjcmlwdGlvbiwgQGNvbnRlbnQsIEB1cmwsIEBwcm92aWRlciA9IG51bGwsIEBwYXJlbnQgPSBudWxsLCBAcHJvdmlkZXJEYXRhPXt9LCBAb3ZlcndyaXRhYmxlLCBAc2hhcmVkQ29udGVudElkLCBAc2hhcmVkQ29udGVudFNlY3JldEtleSwgQG1pbWVUeXBlfSA9IG9wdGlvbnNcbiAgICBAX3VwZGF0ZUZpbGVuYW1lKClcblxuICBARm9sZGVyOiAnZm9sZGVyJ1xuICBARmlsZTogJ2ZpbGUnXG4gIEBMYWJlbDogJ2xhYmVsJ1xuXG4gIEBFeHRlbnNpb246IG51bGxcblxuICBAbWFwVHlwZVRvQ2xvdWRNZXRhZGF0YVR5cGU6IChpVHlwZSkgLT5cbiAgICAjIGZvciBub3cgbWFwcGluZyBpcyAxLXRvLTEgZGVmYXVsdGluZyB0byAnZmlsZSdcbiAgICBpVHlwZSBvciBARmlsZVxuXG4gIEB3aXRoRXh0ZW5zaW9uOiAobmFtZSwgZGVmYXVsdEV4dGVuc2lvbiwga2VlcE9yaWdpbmFsRXh0ZW5zaW9uKSAtPlxuICAgIGlmIGtlZXBPcmlnaW5hbEV4dGVuc2lvbiBhbmQgfm5hbWUuaW5kZXhPZihcIi5cIilcbiAgICAgIHJldHVybiBuYW1lXG4gICAgZXh0ZW5zaW9uID0gQ2xvdWRNZXRhZGF0YS5FeHRlbnNpb24gb3IgZGVmYXVsdEV4dGVuc2lvblxuICAgIGlmIGV4dGVuc2lvblxuICAgICAgQG5ld0V4dGVuc2lvbiBuYW1lLCBleHRlbnNpb25cbiAgICBlbHNlXG4gICAgICBuYW1lXG5cbiAgQG5ld0V4dGVuc2lvbjogKG5hbWUsIGV4dGVuc2lvbikgLT5cbiAgICAjIGRyb3AgbGFzdCBleHRlbnNpb24sIGlmIHRoZXJlIGlzIG9uZVxuICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIG9yIG5hbWVcbiAgICBuYW1lICsgXCIuXCIgKyBleHRlbnNpb25cblxuICBwYXRoOiAtPlxuICAgIF9wYXRoID0gW11cbiAgICBwYXJlbnQgPSBAcGFyZW50XG4gICAgd2hpbGUgcGFyZW50IGlzbnQgbnVsbFxuICAgICAgX3BhdGgudW5zaGlmdCBwYXJlbnRcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRcbiAgICBfcGF0aFxuXG4gIHJlbmFtZTogKG5ld05hbWUpIC0+XG4gICAgQG5hbWUgPSBuZXdOYW1lXG4gICAgQF91cGRhdGVGaWxlbmFtZSgpXG5cbiAgX3VwZGF0ZUZpbGVuYW1lOiAtPlxuICAgIEBmaWxlbmFtZSA9IEBuYW1lXG4gICAgaWYgQG5hbWU/LnN1YnN0cj8gYW5kIENsb3VkTWV0YWRhdGEuRXh0ZW5zaW9uPyBhbmQgQHR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5GaWxlXG4gICAgICBleHRMZW4gPSBDbG91ZE1ldGFkYXRhLkV4dGVuc2lvbi5sZW5ndGhcbiAgICAgIEBuYW1lID0gQG5hbWUuc3Vic3RyKDAsIEBuYW1lLmxlbmd0aCAtIChleHRMZW4rMSkpIGlmIEBuYW1lLnN1YnN0cigtZXh0TGVuKzEpIGlzIFwiLiN7Q2xvdWRNZXRhZGF0YS5FeHRlbnNpb259XCJcbiAgICAgIEBmaWxlbmFtZSA9IENsb3VkTWV0YWRhdGEud2l0aEV4dGVuc2lvbiBAbmFtZSwgbnVsbCwgdHJ1ZVxuXG4jIHNpbmdsZXRvbiB0aGF0IGNhbiBjcmVhdGUgQ2xvdWRDb250ZW50IHdyYXBwZWQgd2l0aCBnbG9iYWwgb3B0aW9uc1xuY2xhc3MgQ2xvdWRDb250ZW50RmFjdG9yeVxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAZW52ZWxvcGVNZXRhZGF0YSA9IHt9XG5cbiAgIyBzZXQgaW5pdGlhbCBlbnZlbG9wZU1ldGFkYXRhIG9yIHVwZGF0ZSBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgc2V0RW52ZWxvcGVNZXRhZGF0YTogKGVudmVsb3BlTWV0YWRhdGEpIC0+XG4gICAgZm9yIGtleSBvZiBlbnZlbG9wZU1ldGFkYXRhXG4gICAgICBAZW52ZWxvcGVNZXRhZGF0YVtrZXldID0gZW52ZWxvcGVNZXRhZGF0YVtrZXldXG5cbiAgIyByZXR1cm5zIG5ldyBDbG91ZENvbnRlbnQgY29udGFpbmluZyBlbnZlbG9wZWQgZGF0YVxuICBjcmVhdGVFbnZlbG9wZWRDbG91ZENvbnRlbnQ6IChjb250ZW50KSAtPlxuICAgIG5ldyBDbG91ZENvbnRlbnQgKEBlbnZlbG9wQ29udGVudCBjb250ZW50KSwgKEBfaWRlbnRpZnlDb250ZW50Rm9ybWF0IGNvbnRlbnQpXG5cbiAgIyBlbnZlbG9wcyBjb250ZW50IHdpdGggbWV0YWRhdGEsIHJldHVybnMgYW4gb2JqZWN0LlxuICAjIElmIGNvbnRlbnQgd2FzIGFscmVhZHkgYW4gb2JqZWN0IChPYmplY3Qgb3IgSlNPTikgd2l0aCBtZXRhZGF0YSxcbiAgIyBhbnkgZXhpc3RpbmcgbWV0YWRhdGEgd2lsbCBiZSByZXRhaW5lZC5cbiAgIyBOb3RlOiBjYWxsaW5nIGBlbnZlbG9wQ29udGVudGAgbWF5IGJlIHNhZmVseSBjYWxsZWQgb24gc29tZXRoaW5nIHRoYXRcbiAgIyBoYXMgYWxyZWFkeSBoYWQgYGVudmVsb3BDb250ZW50YCBjYWxsZWQgb24gaXQsIGFuZCB3aWxsIGJlIGEgbm8tb3AuXG4gIGVudmVsb3BDb250ZW50OiAoY29udGVudCkgLT5cbiAgICBlbnZlbG9wZWRDbG91ZENvbnRlbnQgPSBAX3dyYXBJZk5lZWRlZCBjb250ZW50XG4gICAgZm9yIGtleSBvZiBAZW52ZWxvcGVNZXRhZGF0YVxuICAgICAgZW52ZWxvcGVkQ2xvdWRDb250ZW50W2tleV0gPz0gQGVudmVsb3BlTWV0YWRhdGFba2V5XVxuICAgIHJldHVybiBlbnZlbG9wZWRDbG91ZENvbnRlbnRcblxuICBfaWRlbnRpZnlDb250ZW50Rm9ybWF0OiAoY29udGVudCkgLT5cbiAgICByZXR1cm4gaWYgbm90IGNvbnRlbnQ/XG4gICAgcmVzdWx0ID0geyBpc0NmbVdyYXBwZWQ6IGZhbHNlLCBpc1ByZUNmbUZvcm1hdDogZmFsc2UgfVxuICAgIGlmIGlzU3RyaW5nIGNvbnRlbnRcbiAgICAgIHRyeSBjb250ZW50ID0gSlNPTi5wYXJzZSBjb250ZW50XG4gICAgIyBDdXJyZW50bHksIHdlIGFzc3VtZSAnbWV0YWRhdGEnIGlzIHRvcC1sZXZlbCBwcm9wZXJ0eSBpblxuICAgICMgbm9uLUNGTS13cmFwcGVkIGRvY3VtZW50cy4gQ291bGQgcHV0IGluIGEgY2xpZW50IGNhbGxiYWNrXG4gICAgIyB0aGF0IHdvdWxkIGlkZW50aWZ5IHdoZXRoZXIgdGhlIGRvY3VtZW50IHJlcXVpcmVkXG4gICAgIyBjb252ZXJzaW9uIHRvIGVsaW1pbmF0ZSB0aGlzIGFzc3VtcHRpb24gZnJvbSB0aGUgQ0ZNLlxuICAgIGlmIGNvbnRlbnQubWV0YWRhdGFcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICBpZiBjb250ZW50LmNmbVZlcnNpb24/IG9yIGNvbnRlbnQuY29udGVudD9cbiAgICAgIHJlc3VsdC5pc0NmbVdyYXBwZWQgPSB0cnVlXG4gICAgZWxzZVxuICAgICAgcmVzdWx0LmlzUHJlQ2ZtRm9ybWF0ID0gdHJ1ZVxuICAgIHJlc3VsdFxuXG4gICMgZW52ZWxvcHMgY29udGVudCBpbiB7Y29udGVudDogY29udGVudH0gaWYgbmVlZGVkLCByZXR1cm5zIGFuIG9iamVjdFxuICBfd3JhcElmTmVlZGVkOiAoY29udGVudCkgLT5cbiAgICBpZiBpc1N0cmluZyBjb250ZW50XG4gICAgICB0cnkgY29udGVudCA9IEpTT04ucGFyc2UgY29udGVudFxuICAgIGlmIGNvbnRlbnQuY29udGVudD9cbiAgICAgIHJldHVybiBjb250ZW50XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtjb250ZW50fVxuXG5jbGFzcyBDbG91ZENvbnRlbnRcbiAgIyB3cmFwcGluZyBkZWZhdWx0cyB0byB0cnVlIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBjbGllbnQgdmlhIGFwcE9wdGlvbnNcbiAgQHdyYXBGaWxlQ29udGVudDogdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yOiAoQF8gPSB7fSwgQF9jb250ZW50Rm9ybWF0KSAtPlxuXG4gICMgZ2V0Q29udGVudCBhbmQgZ2V0Q29udGVudEFzSlNPTiByZXR1cm4gdGhlIGZpbGUgY29udGVudCBhcyBzdG9yZWQgb24gZGlza1xuICBnZXRDb250ZW50OiAtPlxuICAgIGlmIENsb3VkQ29udGVudC53cmFwRmlsZUNvbnRlbnQgdGhlbiBAXyBlbHNlIEBfLmNvbnRlbnRcbiAgZ2V0Q29udGVudEFzSlNPTjogLT5cbiAgICBKU09OLnN0cmluZ2lmeSBpZiBDbG91ZENvbnRlbnQud3JhcEZpbGVDb250ZW50IHRoZW4gQF8gZWxzZSBAXy5jb250ZW50XG5cbiAgIyByZXR1cm5zIHRoZSBjbGllbnQtdmlzaWJsZSBjb250ZW50IChleGNsdWRpbmcgd3JhcHBlciBmb3Igd3JhcHBlZCBjbGllbnRzKVxuICBnZXRDbGllbnRDb250ZW50OiAtPlxuICAgIEBfLmNvbnRlbnRcblxuICByZXF1aXJlc0NvbnZlcnNpb246IC0+XG4gICAgKENsb3VkQ29udGVudC53cmFwRmlsZUNvbnRlbnQgaXNudCBAX2NvbnRlbnRGb3JtYXQ/LmlzQ2ZtV3JhcHBlZCkgb3IgQF9jb250ZW50Rm9ybWF0Py5pc1ByZUNmbUZvcm1hdFxuXG4gIGNsb25lOiAtPiBuZXcgQ2xvdWRDb250ZW50IChfLmNsb25lRGVlcCBAXyksIChfLmNsb25lRGVlcCBAX2NvbnRlbnRGb3JtYXQpXG5cbiAgc2V0VGV4dDogKHRleHQpIC0+IEBfLmNvbnRlbnQgPSB0ZXh0XG4gIGdldFRleHQ6IC0+IGlmIEBfLmNvbnRlbnQgaXMgbnVsbCB0aGVuICcnIGVsc2UgaWYgaXNTdHJpbmcoQF8uY29udGVudCkgdGhlbiBAXy5jb250ZW50IGVsc2UgSlNPTi5zdHJpbmdpZnkgQF8uY29udGVudFxuXG4gIGFkZE1ldGFkYXRhOiAobWV0YWRhdGEpIC0+IEBfW2tleV0gPSBtZXRhZGF0YVtrZXldIGZvciBrZXkgb2YgbWV0YWRhdGFcbiAgZ2V0OiAocHJvcCkgLT4gQF9bcHJvcF1cbiAgc2V0OiAocHJvcCwgdmFsdWUpIC0+IEBfW3Byb3BdID0gdmFsdWVcbiAgcmVtb3ZlOiAocHJvcCkgLT4gZGVsZXRlIEBfW3Byb3BdXG5cbiAgZ2V0U2hhcmVkTWV0YWRhdGE6IC0+XG4gICAgIyBvbmx5IGluY2x1ZGUgbmVjZXNzYXJ5IGZpZWxkc1xuICAgIHNoYXJlZCA9IHt9XG4gICAgc2hhcmVkLl9wZXJtaXNzaW9ucyA9IEBfLl9wZXJtaXNzaW9ucyBpZiBAXy5fcGVybWlzc2lvbnM/XG4gICAgc2hhcmVkLnNoYXJlRWRpdEtleSA9IEBfLnNoYXJlRWRpdEtleSBpZiBAXy5zaGFyZUVkaXRLZXk/XG4gICAgc2hhcmVkLnNoYXJlZERvY3VtZW50SWQgPSBAXy5zaGFyZWREb2N1bWVudElkIGlmIEBfLnNoYXJlZERvY3VtZW50SWQ/XG4gICAgc2hhcmVkLmFjY2Vzc0tleXMgPSBAXy5hY2Nlc3NLZXlzIGlmIEBfLmFjY2Vzc0tleXM/XG4gICAgc2hhcmVkXG5cbiAgY29weU1ldGFkYXRhVG86ICh0bykgLT5cbiAgICBtZXRhZGF0YSA9IHt9XG4gICAgZm9yIG93biBrZXksIHZhbHVlIG9mIEBfXG4gICAgICBpZiBrZXkgaXNudCAnY29udGVudCdcbiAgICAgICAgbWV0YWRhdGFba2V5XSA9IHZhbHVlXG4gICAgdG8uYWRkTWV0YWRhdGEgbWV0YWRhdGFcblxuY2xhc3MgUHJvdmlkZXJJbnRlcmZhY2VcblxuICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMpIC0+XG4gICAge0BuYW1lLCBAZGlzcGxheU5hbWUsIEB1cmxEaXNwbGF5TmFtZSwgQGNhcGFiaWxpdGllc30gPSBvcHRpb25zXG5cbiAgQEF2YWlsYWJsZTogLT4gdHJ1ZVxuXG4gIGNhbjogKGNhcGFiaWxpdHkpIC0+XG4gICAgISFAY2FwYWJpbGl0aWVzW2NhcGFiaWxpdHldXG5cbiAgY2FuQXV0bzogKGNhcGFiaWxpdHkpIC0+XG4gICAgQGNhcGFiaWxpdGllc1tjYXBhYmlsaXR5XSBpcyAnYXV0bydcblxuICBpc0F1dGhvcml6YXRpb25SZXF1aXJlZDogLT5cbiAgICBmYWxzZVxuXG4gIGF1dGhvcml6ZWQ6IChjYWxsYmFjaykgLT5cbiAgICBpZiBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgdHJ1ZVxuICAgIGVsc2VcbiAgICAgIHRydWVcblxuICByZW5kZXJBdXRob3JpemF0aW9uRGlhbG9nOiAtPlxuICAgIChBdXRob3JpemF0aW9uTm90SW1wbGVtZW50ZWREaWFsb2cge3Byb3ZpZGVyOiBAfSlcblxuICByZW5kZXJVc2VyOiAtPlxuICAgIG51bGxcblxuICBmaWx0ZXJUYWJDb21wb25lbnQ6IChjYXBhYmlsaXR5LCBkZWZhdWx0Q29tcG9uZW50KSAtPlxuICAgIGRlZmF1bHRDb21wb25lbnRcblxuICBtYXRjaGVzRXh0ZW5zaW9uOiAobmFtZSkgLT5cbiAgICByZXR1cm4gZmFsc2UgaWYgbm90IG5hbWVcbiAgICBpZiBDbG91ZE1ldGFkYXRhLlJlYWRhYmxlRXh0ZW5zaW9ucz8gYW5kIENsb3VkTWV0YWRhdGEuUmVhZGFibGVFeHRlbnNpb25zLmxlbmd0aCA+IDBcbiAgICAgIGZvciBleHRlbnNpb24gaW4gQ2xvdWRNZXRhZGF0YS5SZWFkYWJsZUV4dGVuc2lvbnNcbiAgICAgICAgcmV0dXJuIHRydWUgaWYgbmFtZS5zdWJzdHIoLWV4dGVuc2lvbi5sZW5ndGgpIGlzIGV4dGVuc2lvblxuICAgICAgICBpZiBleHRlbnNpb24gaXMgXCJcIlxuICAgICAgICAgIHJldHVybiB0cnVlIGlmICF+bmFtZS5pbmRleE9mKFwiLlwiKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZWxzZVxuICAgICAgIyBtYXkgc2VlbSB3ZWlyZCBidXQgaXQgbWVhbnMgdGhhdCB3aXRob3V0IGFuIGV4dGVuc2lvbiBzcGVjaWZpZWQgYWxsIGZpbGVzIG1hdGNoXG4gICAgICB0cnVlXG5cbiAgaGFuZGxlVXJsUGFyYW1zOiAtPlxuICAgIGZhbHNlICMgYnkgZGVmYXVsdCwgbm8gYWRkaXRpb25hbCBVUkwgaGFuZGxpbmdcblxuICBkaWFsb2c6IChjYWxsYmFjaykgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdkaWFsb2cnXG5cbiAgc2F2ZTogKGNvbnRlbnQsIG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdzYXZlJ1xuXG4gIHNhdmVBc0V4cG9ydDogKGNvbnRlbnQsIG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICAjIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaW52b2tlcyBzYXZlXG4gICAgaWYgQGNhbiAnc2F2ZScsIG1ldGFkYXRhXG4gICAgICBAc2F2ZSBjb250ZW50LCBtZXRhZGF0YSwgY2FsbGJhY2tcbiAgICBlbHNlXG4gICAgICBAX25vdEltcGxlbWVudGVkICdzYXZlQXNFeHBvcnQnXG5cbiAgbG9hZDogKGNhbGxiYWNrKSAtPlxuICAgIEBfbm90SW1wbGVtZW50ZWQgJ2xvYWQnXG5cbiAgbGlzdDogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdsaXN0J1xuXG4gIHJlbW92ZTogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdyZW1vdmUnXG5cbiAgcmVuYW1lOiAobWV0YWRhdGEsIG5ld05hbWUsIGNhbGxiYWNrKSAtPlxuICAgIEBfbm90SW1wbGVtZW50ZWQgJ3JlbmFtZSdcblxuICBjbG9zZTogKG1ldGFkYXRhLCBjYWxsYmFjaykgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdjbG9zZSdcblxuICBzZXRGb2xkZXI6IChtZXRhZGF0YSkgLT5cbiAgICBAX25vdEltcGxlbWVudGVkICdzZXRGb2xkZXInXG5cbiAgY2FuT3BlblNhdmVkOiAtPiBmYWxzZVxuXG4gIG9wZW5TYXZlZDogKG9wZW5TYXZlZFBhcmFtcywgY2FsbGJhY2spIC0+XG4gICAgQF9ub3RJbXBsZW1lbnRlZCAnb3BlblNhdmVkJ1xuXG4gIGdldE9wZW5TYXZlZFBhcmFtczogKG1ldGFkYXRhKSAtPlxuICAgIEBfbm90SW1wbGVtZW50ZWQgJ2dldE9wZW5TYXZlZFBhcmFtcydcblxuICBmaWxlT3BlbmVkOiAtPlxuICAgICMgZG8gbm90aGluZyBieSBkZWZhdWx0XG5cbiAgX25vdEltcGxlbWVudGVkOiAobWV0aG9kTmFtZSkgLT5cbiAgICAjIHRoaXMgdXNlcyBhIGJyb3dzZXIgYWxlcnQgaW5zdGVhZCBvZiBjbGllbnQuYWxlcnQgYmVjYXVzZSB0aGlzIGlzIGp1c3QgaGVyZSBmb3IgZGVidWdnaW5nXG4gICAgYWxlcnQgXCIje21ldGhvZE5hbWV9IG5vdCBpbXBsZW1lbnRlZCBmb3IgI3tAbmFtZX0gcHJvdmlkZXJcIlxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIENsb3VkRmlsZTogQ2xvdWRGaWxlXG4gIENsb3VkTWV0YWRhdGE6IENsb3VkTWV0YWRhdGFcbiAgQ2xvdWRDb250ZW50OiBDbG91ZENvbnRlbnRcbiAgY2xvdWRDb250ZW50RmFjdG9yeTogbmV3IENsb3VkQ29udGVudEZhY3RvcnkoKVxuICBQcm92aWRlckludGVyZmFjZTogUHJvdmlkZXJJbnRlcmZhY2VcbiIsInRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuaXNTdHJpbmcgPSByZXF1aXJlICcuLi91dGlscy9pcy1zdHJpbmcnXG5pc0FycmF5ID0gcmVxdWlyZSAnLi4vdXRpbHMvaXMtYXJyYXknXG5cblByb3ZpZGVySW50ZXJmYWNlID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuUHJvdmlkZXJJbnRlcmZhY2VcbmNsb3VkQ29udGVudEZhY3RvcnkgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5jbG91ZENvbnRlbnRGYWN0b3J5XG5DbG91ZE1ldGFkYXRhID0gKHJlcXVpcmUgJy4vcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuXG5jbGFzcyBSZWFkT25seVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2VcblxuICBjb25zdHJ1Y3RvcjogKEBvcHRpb25zID0ge30sIEBjbGllbnQpIC0+XG4gICAgc3VwZXJcbiAgICAgIG5hbWU6IFJlYWRPbmx5UHJvdmlkZXIuTmFtZVxuICAgICAgZGlzcGxheU5hbWU6IEBvcHRpb25zLmRpc3BsYXlOYW1lIG9yICh0ciAnflBST1ZJREVSLlJFQURfT05MWScpXG4gICAgICB1cmxEaXNwbGF5TmFtZTogQG9wdGlvbnMudXJsRGlzcGxheU5hbWVcbiAgICAgIGNhcGFiaWxpdGllczpcbiAgICAgICAgc2F2ZTogZmFsc2VcbiAgICAgICAgcmVzYXZlOiBmYWxzZVxuICAgICAgICBleHBvcnQ6IGZhbHNlXG4gICAgICAgIGxvYWQ6IHRydWVcbiAgICAgICAgbGlzdDogdHJ1ZVxuICAgICAgICByZW1vdmU6IGZhbHNlXG4gICAgICAgIHJlbmFtZTogZmFsc2VcbiAgICAgICAgY2xvc2U6IGZhbHNlXG4gICAgQHRyZWUgPSBudWxsXG4gICAgQHByb21pc2VzID0gW11cblxuICBATmFtZTogJ3JlYWRPbmx5J1xuXG4gIGxvYWQ6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgaWYgbWV0YWRhdGEgYW5kIG5vdCBpc0FycmF5IG1ldGFkYXRhIGFuZCBtZXRhZGF0YS50eXBlIGlzIENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgaWYgbWV0YWRhdGEuY29udGVudD9cbiAgICAgICAgY2FsbGJhY2sgbnVsbCwgbWV0YWRhdGEuY29udGVudFxuICAgICAgICByZXR1cm5cbiAgICAgIGVsc2UgaWYgbWV0YWRhdGEudXJsP1xuICAgICAgICAkLmFqYXhcbiAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgICAgdXJsOiBtZXRhZGF0YS51cmxcbiAgICAgICAgICBzdWNjZXNzOiAoZGF0YSkgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrIG51bGwsIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGRhdGFcbiAgICAgICAgICBlcnJvcjogLT4gY2FsbGJhY2sgXCJVbmFibGUgdG8gbG9hZCAnI3ttZXRhZGF0YS5uYW1lfSdcIlxuICAgICAgICByZXR1cm5cbiAgICAgIGVsc2UgaWYgbWV0YWRhdGE/Lm5hbWU/XG4gICAgICAgIEBfbG9hZFRyZWUgKGVyciwgdHJlZSkgPT5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgZXJyIGlmIGVyclxuICAgICAgICAgIGZpbGUgPSBAX2ZpbmRGaWxlIHRyZWUsIG1ldGFkYXRhLm5hbWVcbiAgICAgICAgICBpZiBmaWxlP1xuICAgICAgICAgICAgQGxvYWQgZmlsZSwgY2FsbGJhY2sgICAgICAgICAgIyBjYWxsIGxvYWQgYWdhaW4gd2l0aCBmb3VuZCBmaWxlLCBhcyBpdCBtYXkgYmUgcmVtb3RlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbGJhY2sgXCJVbmFibGUgdG8gbG9hZCAnI3ttZXRhZGF0YS5uYW1lfSdcIlxuICAgICAgICAgIHJldHVyblxuICAgIGVsc2VcbiAgICAgIGNhbGxiYWNrIFwiVW5hYmxlIHRvIGxvYWQgc3BlY2lmaWVkIGNvbnRlbnRcIlxuXG4gIGxpc3Q6IChtZXRhZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgQF9sb2FkVHJlZSAoZXJyLCB0cmVlKSA9PlxuICAgICAgcmV0dXJuIGNhbGxiYWNrIGVyciBpZiBlcnJcbiAgICAgIGl0ZW1zID0gaWYgbWV0YWRhdGE/LnR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5Gb2xkZXIgdGhlbiBtZXRhZGF0YS5wcm92aWRlckRhdGEuY2hpbGRyZW4gZWxzZSBAdHJlZVxuICAgICAgIyBjbG9uZSB0aGUgbWV0YWRhdGEgaXRlbXMgc28gdGhhdCBhbnkgY2hhbmdlcyBtYWRlIHRvIHRoZSBmaWxlbmFtZSBvciBjb250ZW50IGluIHRoZSBlZGl0IGlzIG5vdCBjYWNoZWRcbiAgICAgIGNhbGxiYWNrIG51bGwsIF8ubWFwIGl0ZW1zLCAobWV0YWRhdGFJdGVtKSAtPiBuZXcgQ2xvdWRNZXRhZGF0YSBtZXRhZGF0YUl0ZW1cblxuICBjYW5PcGVuU2F2ZWQ6IC0+IHRydWVcblxuICBvcGVuU2F2ZWQ6IChvcGVuU2F2ZWRQYXJhbXMsIGNhbGxiYWNrKSAtPlxuICAgIG1ldGFkYXRhID0gbmV3IENsb3VkTWV0YWRhdGFcbiAgICAgIG5hbWU6IHVuZXNjYXBlKG9wZW5TYXZlZFBhcmFtcylcbiAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgcGFyZW50OiBudWxsXG4gICAgICBwcm92aWRlcjogQFxuICAgIEBsb2FkIG1ldGFkYXRhLCAoZXJyLCBjb250ZW50KSAtPlxuICAgICAgY2FsbGJhY2sgZXJyLCBjb250ZW50LCBtZXRhZGF0YVxuXG4gIGdldE9wZW5TYXZlZFBhcmFtczogKG1ldGFkYXRhKSAtPlxuICAgIG1ldGFkYXRhLm5hbWVcblxuICBfbG9hZFRyZWU6IChjYWxsYmFjaykgLT5cbiAgICAjIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byBiZSByZXNvbHZlZCBiZWZvcmUgcHJvY2VlZGluZ1xuICAgIGNvbXBsZXRlID0gKGlUcmVlKSA9PlxuICAgICAgUHJvbWlzZS5hbGwoQHByb21pc2VzKVxuICAgICAgICAudGhlbiAoLT5cbiAgICAgICAgICBpZiBpVHJlZT9cbiAgICAgICAgICAgIGNhbGxiYWNrIG51bGwsIGlUcmVlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgIyBhbiBlbXB0eSBmb2xkZXIgaXMgdW51c3VhbCBidXQgbm90IG5lY2Vzc2FyaWx5IGFuIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yPyBcIk5vIGNvbnRlbnRzIGZvdW5kIGZvciAje0BkaXNwbGF5TmFtZX0gcHJvdmlkZXJcIlxuICAgICAgICAgICAgY2FsbGJhY2sgbnVsbCwge31cbiAgICAgICAgKSxcbiAgICAgICAgIyBpZiBhIHByb21pc2Ugd2FzIHJlamVjdGVkLCB0aGVuIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICAoLT4gY2FsbGJhY2sgXCJObyBjb250ZW50cyBmb3VuZCBmb3IgI3tAZGlzcGxheU5hbWV9IHByb3ZpZGVyXCIpXG5cbiAgICBpZiBAdHJlZSBpc250IG51bGxcbiAgICAgIGNvbXBsZXRlIEB0cmVlXG4gICAgZWxzZSBpZiBAb3B0aW9ucy5qc29uXG4gICAgICBAdHJlZSA9IEBfY29udmVydEpTT05Ub01ldGFkYXRhVHJlZSBAb3B0aW9ucy5qc29uXG4gICAgICBjb21wbGV0ZSBAdHJlZVxuICAgIGVsc2UgaWYgQG9wdGlvbnMuanNvbkNhbGxiYWNrXG4gICAgICBAb3B0aW9ucy5qc29uQ2FsbGJhY2sgKGVyciwganNvbikgPT5cbiAgICAgICAgaWYgZXJyXG4gICAgICAgICAgY2FsbGJhY2sgZXJyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAdHJlZSA9IEBfY29udmVydEpTT05Ub01ldGFkYXRhVHJlZSBAb3B0aW9ucy5qc29uXG4gICAgICAgICAgY29tcGxldGUgQHRyZWVcbiAgICBlbHNlIGlmIEBvcHRpb25zLnNyY1xuICAgICAgJC5hamF4XG4gICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgdXJsOiBAb3B0aW9ucy5zcmNcbiAgICAgICAgc3VjY2VzczogKGlSZXNwb25zZSkgPT5cbiAgICAgICAgICBAdHJlZSA9IEBfY29udmVydEpTT05Ub01ldGFkYXRhVHJlZSBpUmVzcG9uc2VcbiAgICAgICAgICAjIGFscGhhYmV0aXplIHJlbW90ZWx5IGxvYWRlZCBmb2xkZXIgY29udGVudHMgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgaWYgQG9wdGlvbnMuYWxwaGFiZXRpemVcbiAgICAgICAgICAgIEB0cmVlLnNvcnQgKGlNZXRhMSwgaU1ldGEyKSAtPlxuICAgICAgICAgICAgICByZXR1cm4gLTEgaWYgaU1ldGExLm5hbWUgPCBpTWV0YTIubmFtZVxuICAgICAgICAgICAgICByZXR1cm4gIDEgaWYgaU1ldGExLm5hbWUgPiBpTWV0YTIubmFtZVxuICAgICAgICAgICAgICByZXR1cm4gIDBcbiAgICAgICAgICBjb21wbGV0ZSBAdHJlZVxuICAgICAgICBlcnJvcjogKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT5cbiAgICAgICAgICBlcnJvck1ldGFkYXRhID0gQF9jcmVhdGVFcnJvck1ldGFkYXRhIG51bGxcbiAgICAgICAgICBAdHJlZSA9IFsgZXJyb3JNZXRhZGF0YSBdXG4gICAgICAgICAgY29tcGxldGUgQHRyZWVcbiAgICBlbHNlXG4gICAgICBjb21wbGV0ZSBudWxsXG5cbiAgX2NvbnZlcnRKU09OVG9NZXRhZGF0YVRyZWU6IChqc29uLCBwYXJlbnQgPSBudWxsKSAtPlxuICAgIHRyZWUgPSBbXVxuXG4gICAgaWYgaXNBcnJheSBqc29uXG4gICAgICAjIHBhcnNlIGFycmF5IGZvcm1hdDpcbiAgICAgICMgW3sgbmFtZTogXCIuLi5cIiwgY29udGVudDogXCIuLi5cIn0sIHsgbmFtZTogXCIuLi5cIiwgdHlwZTogJ2ZvbGRlcicsIGNoaWxkcmVuOiBbLi4uXSB9XVxuICAgICAgZm9yIGl0ZW0gaW4ganNvblxuICAgICAgICB0eXBlID0gQ2xvdWRNZXRhZGF0YS5tYXBUeXBlVG9DbG91ZE1ldGFkYXRhVHlwZSBpdGVtLnR5cGVcbiAgICAgICAgbWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZVxuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvblxuICAgICAgICAgIG1pbWVUeXBlOiBpdGVtLm1pbWVUeXBlXG4gICAgICAgICAgY29udGVudDogaWYgaXRlbS5jb250ZW50PyB0aGVuIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGl0ZW0uY29udGVudCBlbHNlIHVuZGVmaW5lZFxuICAgICAgICAgIHVybDogaXRlbS51cmwgb3IgaXRlbS5sb2NhdGlvblxuICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgcHJvdmlkZXI6IEBcbiAgICAgICAgICBwcm92aWRlckRhdGE6XG4gICAgICAgICAgICBjaGlsZHJlbjogbnVsbFxuICAgICAgICBpZiB0eXBlIGlzIENsb3VkTWV0YWRhdGEuRm9sZGVyXG4gICAgICAgICAgbmV3Rm9sZGVyUHJvbWlzZSA9IChpSXRlbSwgaU1ldGFkYXRhKSA9PlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlIChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgICAgIGlmIGlJdGVtLmNoaWxkcmVuP1xuICAgICAgICAgICAgICAgIGlNZXRhZGF0YS5wcm92aWRlckRhdGEuY2hpbGRyZW4gPSBAX2NvbnZlcnRKU09OVG9NZXRhZGF0YVRyZWUgaUl0ZW0uY2hpbGRyZW4sIGlNZXRhZGF0YVxuICAgICAgICAgICAgICAgIHJlc29sdmUgaU1ldGFkYXRhXG4gICAgICAgICAgICAgIGVsc2UgaWYgaUl0ZW0udXJsP1xuICAgICAgICAgICAgICAgICQuYWpheFxuICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgICAgICAgdXJsOiBpSXRlbS51cmwsXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiAoaVJlc3BvbnNlKSA9PlxuICAgICAgICAgICAgICAgICAgICBpTWV0YWRhdGEucHJvdmlkZXJEYXRhLmNoaWxkcmVuID0gQF9jb252ZXJ0SlNPTlRvTWV0YWRhdGFUcmVlIGlSZXNwb25zZSwgaU1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICMgYWxwaGFiZXRpemUgcmVtb3RlbHkgbG9hZGVkIGZvbGRlciBjb250ZW50cyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgQG9wdGlvbnMuYWxwaGFiZXRpemUgb3IgaUl0ZW0uYWxwaGFiZXRpemVcbiAgICAgICAgICAgICAgICAgICAgICBpTWV0YWRhdGEucHJvdmlkZXJEYXRhLmNoaWxkcmVuLnNvcnQgKGlNZXRhMSwgaU1ldGEyKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xIGlmIGlNZXRhMS5uYW1lIDwgaU1ldGEyLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAgMSBpZiBpTWV0YTEubmFtZSA+IGlNZXRhMi5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIDBcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSBpTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgIGVycm9yOiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1ldGFkYXRhID0gQF9jcmVhdGVFcnJvck1ldGFkYXRhIGlNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICBpTWV0YWRhdGEucHJvdmlkZXJEYXRhLmNoaWxkcmVuID0gWyBlcnJvck1ldGFkYXRhIF1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSBpTWV0YWRhdGFcbiAgICAgICAgICBAcHJvbWlzZXMucHVzaCBuZXdGb2xkZXJQcm9taXNlIGl0ZW0sIG1ldGFkYXRhXG5cbiAgICAgICAgdHJlZS5wdXNoIG1ldGFkYXRhXG4gICAgZWxzZVxuICAgICAgIyBwYXJzZSBvcmlnaW5hbCBmb3JtYXQ6XG4gICAgICAjIHsgZmlsZW5hbWU6IFwiZmlsZSBjb250ZW50c1wiLCBmb2xkZXJOYW1lOiB7Li4uIGNvbnRlbnRzIC4uLn0gfVxuICAgICAgZm9yIG93biBmaWxlbmFtZSBvZiBqc29uXG4gICAgICAgIGl0ZW1Db250ZW50ID0ganNvbltmaWxlbmFtZV1cbiAgICAgICAgdHlwZSA9IGlmIGlzU3RyaW5nIGl0ZW1Db250ZW50IHRoZW4gQ2xvdWRNZXRhZGF0YS5GaWxlIGVsc2UgQ2xvdWRNZXRhZGF0YS5Gb2xkZXJcbiAgICAgICAgbWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICAgIG5hbWU6IGZpbGVuYW1lXG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIGNvbnRlbnQ6IGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50IGl0ZW1Db250ZW50XG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICBwcm92aWRlcjogQFxuICAgICAgICAgIHByb3ZpZGVyRGF0YTpcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsXG4gICAgICAgIGlmIHR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5Gb2xkZXJcbiAgICAgICAgICBtZXRhZGF0YS5wcm92aWRlckRhdGEuY2hpbGRyZW4gPSBAX2NvbnZlcnRKU09OVG9NZXRhZGF0YVRyZWUgaXRlbUNvbnRlbnQsIG1ldGFkYXRhXG4gICAgICAgIHRyZWUucHVzaCBtZXRhZGF0YVxuXG4gICAgdHJlZVxuXG4gIF9maW5kRmlsZTogKGFyciwgZmlsZW5hbWUpIC0+XG4gICAgZm9yIGl0ZW0gaW4gYXJyXG4gICAgICBpZiBpdGVtLnR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5GaWxlXG4gICAgICAgIGlmIGl0ZW0/Lm5hbWUgaXMgZmlsZW5hbWVcbiAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgZWxzZSBpZiBpdGVtLnByb3ZpZGVyRGF0YT8uY2hpbGRyZW4/Lmxlbmd0aFxuICAgICAgICBmb3VuZENoaWxkID0gQF9maW5kRmlsZSBpdGVtLnByb3ZpZGVyRGF0YS5jaGlsZHJlbiwgZmlsZW5hbWVcbiAgICAgICAgaWYgZm91bmRDaGlsZD8gdGhlbiByZXR1cm4gZm91bmRDaGlsZFxuICAgIHJldHVybiBudWxsXG5cbiAgIyBSZW1vdGUgZm9sZGVyIGNvbnRlbnRzIGFyZSBsaWtlbHkgdG8gYmUgbG9hZGVkIGFzIHBhcnQgb2ZcbiAgIyBzYW1wbGUgZG9jdW1lbnQgaGllcmFyY2hpZXMuIFRoZSBpbmFiaWxpdHkgdG8gbG9hZCBvbmUgc3ViZm9sZGVyXG4gICMgb2YgZXhhbXBsZXMgc2hvdWxkbid0IG5lY2Vzc2FyaWx5IGJlIHRyZWF0ZWQgYXMgYSBmYXRhbCBlcnJvci5cbiAgIyBUaGVyZWZvcmUsIHdlIHB1dCBhbiBpdGVtIGluIHRoZSByZXR1cm5lZCByZXN1bHRzIHdoaWNoIGluZGljYXRlc1xuICAjIHRoZSBlcnJvciBhbmQgd2hpY2ggaXMgbm9uLXNlbGVjdGFibGUsIGJ1dCByZXNvbHZlIHRoZSBwcm9taXNlXG4gICMgc28gdGhhdCB0aGUgb3BlbiBjYW4gcHJvY2VlZCB3aXRob3V0IHRoZSBtaXNzaW5nIGZvbGRlciBjb250ZW50cy5cbiAgX2NyZWF0ZUVycm9yTWV0YWRhdGE6IChpUGFyZW50KSAtPlxuICAgIG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICBuYW1lOiB0ciBcIn5GSUxFX0RJQUxPRy5MT0FEX0ZPTERFUl9FUlJPUlwiXG4gICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkxhYmVsXG4gICAgICBjb250ZW50OiBcIlwiXG4gICAgICBwYXJlbnQ6IGlQYXJlbnRcbiAgICAgIHByb3ZpZGVyOiBAXG4gICAgICBwcm92aWRlckRhdGE6XG4gICAgICAgIGNoaWxkcmVuOiBudWxsXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZE9ubHlQcm92aWRlclxuIiwiUHJvdmlkZXJJbnRlcmZhY2UgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5Qcm92aWRlckludGVyZmFjZVxuY2xvdWRDb250ZW50RmFjdG9yeSA9IChyZXF1aXJlICcuL3Byb3ZpZGVyLWludGVyZmFjZScpLmNsb3VkQ29udGVudEZhY3RvcnlcbkNsb3VkTWV0YWRhdGEgPSAocmVxdWlyZSAnLi9wcm92aWRlci1pbnRlcmZhY2UnKS5DbG91ZE1ldGFkYXRhXG5cbiMgVGhpcyBwcm92aWRlciBnZXRzIGNyZWF0ZWQgYnkgdGhlIGNsaWVudCB3aGVuIG5lZWRlZCB0byBvcGVuIGEgdXJsIGRpcmVjdGx5LlxuIyBJdCBjYW5ub3QgYmUgYWRkZWQgYXMgb25lIG9mIHRoZSBhcHAncyBsaXN0IG9mIHByb3ZpZGVyc1xuXG5jbGFzcyBVUkxQcm92aWRlciBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlXG5cbiAgY29uc3RydWN0b3I6IChAb3B0aW9ucyA9IHt9LCBAY2xpZW50KSAtPlxuICAgIHN1cGVyXG4gICAgICBjYXBhYmlsaXRpZXM6XG4gICAgICAgIHNhdmU6IGZhbHNlXG4gICAgICAgIHJlc2F2ZTogZmFsc2VcbiAgICAgICAgZXhwb3J0OiBmYWxzZVxuICAgICAgICBsb2FkOiBmYWxzZVxuICAgICAgICBsaXN0OiBmYWxzZVxuICAgICAgICByZW1vdmU6IGZhbHNlXG4gICAgICAgIHJlbmFtZTogZmFsc2VcbiAgICAgICAgY2xvc2U6IGZhbHNlXG5cbiAgY2FuT3BlblNhdmVkOiAtPiBmYWxzZVxuXG4gIG9wZW5GaWxlRnJvbVVybDogKHVybCwgY2FsbGJhY2spIC0+XG4gICAgbWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgdHlwZTogQ2xvdWRNZXRhZGF0YS5GaWxlXG4gICAgICB1cmw6IHVybFxuICAgICAgcGFyZW50OiBudWxsXG4gICAgICBwcm92aWRlcjogQFxuXG4gICAgJC5hamF4XG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICB1cmw6IG1ldGFkYXRhLnVybFxuICAgICAgc3VjY2VzczogKGRhdGEpIC0+XG4gICAgICAgIGNhbGxiYWNrIG51bGwsIGNsb3VkQ29udGVudEZhY3RvcnkuY3JlYXRlRW52ZWxvcGVkQ2xvdWRDb250ZW50KGRhdGEpLCBtZXRhZGF0YVxuICAgICAgZXJyb3I6IC0+IGNhbGxiYWNrIFwiVW5hYmxlIHRvIGxvYWQgZG9jdW1lbnQgZnJvbSAnI3ttZXRhZGF0YS51cmx9J1wiXG5cbm1vZHVsZS5leHBvcnRzID0gVVJMUHJvdmlkZXJcbiIsInRyID0gcmVxdWlyZSAnLi91dGlscy90cmFuc2xhdGUnXG5pc1N0cmluZyA9IHJlcXVpcmUgJy4vdXRpbHMvaXMtc3RyaW5nJ1xuXG5jbGFzcyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudFxuXG4gIGNvbnN0cnVjdG9yOiAoQHR5cGUsIEBkYXRhID0ge30pIC0+XG5cbmNsYXNzIENsb3VkRmlsZU1hbmFnZXJVSU1lbnVcblxuICBARGVmYXVsdE1lbnU6IFsnbmV3RmlsZURpYWxvZycsICdvcGVuRmlsZURpYWxvZycsICdyZXZlcnRTdWJNZW51JywgJ3NlcGFyYXRvcicsICdzYXZlJywgJ2NyZWF0ZUNvcHknLCAnc2hhcmVTdWJNZW51JywgJ3JlbmFtZURpYWxvZyddXG5cbiAgY29uc3RydWN0b3I6IChvcHRpb25zLCBjbGllbnQpIC0+XG4gICAgQG9wdGlvbnMgPSBvcHRpb25zXG4gICAgQGl0ZW1zID0gQHBhcnNlTWVudUl0ZW1zIG9wdGlvbnMubWVudSwgY2xpZW50XG5cbiAgcGFyc2VNZW51SXRlbXM6IChtZW51SXRlbXMsIGNsaWVudCkgLT5cbiAgICBzZXRBY3Rpb24gPSAoYWN0aW9uKSAtPlxuICAgICAgY2xpZW50W2FjdGlvbl0/LmJpbmQoY2xpZW50KSBvciAoLT4gY2xpZW50LmFsZXJ0IFwiTm8gI3thY3Rpb259IGFjdGlvbiBpcyBhdmFpbGFibGUgaW4gdGhlIGNsaWVudFwiKVxuXG4gICAgc2V0RW5hYmxlZCA9IChhY3Rpb24pIC0+XG4gICAgICBzd2l0Y2ggYWN0aW9uXG4gICAgICAgIHdoZW4gJ3JldmVydFN1Yk1lbnUnXG4gICAgICAgICAgIyByZXZlcnQgc3ViLW1lbnUgc3RhdGUgZGVwZW5kcyBvbiBwcmVzZW5jZSBvZiBzaGFyZUVkaXRLZXlcbiAgICAgICAgICAtPiAoY2xpZW50LnN0YXRlLm9wZW5lZENvbnRlbnQ/IGFuZCBjbGllbnQuc3RhdGUubWV0YWRhdGE/KSBvciBjbGllbnQuY2FuRWRpdFNoYXJlZCgpXG4gICAgICAgIHdoZW4gJ3JldmVydFRvTGFzdE9wZW5lZERpYWxvZydcbiAgICAgICAgICAtPiBjbGllbnQuc3RhdGUub3BlbmVkQ29udGVudD8gYW5kIGNsaWVudC5zdGF0ZS5tZXRhZGF0YT9cbiAgICAgICAgd2hlbiAnc2hhcmVHZXRMaW5rJywgJ3NoYXJlU3ViTWVudSdcbiAgICAgICAgICAtPiBjbGllbnQuc3RhdGUuc2hhcmVQcm92aWRlcj9cbiAgICAgICAgd2hlbiAncmV2ZXJ0VG9TaGFyZWREaWFsb2cnXG4gICAgICAgICAgIyByZXZlcnQgdG8gc2hhcmVkIG1lbnUgaXRlbSBzdGF0ZSBkZXBlbmRzIG9uIHNoYXJlZERvY3VtZW50SWRcbiAgICAgICAgICAtPiBjbGllbnQuaXNTaGFyZWQoKVxuICAgICAgICB3aGVuICdzaGFyZVVwZGF0ZSdcbiAgICAgICAgICAjIHNoYXJlVXBkYXRlIG1lbnUgaXRlbSBzdGF0ZSBkZXBlbmRzIG9uIHByZXNlbmNlIG9mIHNoYXJlRWRpdEtleSBvciByZWFkV3JpdGUgYWNjZXNzS2V5XG4gICAgICAgICAgLT4gY2xpZW50LmNhbkVkaXRTaGFyZWQoKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdHJ1ZVxuXG4gICAgZ2V0SXRlbXMgPSAoc3ViTWVudUl0ZW1zKSA9PlxuICAgICAgaWYgc3ViTWVudUl0ZW1zXG4gICAgICAgIEBwYXJzZU1lbnVJdGVtcyBzdWJNZW51SXRlbXMsIGNsaWVudFxuICAgICAgZWxzZVxuICAgICAgICBudWxsXG5cbiAgICBuYW1lcyA9XG4gICAgICBuZXdGaWxlRGlhbG9nOiB0ciBcIn5NRU5VLk5FV1wiXG4gICAgICBvcGVuRmlsZURpYWxvZzogdHIgXCJ+TUVOVS5PUEVOXCJcbiAgICAgIGNsb3NlRmlsZURpYWxvZzogdHIgXCJ+TUVOVS5DTE9TRVwiXG4gICAgICByZXZlcnRUb0xhc3RPcGVuZWREaWFsb2c6IHRyIFwifk1FTlUuUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCJcbiAgICAgIHJldmVydFRvU2hhcmVkRGlhbG9nOiB0ciBcIn5NRU5VLlJFVkVSVF9UT19TSEFSRURfVklFV1wiXG4gICAgICBzYXZlOiB0ciBcIn5NRU5VLlNBVkVcIlxuICAgICAgc2F2ZUZpbGVBc0RpYWxvZzogdHIgXCJ+TUVOVS5TQVZFX0FTXCJcbiAgICAgIHNhdmVTZWNvbmRhcnlGaWxlQXNEaWFsb2c6IHRyIFwifk1FTlUuRVhQT1JUX0FTXCJcbiAgICAgIGNyZWF0ZUNvcHk6IHRyIFwifk1FTlUuQ1JFQVRFX0NPUFlcIlxuICAgICAgc2hhcmVHZXRMaW5rOiB0ciBcIn5NRU5VLlNIQVJFX0dFVF9MSU5LXCJcbiAgICAgIHNoYXJlVXBkYXRlOiB0ciBcIn5NRU5VLlNIQVJFX1VQREFURVwiXG4gICAgICBkb3dubG9hZERpYWxvZzogdHIgXCJ+TUVOVS5ET1dOTE9BRFwiXG4gICAgICByZW5hbWVEaWFsb2c6IHRyIFwifk1FTlUuUkVOQU1FXCJcbiAgICAgIHJldmVydFN1Yk1lbnU6IHRyIFwifk1FTlUuUkVWRVJUX1RPXCJcbiAgICAgIHNoYXJlU3ViTWVudTogdHIgXCJ+TUVOVS5TSEFSRVwiXG5cbiAgICBzdWJNZW51cyA9XG4gICAgICByZXZlcnRTdWJNZW51OiBbJ3JldmVydFRvTGFzdE9wZW5lZERpYWxvZycsICdyZXZlcnRUb1NoYXJlZERpYWxvZyddXG4gICAgICBzaGFyZVN1Yk1lbnU6IFsnc2hhcmVHZXRMaW5rJywgJ3NoYXJlVXBkYXRlJ11cblxuICAgIGl0ZW1zID0gW11cbiAgICBmb3IgaXRlbSwgaSBpbiBtZW51SXRlbXNcbiAgICAgIGlmIGl0ZW0gaXMgJ3NlcGFyYXRvcidcbiAgICAgICAgbWVudUl0ZW0gPVxuICAgICAgICAgIGtleTogXCJzZXBlcmF0b3Ije2l9XCJcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWVcbiAgICAgIGVsc2UgaWYgaXNTdHJpbmcgaXRlbVxuICAgICAgICBtZW51SXRlbSA9XG4gICAgICAgICAga2V5OiBpdGVtXG4gICAgICAgICAgbmFtZTogQG9wdGlvbnMubWVudU5hbWVzP1tpdGVtXSBvciBuYW1lc1tpdGVtXSBvciBcIlVua25vd24gaXRlbTogI3tpdGVtfVwiXG4gICAgICAgICAgZW5hYmxlZDogc2V0RW5hYmxlZCBpdGVtXG4gICAgICAgICAgaXRlbXM6IGdldEl0ZW1zIHN1Yk1lbnVzW2l0ZW1dXG4gICAgICAgICAgYWN0aW9uOiBzZXRBY3Rpb24gaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBtZW51SXRlbSA9IGl0ZW1cbiAgICAgICAgIyBjbGllbnRzIGNhbiBwYXNzIGluIGN1c3RvbSB7bmFtZTouLi4sIGFjdGlvbjouLi59IG1lbnUgaXRlbXMgd2hlcmUgdGhlIGFjdGlvbiBjYW4gYmUgYSBjbGllbnQgZnVuY3Rpb24gbmFtZSBvciBvdGhlcndpc2UgaXQgaXMgYXNzdW1lZCBhY3Rpb24gaXMgYSBmdW5jdGlvblxuICAgICAgICBpZiBpc1N0cmluZyBpdGVtLmFjdGlvblxuICAgICAgICAgIG1lbnVJdGVtLmtleSA9IGl0ZW0uYWN0aW9uXG4gICAgICAgICAgbWVudUl0ZW0uZW5hYmxlZCA9IHNldEVuYWJsZWQgaXRlbS5hY3Rpb25cbiAgICAgICAgICBtZW51SXRlbS5hY3Rpb24gPSBzZXRBY3Rpb24gaXRlbS5hY3Rpb25cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1lbnVJdGVtLmVuYWJsZWQgb3I9IHRydWVcbiAgICAgICAgbWVudUl0ZW0uaXRlbXMgPSBnZXRJdGVtcyhpdGVtLml0ZW1zKSBpZiBpdGVtLml0ZW1zXG4gICAgICBpdGVtcy5wdXNoIG1lbnVJdGVtXG4gICAgaXRlbXNcblxuY2xhc3MgQ2xvdWRGaWxlTWFuYWdlclVJXG5cbiAgY29uc3RydWN0b3I6IChAY2xpZW50KS0+XG4gICAgQG1lbnUgPSBudWxsXG4gICAgQGxpc3RlbmVyQ2FsbGJhY2tzID0gW11cblxuICBpbml0OiAob3B0aW9ucykgLT5cbiAgICBvcHRpb25zID0gb3B0aW9ucyBvciB7fVxuICAgICMgc2tpcCB0aGUgbWVudSBpZiBleHBsaWNpdHkgc2V0IHRvIG51bGwgKG1lYW5pbmcgbm8gbWVudSlcbiAgICBpZiBvcHRpb25zLm1lbnUgaXNudCBudWxsXG4gICAgICBpZiB0eXBlb2Ygb3B0aW9ucy5tZW51IGlzICd1bmRlZmluZWQnXG4gICAgICAgIG9wdGlvbnMubWVudSA9IENsb3VkRmlsZU1hbmFnZXJVSU1lbnUuRGVmYXVsdE1lbnVcbiAgICAgIEBtZW51ID0gbmV3IENsb3VkRmlsZU1hbmFnZXJVSU1lbnUgb3B0aW9ucywgQGNsaWVudFxuXG4gICMgZm9yIFJlYWN0IHRvIGxpc3RlbiBmb3IgZGlhbG9nIGNoYW5nZXNcbiAgbGlzdGVuOiAoY2FsbGJhY2spIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2tzLnB1c2ggY2FsbGJhY2tcblxuICBsaXN0ZW5lckNhbGxiYWNrOiAoZXZ0KSAtPlxuICAgIGZvciBjYWxsYmFjayBpbiBAbGlzdGVuZXJDYWxsYmFja3NcbiAgICAgIGNhbGxiYWNrIGV2dFxuXG4gIGFwcGVuZE1lbnVJdGVtOiAoaXRlbSkgLT5cbiAgICBAbGlzdGVuZXJDYWxsYmFjayBuZXcgQ2xvdWRGaWxlTWFuYWdlclVJRXZlbnQgJ2FwcGVuZE1lbnVJdGVtJywgaXRlbVxuXG4gIHByZXBlbmRNZW51SXRlbTogKGl0ZW0pIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdwcmVwZW5kTWVudUl0ZW0nLCBpdGVtXG5cbiAgcmVwbGFjZU1lbnVJdGVtOiAoa2V5LCBpdGVtKSAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAncmVwbGFjZU1lbnVJdGVtJyxcbiAgICAgIGtleToga2V5XG4gICAgICBpdGVtOiBpdGVtXG5cbiAgaW5zZXJ0TWVudUl0ZW1CZWZvcmU6IChrZXksIGl0ZW0pIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdpbnNlcnRNZW51SXRlbUJlZm9yZScsXG4gICAgICBrZXk6IGtleVxuICAgICAgaXRlbTogaXRlbVxuXG4gIGluc2VydE1lbnVJdGVtQWZ0ZXI6IChrZXksIGl0ZW0pIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdpbnNlcnRNZW51SXRlbUFmdGVyJyxcbiAgICAgIGtleToga2V5XG4gICAgICBpdGVtOiBpdGVtXG5cbiAgc2V0TWVudUJhckluZm86IChpbmZvKSAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAnc2V0TWVudUJhckluZm8nLCBpbmZvXG5cbiAgc2F2ZUZpbGVEaWFsb2c6IChjYWxsYmFjaykgLT5cbiAgICBAX3Nob3dQcm92aWRlckRpYWxvZyAnc2F2ZUZpbGUnLCAodHIgJ35ESUFMT0cuU0FWRScpLCBjYWxsYmFja1xuXG4gIHNhdmVGaWxlQXNEaWFsb2c6IChjYWxsYmFjaykgLT5cbiAgICBAX3Nob3dQcm92aWRlckRpYWxvZyAnc2F2ZUZpbGVBcycsICh0ciAnfkRJQUxPRy5TQVZFX0FTJyksIGNhbGxiYWNrXG5cbiAgc2F2ZVNlY29uZGFyeUZpbGVBc0RpYWxvZzogKGRhdGEsIGNhbGxiYWNrKSAtPlxuICAgIEBfc2hvd1Byb3ZpZGVyRGlhbG9nICdzYXZlU2Vjb25kYXJ5RmlsZUFzJywgKHRyICd+RElBTE9HLkVYUE9SVF9BUycpLCBjYWxsYmFjaywgZGF0YVxuXG4gIG9wZW5GaWxlRGlhbG9nOiAoY2FsbGJhY2spIC0+XG4gICAgQF9zaG93UHJvdmlkZXJEaWFsb2cgJ29wZW5GaWxlJywgKHRyICd+RElBTE9HLk9QRU4nKSwgY2FsbGJhY2tcblxuICBpbXBvcnREYXRhRGlhbG9nOiAoY2FsbGJhY2spIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdzaG93SW1wb3J0RGlhbG9nJyxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuXG4gIGRvd25sb2FkRGlhbG9nOiAoZmlsZW5hbWUsIGNvbnRlbnQsIGNhbGxiYWNrKSAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAnc2hvd0Rvd25sb2FkRGlhbG9nJyxcbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgY29udGVudDogY29udGVudFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG5cbiAgcmVuYW1lRGlhbG9nOiAoZmlsZW5hbWUsIGNhbGxiYWNrKSAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAnc2hvd1JlbmFtZURpYWxvZycsXG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuXG4gIHNoYXJlRGlhbG9nOiAoY2xpZW50LCBlbmFibGVMYXJhU2hhcmluZz1mYWxzZSkgLT5cbiAgICBAbGlzdGVuZXJDYWxsYmFjayBuZXcgQ2xvdWRGaWxlTWFuYWdlclVJRXZlbnQgJ3Nob3dTaGFyZURpYWxvZycsXG4gICAgICBjbGllbnQ6IGNsaWVudFxuICAgICAgZW5hYmxlTGFyYVNoYXJpbmc6IGVuYWJsZUxhcmFTaGFyaW5nXG5cbiAgc2hvd0Jsb2NraW5nTW9kYWw6IChtb2RhbFByb3BzKSAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAnc2hvd0Jsb2NraW5nTW9kYWwnLCBtb2RhbFByb3BzXG5cbiAgaGlkZUJsb2NraW5nTW9kYWw6IC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdoaWRlQmxvY2tpbmdNb2RhbCdcblxuICBlZGl0SW5pdGlhbEZpbGVuYW1lOiAtPlxuICAgIEBsaXN0ZW5lckNhbGxiYWNrIG5ldyBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudCAnZWRpdEluaXRpYWxGaWxlbmFtZSdcblxuICBhbGVydERpYWxvZzogKG1lc3NhZ2UsIHRpdGxlLCBjYWxsYmFjaykgLT5cbiAgICBAbGlzdGVuZXJDYWxsYmFjayBuZXcgQ2xvdWRGaWxlTWFuYWdlclVJRXZlbnQgJ3Nob3dBbGVydERpYWxvZycsXG4gICAgICB0aXRsZTogdGl0bGVcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuXG4gIGNvbmZpcm1EaWFsb2c6IChwYXJhbXMpIC0+XG4gICAgQGxpc3RlbmVyQ2FsbGJhY2sgbmV3IENsb3VkRmlsZU1hbmFnZXJVSUV2ZW50ICdzaG93Q29uZmlybURpYWxvZycsIHBhcmFtc1xuXG4gIF9zaG93UHJvdmlkZXJEaWFsb2c6IChhY3Rpb24sIHRpdGxlLCBjYWxsYmFjaywgZGF0YSkgLT5cbiAgICBAbGlzdGVuZXJDYWxsYmFjayBuZXcgQ2xvdWRGaWxlTWFuYWdlclVJRXZlbnQgJ3Nob3dQcm92aWRlckRpYWxvZycsXG4gICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIGRhdGE6IGRhdGFcblxubW9kdWxlLmV4cG9ydHMgPVxuICBDbG91ZEZpbGVNYW5hZ2VyVUlFdmVudDogQ2xvdWRGaWxlTWFuYWdlclVJRXZlbnRcbiAgQ2xvdWRGaWxlTWFuYWdlclVJOiBDbG91ZEZpbGVNYW5hZ2VyVUlcbiAgQ2xvdWRGaWxlTWFuYWdlclVJTWVudTogQ2xvdWRGaWxlTWFuYWdlclVJTWVudVxuIiwibW9kdWxlLmV4cG9ydHMgPSAocGFyYW0pIC0+XG4gIHJldCA9IG51bGxcbiAgbG9jYXRpb24uaGFzaC5zdWJzdHIoMSkuc3BsaXQoXCImXCIpLnNvbWUgKHBhaXIpIC0+XG4gICAga2V5ID0gcGFpci5zcGxpdChcIj1cIilbMF1cbiAgICBpZiBrZXkgaXMgcGFyYW1cbiAgICAgIHZhbHVlID0gcGFpci5zcGxpdChcIj1cIilbMV1cbiAgICAgIGxvb3BcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpXG4gICAgICAgICMgZGVhbCB3aXRoIG11bHRpcGx5LWVuY29kZWQgdmFsdWVzXG4gICAgICAgIGJyZWFrIHVubGVzcyAvJTIwfCUyNS8udGVzdCh2YWx1ZSlcbiAgICAgIHJldCA9IHZhbHVlXG4gIHJldFxuIiwibW9kdWxlLmV4cG9ydHMgPSAocGFyYW0pIC0+XG4gIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvW1xcW10vLCBcIlxcXFxbXCIpLnJlcGxhY2UoL1tcXF1dLywgXCJcXFxcXVwiKVxuICByZWdleFMgPSBcIltcXFxcPyZdXCIgKyBwYXJhbSArIFwiPShbXiYjXSopXCJcbiAgcmVnZXggPSBuZXcgUmVnRXhwIHJlZ2V4U1xuICByZXN1bHRzID0gcmVnZXguZXhlYyB3aW5kb3cubG9jYXRpb24uaHJlZlxuICBpZiByZXN1bHRzPy5sZW5ndGggPiAxXG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCByZXN1bHRzWzFdXG4gIGVsc2VcbiAgICByZXR1cm4gbnVsbFxuIiwiIyBodHRwczovL2NvZmZlZXNjcmlwdC1jb29rYm9vay5naXRodWIuaW8vY2hhcHRlcnMvYXJyYXlzL2NoZWNrLXR5cGUtaXMtYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gKHZhbHVlKSAtPiBBcnJheS5pc0FycmF5IHZhbHVlIG9yIHt9LnRvU3RyaW5nLmNhbGwgdmFsdWUgaXMgJ1tvYmplY3QgQXJyYXldJ1xuIiwibW9kdWxlLmV4cG9ydHMgPSAocGFyYW0pIC0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXJhbSkgaXMgJ1tvYmplY3QgU3RyaW5nXSdcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIn5NRU5VQkFSLlVOVElUTEVEX0RPQ1VNRU5UXCI6IFwiRG9rdW1lbnQxXCIsXG4gICAgXCJ+TUVOVS5ORVdcIjogXCJOZXVcIixcbiAgICBcIn5NRU5VLk9QRU5cIjogXCLDlmZmbmVuXCIsXG4gICAgXCJ+TUVOVS5DTE9TRVwiOiBcIlNjaGxpZcOfZW5cIixcbiAgICBcIn5NRU5VLklNUE9SVF9EQVRBXCI6IFwiRGF0ZW4gaW1wb3J0aWVyZW4gLi4uXCIsXG4gICAgXCJ+TUVOVS5TQVZFXCI6IFwiU3BlaWNoZXJuXCIsXG4gICAgXCJ+TUVOVS5TQVZFX0FTXCI6IFwiU3BlaWNoZXJuIHVudGVyIC4uLlwiLFxuICAgIFwifk1FTlUuRVhQT1JUX0FTXCI6IFwiRGF0ZWkgZXhwb3J0aWVyZW4gYWxzIC4uLlwiLFxuICAgIFwifk1FTlUuQ1JFQVRFX0NPUFlcIjogXCJLb3BpZSBlcnN0ZWxsZW5cIixcbiAgICBcIn5NRU5VLlNIQVJFXCI6IFwiVGVpbGVuIC4uLlwiLFxuICAgIFwifk1FTlUuU0hBUkVfR0VUX0xJTktcIjogXCJMaW5rIGVyaGFsdGVuIGbDvHIgZ2V0ZWlsdGUgQW5zaWNodFwiLFxuICAgIFwifk1FTlUuU0hBUkVfVVBEQVRFXCI6IFwiR2V0ZWlsdGUgQW5zaWNodCBha3R1YWxpc2llcmVuXCIsXG4gICAgXCJ+TUVOVS5ET1dOTE9BRFwiOiBcIkRvd25sb2FkXCIsXG4gICAgXCJ+TUVOVS5SRU5BTUVcIjogXCJVbWJlbmVubmVuXCIsXG4gICAgXCJ+TUVOVS5SRVZFUlRfVE9cIjogXCJadXLDvGNra2VocmVuIC4uLlwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCI6IFwiS8O8cnpsaWNoIGdlw7ZmZm5ldGUgRmFzc3VuZ1wiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwiR2V0ZWlsdGUgQW5zaWNodFwiLFxuICAgIFwifkRJQUxPRy5TQVZFXCI6IFwiU3BlaWNoZXJuXCIsXG4gICAgXCJ+RElBTE9HLlNBVkVfQVNcIjogXCJTcGVpY2hlcm4gdW50ZXIgLi4uXCIsXG4gICAgXCJ+RElBTE9HLkVYUE9SVF9BU1wiOiBcIkRhdGVpIGV4cG9ydGllcmVuIGFscyAuLi5cIixcbiAgICBcIn5ESUFMT0cuQ1JFQVRFX0NPUFlcIjogXCJLb3BpZSBlcnN0ZWxsZW4gLi4uXCIsXG4gICAgXCJ+RElBTE9HLk9QRU5cIjogXCLDlmZmbmVuXCIsXG4gICAgXCJ+RElBTE9HLkRPV05MT0FEXCI6IFwiRG93bmxvYWRcIixcbiAgICBcIn5ESUFMT0cuUkVOQU1FXCI6IFwiVW1iZW5lbm5lblwiLFxuICAgIFwifkRJQUxPRy5TSEFSRURcIjogXCJUZWlsZW5cIixcbiAgICBcIn5ESUFMT0cuSU1QT1JUX0RBVEFcIjogXCJEYXRlbiBpbXBvcnRpZXJlblwiLFxuICAgIFwiflBST1ZJREVSLkxPQ0FMX1NUT1JBR0VcIjogXCJMb2thbGVyIFNwZWljaGVyXCIsXG4gICAgXCJ+UFJPVklERVIuUkVBRF9PTkxZXCI6IFwiTGVzZWFuc2ljaHRcIixcbiAgICBcIn5QUk9WSURFUi5HT09HTEVfRFJJVkVcIjogXCJHb29nbGUgRHJpdmVcIixcbiAgICBcIn5QUk9WSURFUi5ET0NVTUVOVF9TVE9SRVwiOiBcIkNvbmNvcmQgQ2xvdWRcIixcbiAgICBcIn5QUk9WSURFUi5MT0NBTF9GSUxFXCI6IFwiTG9rYWxlIERhdGVpXCIsXG4gICAgXCJ+RklMRV9TVEFUVVMuU0FWSU5HXCI6IFwiU3BlaWNoZXJuXCIsXG4gICAgXCJ+RklMRV9TVEFUVVMuU0FWRURcIjogXCJHZXNwZWljaGVydFwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVkVEX1RPX1BST1ZJREVSXCI6IFwiQWxsZSDDhG5kZXJ1bmdlbiBnZXNwZWljaGVydCAle3Byb3ZpZGVyTmFtZX1cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5VTlNBVkVEXCI6IFwiVW5nZXNwZWljaGVydFwiLFxuICAgIFwifkZJTEVfRElBTE9HLkZJTEVOQU1FXCI6IFwiRGF0ZWluYW1lXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuT1BFTlwiOiBcIsOWZmZuZW5cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwiU3BlaWNoZXJuXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuQ0FOQ0VMXCI6IFwiQWJicmVjaGVuXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCI6IFwiTMO2c2NoZW5cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVfQ09ORklSTVwiOiBcIlNpbmQgU2llIHNpY2hlciwgZGFzcyAle2ZpbGVuYW1lfSBnZWzDtnNjaHQgd2VyZGVuIHNvbGw/XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiOiBcIkRhdGVpIGzDtnNjaGVuXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9NRVNTQUdFXCI6IFwiJXtmaWxlbmFtZX0gd3VyZGUgZ2Vsw7ZzY2h0XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRElOR1wiOiBcIkxhZGVuLi4uXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRF9GT0xERVJfRVJST1JcIjogXCIqKiogRmVobGVyIGJlaW0gTGFkZW4gZGVyIE9yZG5lcmluaGFsdGUgKioqXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuRE9XTkxPQURcIjogXCJEb3dubG9hZFwiLFxuICAgIFwifkZJTEVfRElBTE9HLkRPV05MT0FEX05PVEVcIjogXCJBY2h0dW5nOiBCZWkgU2FmYXJpIGvDtm5udGUgZGllc2UgRGF0ZWkgXFxcInVuYmVrYW5udFxcXCIgaGVpw59lbiB1bmQgc29sbHRlIG1hbnVlbGwgbWl0IGRlciAuY29kYXAgRXJ3ZWl0ZXJ1bmcgdmVyc2VoZW4gd2VyZGVuLlwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRFwiOiBcIkRvd25sb2FkXCIsXG4gICAgXCJ+RE9XTkxPQURfRElBTE9HLkNBTkNFTFwiOiBcIkFiYnJlY2hlblwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5JTkNMVURFX1NIQVJFX0lORk9cIjogXCJJbmZvcm1hdGlvbiDDvGJlciBUZWlsZW4gaW0gRG9rdW1lbnQgXCIsXG4gICAgXCJ+UkVOQU1FX0RJQUxPRy5SRU5BTUVcIjogXCJVbWJlbmVubmVuXCIsXG4gICAgXCJ+UkVOQU1FX0RJQUxPRy5DQU5DRUxcIjogXCJBYmJyZWNoZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWVwiOiBcIktvcGllcmVuXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlZJRVdcIjogXCJBbnNpY2h0XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNMT1NFXCI6IFwiU2NobGllw59lblwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX1NVQ0NFU1NcIjogXCJEaWUgSW5mb3JtYXRpb24gd3VyZGUga29waWVydC5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9FUlJPUlwiOiBcIkVudHNjaHVsZGlndW5nLCBkaWVzZSBJbmZvcm1hdGlvbiBrb25udGUgbmljaHQga29waWVydCB3ZXJkZW4uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfVElUTEVcIjogXCJFcmdlYm5pcyBrb3BpZXJlblwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MT05HRVZJVFlfV0FSTklOR1wiOiBcIkRpZSBnZXRlaWx0ZSBLb3BpZSBkZXMgRG9rdW1lbnRzIHdpcmQgYXVmYmV3YWhydCwgYmlzIGVpbiBKYWhyIGxhbmcgbmllbWFuZCBtZWhyIGRhcmF1ZiB6dWdyZWlmdC5cIixcbiAgICBcIn5TSEFSRV9VUERBVEUuVElUTEVcIjogXCJHZXRlaWx0ZSBBbnNjaGljaHQgYWt0dWFsaXNpZXJ0XCIsXG4gICAgXCJ+U0hBUkVfVVBEQVRFLk1FU1NBR0VcIjogXCJEaWUgZ2V0ZWlsdGUgQW5zaWNodCB3dXJkZSBlcmZvbGdyZWljaCBha3R1YWxpc2llcnQuXCIsXG4gICAgXCJ+Q09ORklSTS5PUEVOX0ZJTEVcIjogXCJFcyBnaWJ0IHVuZ2VzaWNoZXJ0ZSDDhG5kZXJ1bmdlbi4gV29sbGVuIFNpZSB3aXJrbGljaCBlaW4gbmV1ZXMgRG9rdW1lbnQgw7ZmZm5lbj9cIixcbiAgICBcIn5DT05GSVJNLk5FV19GSUxFXCI6IFwiRXMgZ2lidCB1bmdlc2ljaGVydGUgw4RuZGVydW5nZW4uIFdvbGxlbiBTaWUgd2lya2xpY2ggZWluIG5ldWVzIERva3VtZW50IGVyc3RlbGxlbj9cIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9PUEVOXCI6IFwiVW0gZGllc2VzIERva3VtZW50IHp1IMO2ZmZuZW4sIG3DvHNzZW4gU2llIHNpY2ggYXV0aG9yaXNpZXJlbi4gV29sbGVuIFNpZSBmb3J0ZmFocmVuP1wiLFxuICAgIFwifkNPTkZJUk0uQVVUSE9SSVpFX1NBVkVcIjogXCJVbSBkaWVzZXMgRG9rdW1lbnQgenUgc3BlaWNoZXJuLCBtw7xzc2VuIFNpZSBzaWNoIGF1dGhvcmlzaWVyZW4uIFdvbGxlbiBTaWUgZm9ydGZhaHJlbj9cIixcbiAgICBcIn5DT05GSVJNLkNMT1NFX0ZJTEVcIjogXCJFcyBnaWJ0IHVuZ2VzaWNoZXJ0ZSDDhG5kZXJ1bmdlbi4gV29sbGVuIFNpZSBkYXMgRG9rdW1lbnQgd2lya2xpY2ggc2NobGllw59lbj9cIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIlNpbmQgU2llIHNpY2hlciwgZGFzcyBTaWUgZGFzIERva3VtZW50IGluIGRlbiB6dWxldHp0IGdlw7ZmZm5ldGVuIFp1c3RhbmQgenVyw7xja3ZlcnNldHplbiBtw7ZjaHRlbj9cIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19TSEFSRURfVklFV1wiOiBcIlNpbmQgU2llIHNpY2hlciwgZGFzcyBTaWUgZGFzIERva3VtZW50IGluIGRlbiB6dWxldHp0IGdldGVpbHRlbiBadXN0YW5kIHp1csO8Y2t2ZXJzZXR6ZW4gbcO2Y2h0ZW4/XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuVElUTEVcIjogXCJTaW5kIFNpZSBzaWNoZXI/XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuWUVTXCI6IFwiSmFcIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5OT1wiOiBcIk5laW5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5EUk9QX0ZJTEVfSEVSRVwiOiBcIkRhdGVpIGhpZXJoZXIgemllaGVuIG9kZXIga2xpY2tlbiwgdW0gZWluZSBEYXRlaSBhdXN6dXfDpGhsZW5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19TRUxFQ1RFRFwiOiBcIkVzIGthbm4gbnVyIGVpbmUgRGF0ZWkgYXVzZ2V3w6RobHQgd2VyZGVuLlwiLFxuICAgIFwifkxPQ0FMX0ZJTEVfRElBTE9HLk1VTFRJUExFX0ZJTEVTX0RST1BQRURcIjogXCJTaWUga8O2bm5lbiBudXIgZWluZSBEYXRlaSBoaWVyaGVyIHppZWhlbi5cIixcbiAgICBcIn5JTVBPUlQuTE9DQUxfRklMRVwiOiBcIkxva2FsZSBEYXRlaVwiLFxuICAgIFwifklNUE9SVC5VUkxcIjogXCJVUkxcIixcbiAgICBcIn5JTVBPUlRfVVJMLk1VTFRJUExFX1VSTFNfRFJPUFBFRFwiOiBcIkVzIGthbm4gbnVyIGVpbmUgVVJMIHZlcndlbmRldCB3ZXJkZW4uXCIsXG4gICAgXCJ+SU1QT1JUX1VSTC5QTEVBU0VfRU5URVJfVVJMXCI6IFwiQWRyZXNzZSB6dW0gSW1wb3J0aWVyZW4gZWluZ2ViZW4uXCIsXG4gICAgXCJ+VVJMX1RBQi5EUk9QX1VSTF9IRVJFXCI6IFwiWmllaGVuIFNpZSBkaWUgVVJMIGhpZXJoZXIgb2RlciBnZWJlbiBTaWUgZGllIFVSTCB1bnRlbiBlaW5cIixcbiAgICBcIn5VUkxfVEFCLklNUE9SVFwiOiBcIkltcG9ydGllcmVuXCIsXG4gICAgXCJ+Q0xJRU5UX0VSUk9SLlRJVExFXCI6IFwiRmVobGVyXCIsXG4gICAgXCJ+QUxFUlRfRElBTE9HLlRJVExFXCI6IFwiQWxhcm1cIixcbiAgICBcIn5BTEVSVF9ESUFMT0cuQ0xPU0VcIjogXCJTY2hsaWXDn2VuXCIsXG4gICAgXCJ+QUxFUlQuTk9fUFJPVklERVJcIjogXCJEYXMgYW5nZWdlYmVuZSBEb2t1bWVudCBrb25udGUgbmljaHQgZ2XDtmZmbmV0IHdlcmRlbiwgZGEga2VpbiBnZWVpZ25ldGVyIEFuYmlldGVyIHZlcmbDvGdiYXIgaXN0LlwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5MT0dJTl9CVVRUT05fTEFCRUxcIjogXCJMb2dpbiBmw7xyIEdvb2dsZVwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5DT05ORUNUSU5HX01FU1NBR0VcIjogXCJWZXJiaW5kZSB6dSBHb29nbGUuLi5cIixcbiAgICBcIn5HT09HTEVfRFJJVkUuRVJST1JfTUlTU0lOR19DTElFTlRJRFwiOiBcIkZlaGxlbmRlIGVyZm9yZGVybGljaGUgQ2xpZW50SWQgaW4gZGVuIEdvb2dsZURyaXZlIE9wdGlvbmVuXCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF80MDNfRVJST1JcIjogXCJTaWUgaGFiZW4ga2VpbmUgRXJsYXVibmlzLCB1bSAle2ZpbGVuYW1lfS48YnI+PGJyPiB6dSBsYWRlbi4gRmFsbHMgU2llIGVpbiBnZXRlaWx0ZXMgRG9rdW1lbnQgbnV0emVuLCBrw7ZubnRlIGVzIHVuZ2V0ZWlsdCB3b3JkZW4gc2Vpbi5cIixcbiAgICBcIn5ET0NTVE9SRS5MT0FEX1NIQVJFRF80MDRfRVJST1JcIjogXCJEYXMgYW5nZWZvcmRlcnRlIGdldGVpbHRlIERva3VtZW50IGtvbm50ZSBuaWNodCBnZWxhZGVuIHdlcmRlbi4gPGJyPjxicj4gTcO2Z2xpY2hlcndlaXNlIHd1cmRlIGRpZSBEYXRlaSBuaWNodCBnZXRlaWx0P1wiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfNDA0X0VSUk9SXCI6IFwiJXtmaWxlbmFtZX0ga2FubiBuaWNodCBnZWxhZGVuIHdlcmRlblwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfNDAzX0VSUk9SXCI6IFwiU2llIGhhYmVuIGtlaW5lIEJlcmVjaHRpZ3VuZywgdW0gJyV7ZmlsZW5hbWV9Jy48YnI+PGJyPiB6dSBzcGVpY2hlcm4uIExvZ2dlbiBTaWUgc2ljaCBlcm5ldXQgZWluLlwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRFVQTElDQVRFX0VSUk9SXCI6IFwiJXtmaWxlbmFtZX0ga2FubiBuaWNodCBlcnN0ZWxsdCB3ZXJkZW4uIERhcyBEb2t1bWVudCBleGlzdGllcnQgYmVyZWl0cy5cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0VSUk9SX1dJVEhfTUVTU0FHRVwiOiBcIkthbm4gbmljaHQgZ2VzcGVpY2hlcnQgd2VyZGVuOiAle2ZpbGVuYW1lfTogWyV7bWVzc2FnZX1dXCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV9FUlJPUlwiOiBcIkthbm4gbmljaHQgZ2VzcGVpY2hlcnQgd2VyZGVuOiAle2ZpbGVuYW1lfVwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV80MDNfRVJST1JcIjogXCJTaWUgaGFiZW4ga2VpbmUgQmVyZWNodGlndW5nLCB1bSAnJXtmaWxlbmFtZX0nLjxicj48YnI+IHp1IGzDtnNjaGVuLiBMb2dnZW4gU2llIHNpY2ggZXJuZXV0IGVpbi5cIixcbiAgICBcIn5ET0NTVE9SRS5SRU1PVkVfRVJST1JcIjogXCJLYW5uIG5pY2h0IGdlbMO2c2NodCB3ZXJkZW46ICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FXzQwM19FUlJPUlwiOiBcIlNpZSBoYWJlbiBrZWluZSBCZXJlY2h0aWd1bmcsIHVtICV7ZmlsZW5hbWV9IHVtenViZW5lbm5lbi48YnI+PGJyPiBMb2dnaW4gU2llIHNpY2ggZXJuZXV0IGVpbi5cIixcbiAgICBcIn5ET0NTVE9SRS5SRU5BTUVfRVJST1JcIjogXCJLYW5uIG5pY2h0IHVtYmVuYW5udCB3ZXJkZW46ICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfVElUTEVcIjogXCJDb25jb3JkIENsb3VkIEFsYXJtXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5BTEVSVF9TQVZFX1RJVExFXCI6IFwiQ29uY29yZCBDbG91ZCBBbGFybVwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9TQVZFX0VMU0VXSEVSRVwiOiBcIkFuIGFuZGVyZXIgU3RlbGxlIHNwZWljaGVyblwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9ET19JVF9MQVRFUlwiOiBcIkljaCB3ZXJkZSBlcyBzcMOkdGVyIHR1blwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uU0hVVF9ET1dOX01FU1NBR0VcIjogXCJEaWUgQ29uY29yZCBDbG91ZCBpc3QgbmljaHQgZXJyZWljaGJhci5cIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLlBMRUFTRV9TQVZFX0VMU0VXSEVSRVwiOiBcIkJpdHRlIHNwZWljaGVybiBTaWUgSWhyZSBEb2t1bWVudGUgYW4gYW5kZXJlciBTdGVsbGUuXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFXCI6IFwiR2V0ZWlsdGUgQW5zaWNodDrikKNcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVfRU5BQkxFRFwiOiBcImFrdGl2aWVydFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9ESVNBQkxFRFwiOiBcImRlYWt0aXZpZXJ0XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVOQUJMRV9TSEFSSU5HXCI6IFwiVGVpbGVuIGFrdGl2aWVyZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU1RPUF9TSEFSSU5HXCI6IFwiVGVpbGVuIHN0b3BwZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuVVBEQVRFX1NIQVJJTkdcIjogXCJHZXRlaWx0ZSBBbnNpY2h0IGFrdHVhbGlzaWVyZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuUFJFVklFV19TSEFSSU5HXCI6IFwiVm9yc2NoYXUgenUgZ2V0ZWlsdGVyIEFuc2ljaHRcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdfTUVTU0FHRVwiOiBcIldoZW4gVGVpbGVuIGFrdGl2aWVydCBpc3QsIHdpcmQgZWluZSBLb3BpZSBkZXIgYWt0dWVsbGVuIEFuc2ljaHQgZXJzdGVsbHQuIERpZXNlIEtvcGllIGthbm4gZ2V0ZWlsdCB3ZXJkZW4uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfVEFCXCI6IFwiTGlua1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MSU5LX01FU1NBR0VcIjogXCJJbiBlaW5lIEVtYWlsIG9kZXIgTmFjaHJpY2h0IGVpbmbDvGdlbuKQo1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9UQUJcIjogXCJFaW5iZXR0ZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU1CRURfTUVTU0FHRVwiOiBcIkNvZGUgZWluYmV0dGVuIGbDvHIgV2Vic2VpdGVuIG9kZXIgYW5kZXJlIEluaGFsdGVcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCI6IFwiRGllc2VuIExpbmsgdmVyd2VuZGVuLCB1bSBlaW5lIEFrdGl2aXTDpHQgaW4gTEFSQSB6dSBlcnN0ZWxsZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9DT0RBUF9VUkxcIjogXCJDT0RBUCBTZXJ2ZXIgVVJMOlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0FVVE9MQVVOQ0hfUEFHRVwiOiBcIkF1dG9sYXVuY2ggU2VpdGVcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9GVUxMU0NSRUVOX0JVVFRPTl9BTkRfU0NBTElOR1wiOiBcIlZvbGxiaWxkIHVuZCBTa2FsaWVyZW5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9MQVVOQ0hfQlVUVE9OX1RFWFRcIjogXCJUZXh0YnV0dG9uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfRElTUExBWV9WSVNJQklMSVRZX1RPR0dMRVNcIjogXCJEYXRlbnNpY2h0YmFya2VpdCBpbiBHcmFwaGVuIGFuemVpZ2VuXCIsXG4gICAgXCJ+Q09ORklSTS5DSEFOR0VfTEFOR1VBR0VcIjogXCJZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMuIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjaGFuZ2UgbGFuZ3VhZ2VzP1wiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwifk1FTlVCQVIuVU5USVRMRURfRE9DVU1FTlRcIjogXCLOms61zq/OvM61zr3OvyDOp8+Jz4HOr8+CIM6Mzr3Ov868zrFcIixcbiAgICBcIn5NRU5VLk5FV1wiOiBcIs6dzq3Ov1wiLFxuICAgIFwifk1FTlUuT1BFTlwiOiBcIs6Gzr3Ov865zrPOvM6xIC4uLlwiLFxuICAgIFwifk1FTlUuQ0xPU0VcIjogXCLOms67zrXOr8+DzrnOvM6/XCIsXG4gICAgXCJ+TUVOVS5JTVBPUlRfREFUQVwiOiBcIs6VzrnPg86xzrPPic6zzq4gzrTOtc60zr/OvM6tzr3Pic69IC4uLlwiLFxuICAgIFwifk1FTlUuU0FWRVwiOiBcIs6Rz4DOv864zq7Ous61z4XPg863XCIsXG4gICAgXCJ+TUVOVS5TQVZFX0FTXCI6IFwizpHPgM6/zrjOrs66zrXPhc+DzrcgzqnPgiAuLi5cIixcbiAgICBcIn5NRU5VLkVYUE9SVF9BU1wiOiBcIs6Vzr7Osc6zz4nOs86uIM6Rz4HPh861zq/Ov8+FIM6pz4IgLi4uXCIsXG4gICAgXCJ+TUVOVS5DUkVBVEVfQ09QWVwiOiBcIs6UzrfOvM65zr/Phc+BzrPOr86xIM6xzr3PhM65zrPPgc6sz4bOv8+FXCIsXG4gICAgXCJ+TUVOVS5TSEFSRVwiOiBcIs6azr/Ouc69zr/PgM6/zq/Ot8+DzrdcIixcbiAgICBcIn5NRU5VLlNIQVJFX0dFVF9MSU5LXCI6IFwizpvOrs+Izrcgz4PPhc69zrTOrc+DzrzOv8+FIM66zr/Ouc69z4zPh8+BzrfPg8+EzrfPgiDPgM+Bzr/Oss6/zrvOrs+CXCIsXG4gICAgXCJ+TUVOVS5TSEFSRV9VUERBVEVcIjogXCLOlc+AzrnOus6xzrnPgc6/z4DOv86vzrfPg863IM66zr/Ouc69z4zPh8+BzrfPg8+EzrfPgiDPgM+Bzr/Oss6/zrvOrs+CXCIsXG4gICAgXCJ+TUVOVS5ET1dOTE9BRFwiOiBcIs6bzq7PiM63XCIsXG4gICAgXCJ+TUVOVS5SRU5BTUVcIjogXCLOnM61z4TOv869zr/OvM6xz4POr86xXCIsXG4gICAgXCJ+TUVOVS5SRVZFUlRfVE9cIjogXCLOlc+AzrnPg8+Ez4HOv8+Gzq4gz4PPhM6/IC4uLlwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCI6IFwizprOsc+EzqzPg8+EzrHPg863IM+Az4HPjM+Dz4bOsc+Ezr/PhSDOsc69zr/Or86zzrzOsc+Ezr/PglwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwizprOv865zr3PjM+Hz4HOt8+Dz4TOtyDPgM+Bzr/Oss6/zrvOrlwiLFxuICAgIFwifkRJQUxPRy5TQVZFXCI6IFwizpHPgM6/zrjOrs66zrXPhc+DzrdcIixcbiAgICBcIn5ESUFMT0cuU0FWRV9BU1wiOiBcIs6Rz4DOv864zq7Ous61z4XPg863IM6pz4IgLi4uXCIsXG4gICAgXCJ+RElBTE9HLkVYUE9SVF9BU1wiOiBcIs6Vzr7Osc6zz4nOs86uIM6Rz4HPh861zq/Ov8+FIM6pz4IgLi4uXCIsXG4gICAgXCJ+RElBTE9HLkNSRUFURV9DT1BZXCI6IFwizpTOt868zrnOv8+Fz4HOs86vzrEgzpHOvc+EzrnOs8+BzqzPhs6/z4UgLi4uXCIsXG4gICAgXCJ+RElBTE9HLk9QRU5cIjogXCLOhs69zr/Ouc6zzrzOsVwiLFxuICAgIFwifkRJQUxPRy5ET1dOTE9BRFwiOiBcIs6bzq7PiM63XCIsXG4gICAgXCJ+RElBTE9HLlJFTkFNRVwiOiBcIs6czrXPhM6/zr3Ov868zrHPg86vzrFcIixcbiAgICBcIn5ESUFMT0cuU0hBUkVEXCI6IFwizprOv865zr3Ov8+Azr/Or863z4POt1wiLFxuICAgIFwifkRJQUxPRy5JTVBPUlRfREFUQVwiOiBcIs6VzrnPg86xzrPPic6zzq4gzpTOtc60zr/OvM6tzr3Pic69XCIsXG4gICAgXCJ+UFJPVklERVIuTE9DQUxfU1RPUkFHRVwiOiBcIs6kzr/PgM65zrrOriDOkc+Azr/OuM6uzrrOtc+Fz4POt1wiLFxuICAgIFwiflBST1ZJREVSLlJFQURfT05MWVwiOiBcIs6cz4zOvc6/IM6Rzr3OrM6zzr3Pic+DzrdcIixcbiAgICBcIn5QUk9WSURFUi5HT09HTEVfRFJJVkVcIjogXCJHb29nbGUgRHJpdmVcIixcbiAgICBcIn5QUk9WSURFUi5ET0NVTUVOVF9TVE9SRVwiOiBcIkNvbmNvcmQgQ2xvdWRcIixcbiAgICBcIn5QUk9WSURFUi5MT0NBTF9GSUxFXCI6IFwizqTOv8+AzrnOus+MIM6Rz4HPh861zq/Ov1wiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVklOR1wiOiBcIs6Rz4DOv864zq7Ous61z4XPg863IC4uLlwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVkVEXCI6IFwizozOu861z4Igzr/OuSDOsc67zrvOsc6zzq3PgiDOsc+Azr/OuM63zrrOtc+NzrjOt866zrHOvVwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVkVEX1RPX1BST1ZJREVSXCI6IFwizozOu861z4Igzr/OuSDOsc67zrvOsc6zzq3PgiDOsc+Azr/OuM63zrrOtc+NzrjOt866zrHOvSDPg8+Ezr8gJXtwcm92aWRlck5hbWV9XCIsXG4gICAgXCJ+RklMRV9TVEFUVVMuVU5TQVZFRFwiOiBcIs6czrcgzpHPgM6/zrjOt866zrXPhc68zq3Ovc6/XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuRklMRU5BTUVcIjogXCLOjM69zr/OvM6xIM6Rz4HPh861zq/Ov8+FXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuT1BFTlwiOiBcIs6Gzr3Ov865zrPOvM6xXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuU0FWRVwiOiBcIs6Rz4DOv864zq7Ous61z4XPg863XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuQ0FOQ0VMXCI6IFwizpHOus+Nz4HPic+DzrdcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVcIjogXCLOlM65zrHOs8+BzrHPhs6uXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFX0NPTkZJUk1cIjogXCLOmM6tzrvOtc+EzrUgz4POr86zzr/Phc+BzrEgzr3OsSDOtM65zrHOs8+BzqzPiM61z4TOtSDPhM6/ICV7ZmlsZW5hbWV9O1wiLFxuICAgIFwifkZJTEVfRElBTE9HLlJFTU9WRURfVElUTEVcIjogXCLOlM65zrHOs8+BzrHPhs6uIM6Rz4HPh861zq/Ov8+FXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9NRVNTQUdFXCI6IFwizqTOvyAle2ZpbGVuYW1lfSDOtM65zrHOs8+BzqzPhs63zrrOtVwiLFxuICAgIFwifkZJTEVfRElBTE9HLkxPQURJTkdcIjogXCLOps+Mz4HPhM+Jz4POty4uLlwiLFxuICAgIFwifkZJTEVfRElBTE9HLkxPQURfRk9MREVSX0VSUk9SXCI6IFwiKioqIM6jz4bOrM67zrzOsSDPhs+Mz4HPhM+Jz4POt8+CIM+AzrXPgc65zrXPh86/zrzOrc69z4nOvSDPhs6xzrrOrc67zr/PhSAqKipcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5ET1dOTE9BRFwiOiBcIs6bzq7PiM63XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuRE9XTkxPQURfTk9URVwiOiBcIs6jzpfOnM6VzpnOqc6jzpc6IM6jz4TOvyBTYWZhcmkgz4TOvyDOsc+Bz4fOtc6vzr8gzrzPgM6/z4HOtc6vIM69zrEgzrXOr869zrHOuSBcXFwizobOs869z4nPg8+Ezr9cXFwiIM66zrHOuSDPgM+Bzq3PgM61zrkgzr3OsSDPhM6/IM68zrXPhM6/zr3Ov868zqzPg861z4TOtSDOtc+DzrXOr8+CLCDPgM+Bzr/Pg864zq3PhM6/zr3PhM6xz4Igz4TOt869IM66zrHPhM6szrvOt86+zrcgLmNvZGFwXCIsXG4gICAgXCJ+RE9XTkxPQURfRElBTE9HLkRPV05MT0FEXCI6IFwizpvOrs+IzrdcIixcbiAgICBcIn5ET1dOTE9BRF9ESUFMT0cuQ0FOQ0VMXCI6IFwizpHOus+Nz4HPic+DzrdcIixcbiAgICBcIn5ET1dOTE9BRF9ESUFMT0cuSU5DTFVERV9TSEFSRV9JTkZPXCI6IFwizp3OsSDPg8+FzrzPgM61z4HOuc67zrfPhs64zr/Pjc69IM+AzrvOt8+Bzr/Phs6/z4HOr861z4IgzrrOv865zr3Ov8+Azr/Or863z4POt8+CIM+Dz4TOvyDOsc+Bz4fOtc6vzr8gzrvOrs+IzrfPglwiLFxuICAgIFwiflJFTkFNRV9ESUFMT0cuUkVOQU1FXCI6IFwizpzOtc+Ezr/Ovc6/zrzOsc+Dzq/OsVwiLFxuICAgIFwiflJFTkFNRV9ESUFMT0cuQ0FOQ0VMXCI6IFwizpHOus+Nz4HPic+DzrdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWVwiOiBcIs6Rzr3PhM65zrPPgc6xz4bOrlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5WSUVXXCI6IFwizqDPgc6/zrLOv867zq5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ0xPU0VcIjogXCLOms67zrXOr8+DzrnOvM6/XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfU1VDQ0VTU1wiOiBcIs6XIM+AzrvOt8+Bzr/Phs6/z4HOr861z4Igzq3Ph86/z4XOvSDOsc69z4TOuc6zz4HOsc+GzrXOryDPg8+Ezr8gz4DPgc+Mz4fOtc65z4HOvy5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9FUlJPUlwiOiBcIs6bz4XPgM6/z43OvM6xz4PPhM61LCDOv865IM+AzrvOt8+Bzr/Phs6/z4HOr861z4IgzrTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TPjCDOvc6xIM6xzr3PhM65zrPPgc6xz4bOv8+Nzr0gz4PPhM6/IM+Az4HPjM+HzrXOuc+Bzr8uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfVElUTEVcIjogXCLOkc69z4TOuc6zz4HOsc+Gzq4gzpHPgM6/z4TOtc67zq3Pg868zrHPhM6/z4JcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTE9OR0VWSVRZX1dBUk5JTkdcIjogXCLOpM6/IM66zr/Ouc69z4zPh8+BzrfPg8+Ezr8gzrHOvc+Ezq/Os8+BzrHPhs6/z4UgzrHPhc+Ezr/PjSDPhM6/z4UgzrHPgc+HzrXOr86/z4UgzrjOsSDOtM65zrHPhM63z4HOt864zrXOryDOrc+Jz4Igz4zPhM6/z4UgzrTOtc69IM6tz4fOtc65IM+Az4HOv86yzrvOt864zrXOryDOs865zrEgz4DOtc+BzrnPg8+Dz4zPhM61z4HOvyDOsc+Az4wgzq3Ovc6xIM6tz4TOv8+CLlwiLFxuICAgIFwiflNIQVJFX1VQREFURS5USVRMRVwiOiBcIs6XIM6azr/Ouc69z4zPh8+BzrfPg8+EzrcgzqDPgc6/zrLOv867zq4gzpXPgM65zrrOsc65z4HOv8+Azr/Ouc6uzrjOt866zrVcIixcbiAgICBcIn5TSEFSRV9VUERBVEUuTUVTU0FHRVwiOiBcIs6XIM66zr/Ouc69z4zPh8+BzrfPg8+Ezrcgz4DPgc6/zrLOv867zq4gzrXPgM65zrrOsc65z4HOv8+Azr/Ouc6uzrjOt866zrUgzrzOtSDOtc+AzrnPhM+Fz4fOr86xLlwiLFxuICAgIFwifkNPTkZJUk0uT1BFTl9GSUxFXCI6IFwizojPh861z4TOtSDOvM63IM6xz4DOv864zrfOus61z4XOvM6tzr3Otc+CIM6xzrvOu86xzrPOrc+CLiDOlc6vz4PPhM61IM+Dzq/Os86/z4XPgc6/zrkgz4zPhM65IM64zq3Ou861z4TOtSDOvc6xIM6xzr3Ov86vzr7Otc+EzrUgzq3Ovc6xIM69zq3OvyDOrc6zzrPPgc6xz4bOvztcIixcbiAgICBcIn5DT05GSVJNLk5FV19GSUxFXCI6IFwizojPh861z4TOtSDOvM63IM6xz4DOv864zrfOus61z4XOvM6tzr3Otc+CIM6xzrvOu86xzrPOrc+CLiDOlc6vz4PPhM61IM+Dzq/Os86/z4XPgc6/zrkgz4zPhM65IM64zq3Ou861z4TOtSDOvc6xIM60zrfOvM65zr/Phc+BzrPOrs+DzrXPhM61IM6tzr3OsSDOvc6tzr8gzq3Os86zz4HOsc+Gzr87XCIsXG4gICAgXCJ+Q09ORklSTS5BVVRIT1JJWkVfT1BFTlwiOiBcIs6TzrnOsSDPhM6/IM6szr3Ov865zrPOvM6xIM+Ezr/PhSDOtc6zzrPPgc6sz4bOv8+FIM6xz4DOsc65z4TOtc6vz4TOsc65IM6tzrPOus+BzrnPg863LiDOmM6tzrvOtc+EzrUgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861z4TOtSDOvM61IM+EzrfOvSDOrc6zzrrPgc65z4POtztcIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9TQVZFXCI6IFwizpPOuc6xIM+EzrfOvSDOsc+Azr/OuM6uzrrOtc+Fz4POtyDPhM6/z4UgzrXOs86zz4HOrM+Gzr/PhSDOsc+AzrHOuc+EzrXOr8+EzrHOuSDOrc6zzrrPgc65z4POty4gzpjOrc67zrXPhM61IM69zrEgz4PPhc69zrXPh86vz4POtc+EzrUgzrzOtSDPhM63zr0gzq3Os866z4HOuc+Dzrc7XCIsXG4gICAgXCJ+Q09ORklSTS5DTE9TRV9GSUxFXCI6IFwizojPh861z4TOtSDOvM63IM6xz4DOv864zrfOus61z4XOvM6tzr3Otc+CIM6xzrvOu86xzrPOrc+CLiDOlc6vz4PPhM61IM+Dzq/Os86/z4XPgc6/zrkgz4zPhM65IM64zq3Ou861z4TOtSDOvc6xIM66zrvOtc6vz4POtc+EzrUgzrHPhc+Ez4wgz4TOvyDOrc6zzrPPgc6xz4bOvztcIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIs6Vzq/Pg8+EzrUgz4POr86zzr/Phc+Bzr/OuSDPjM+EzrkgzrjOrc67zrXPhM61IM69zrEgzrXPgM6xzr3Osc+Gzq3Pgc61z4TOtSDPhM6/IM6tzrPOs8+BzrHPhs6/IM+Dz4TOt869IM66zrHPhM6sz4PPhM6xz4POtyDPgM6/z4Ugz4TOvyDOsc69zr/Or86+zrHPhM61IM+EzrfOvSDPhM61zrvOtc+Fz4TOsc6vzrEgz4bOv8+Bzqw7XCIsXG4gICAgXCJ+Q09ORklSTS5SRVZFUlRfVE9fU0hBUkVEX1ZJRVdcIjogXCLOlc6vz4PPhM61IM+Dzq/Os86/z4XPgc6/zrkgz4zPhM65IM64zq3Ou861z4TOtSDOvc6xIM61z4DOsc69zrHPhs6tz4HOtc+EzrUgz4TOvyDOrc6zzrPPgc6xz4bOvyDPg8+EzrfOvSDOus6xz4TOrM+Dz4TOsc+Dzrcgz4DOv8+FIM+Ezr8gzrrOv865zr3Ov8+Azr/Ouc6uz4POsc+EzrUgz4TOt869IM+EzrXOu861z4XPhM6xzq/OsSDPhs6/z4HOrDtcIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5USVRMRVwiOiBcIs6Vzq/Pg8+EzrUgz4POr86zzr/Phc+Bzr/OuTtcIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5ZRVNcIjogXCLOnc6xzrlcIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5OT1wiOiBcIs6Mz4fOuVwiLFxuICAgIFwifkxPQ0FMX0ZJTEVfRElBTE9HLkRST1BfRklMRV9IRVJFXCI6IFwizqPPjc+BzrXPhM61IM6tzr3OsSDOsc+Bz4fOtc6vzr8gzrXOtM+OIM6uIM+AzrHPhM6uz4PPhM61IM61zrTPjiDOs865zrEgzr3OsSDOtc+AzrnOu86tzr7Otc+EzrUgzq3Ovc6xIM6xz4HPh861zq/Ovy5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19TRUxFQ1RFRFwiOiBcIs6bz4XPgM6/z43OvM6xz4PPhM61LCDOvM+Azr/Pgc61zq/PhM61IM69zrEgzrXPgM65zrvOrc6+zrXPhM61IM6tzr3OsSDOvM+Mzr3OvyDOsc+Bz4fOtc6vzr8gzrPOuc6xIM69zrEgzrHOvc6/zq/Ovs61z4TOtS5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19EUk9QUEVEXCI6IFwizpvPhc+Azr/Pjc68zrHPg8+EzrUsIM60zrXOvSDOvM+Azr/Pgc61zq/PhM61IM69zrEgz4PPjc+BzrXPhM61IM+AzrXPgc65z4PPg8+Mz4TOtc+BzrEgzrHPgM+MIM6tzr3OsSDOsc+Bz4fOtc6vzrEuXCIsXG4gICAgXCJ+SU1QT1JULkxPQ0FMX0ZJTEVcIjogXCLOpM6/z4DOuc66z4wgzpHPgc+HzrXOr86/XCIsXG4gICAgXCJ+SU1QT1JULlVSTFwiOiBcIlVSTFwiLFxuICAgIFwifklNUE9SVF9VUkwuTVVMVElQTEVfVVJMU19EUk9QUEVEXCI6IFwizpvPhc+Azr/Pjc68zrHPg8+EzrUsIM68z4DOv8+BzrXOr8+EzrUgzr3OsSDOtc+AzrnOu86tzr7Otc+EzrUgzrzPjM69zr8gzq3Ovc6xIHVybCDOs865zrEgzr3OsSDOsc69zr/Or86+zrXPhM61LlwiLFxuICAgIFwifklNUE9SVF9VUkwuUExFQVNFX0VOVEVSX1VSTFwiOiBcIs6gzrHPgc6xzrrOsc67zr/Pjc68zrUgz4DOu863zrrPhM+Bzr/Ou86/zrPOrs+Dz4TOtSDOrc69zrEgdXJsIM6zzrnOsSDOtc65z4POsc6zz4nOs86uLlwiLFxuICAgIFwiflVSTF9UQUIuRFJPUF9VUkxfSEVSRVwiOiBcIs6jz43Pgc61z4TOtSDOrc69zrEgVVJMIM61zrTPjiDOriDPgM67zrfOus+Ez4HOv867zr/Os86uz4PPhM61IM6tzr3OsSBVUkwgz4DOsc+BzrHOus6sz4TPiVwiLFxuICAgIFwiflVSTF9UQUIuSU1QT1JUXCI6IFwizpXOuc+DzrHOs8+JzrPOrlwiLFxuICAgIFwifkNMSUVOVF9FUlJPUi5USVRMRVwiOiBcIs6jz4bOrM67zrzOsVwiLFxuICAgIFwifkFMRVJUX0RJQUxPRy5USVRMRVwiOiBcIs6gz4HOv861zrnOtM6/z4DOv86vzrfPg863XCIsXG4gICAgXCJ+QUxFUlRfRElBTE9HLkNMT1NFXCI6IFwizprOu861zq/Pg865zrzOv1wiLFxuICAgIFwifkFMRVJULk5PX1BST1ZJREVSXCI6IFwizpHPhc+Ezr8gz4TOvyDOsc+Bz4fOtc6vzr8gzrTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TPjCDOvc6xIM6xzr3Ov865z4fPhM61zq8gzrTOuc+Mz4TOuSDOtM61zr0gzrXOr869zrHOuSDOtM65zrHOuM6tz4POuc68zr/PgiDOvyDOus6xz4TOrM67zrvOt867zr/PgiDPgM6sz4HOv8+Hzr/Pgi5cIixcbiAgICBcIn5HT09HTEVfRFJJVkUuTE9HSU5fQlVUVE9OX0xBQkVMXCI6IFwizpXOr8+Dzr/OtM6/z4Igz4PPhM6/IEdvb2dsZVwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5DT05ORUNUSU5HX01FU1NBR0VcIjogXCLOo8+Nzr3OtM61z4POtyDPg8+Ezr8gR29vZ2xlLi4uXCIsXG4gICAgXCJ+R09PR0xFX0RSSVZFLkVSUk9SX01JU1NJTkdfQ0xJRU5USURcIjogXCLOlM61zr0gzrTPjM64zrfOus61IM63IM6xz4DOsc+BzrHOr8+EzrfPhM63IM+EzrHPhc+Ez4zPhM63z4TOsSDPh8+Bzq7Pg8+Ezrcgz4PPhGnPgiDOtc+AzrnOu86/zrPOrc+CIM+AzrHPgc+Mz4fOv8+FIM+Ezr/PhSBnb29nbGVEcml2ZVwiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfNDAzX0VSUk9SXCI6IFwizpTOtc69IM6tz4fOtc+EzrUgzrTOuc66zrHOr8+JzrzOsSDPhs+Mz4HPhM+Jz4POt8+CIM+Ezr/PhSAle2ZpbGVuYW1lfS48YnI+PGJyPs6xzr0gz4fPgc63z4POuc68zr/PgM6/zrnOtc6vz4TOtSDOus6/zrnOvc+Mz4fPgc63z4PPhM6/IM6tzrPOs8+BzrHPhs6/IM66zqzPgM6/zrnOv8+FIM6szrvOu86/z4UsIM61zq/Ovc6xzrkgz4DOuc64zrHOvc+MIM69zrEgzq3Ph861zrkgzrTOuc6xzrrOv8+AzrXOryDOtyDOus6/zrnOvc6uIM+Hz4HOrs+DzrcuXCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF9TSEFSRURfNDA0X0VSUk9SXCI6IFwizpTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TOriDOtyDPhs+Mz4HPhM+Jz4POtyDPhM6/z4UgzrrOv865zr3PjM+Hz4HOt8+Dz4TOv8+FIM6xz4HPh861zq/Ov8+FIM+Azr/PhSDOts63z4TOrs+DzrHPhM61Ljxicj48YnI+zorPg8+Jz4Igzr3OsSDOvM63zr0gzq3Os865zr3OtSDOus6/zrnOvc6uIM+Hz4HOrs+Dzrcgz4TOv8+FIM6xz4HPh861zq/Ov8+FO1wiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfNDA0X0VSUk9SXCI6IFwizpTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TOriDOtyDPhs+Mz4HPhM+Jz4POtyDPhM6/z4UgJXtmaWxlbmFtZX1cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiOiBcIs6UzrXOvSDOrc+HzrXPhM61IM60zrnOus6xzq/Pic68zrEgzrHPgM6/zrjOrs66zrXPhc+DzrfPgiDPhM6/z4UgJyV7ZmlsZW5hbWV9Jy48YnI+PGJyPs6Kz4PPic+CIM+Hz4HOtc65zqzOts61z4TOtSDOvc6xIM6+zrHOvc6xz4PPhc69zrTOtc64zrXOr8+EzrUuXCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV9EVVBMSUNBVEVfRVJST1JcIjogXCLOlM61zr0gzq7PhM6xzr0gzrTPhc69zrHPhM6uIM63IM60zrfOvM65zr/Phc+BzrPOr86xIM+Ezr/PhSAle2ZpbGVuYW1lfS4gzqTOvyDOsc+Bz4fOtc6vzr8gz4XPgM6sz4HPh861zrkgzq7OtM63LlwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JfV0lUSF9NRVNTQUdFXCI6IFwizpTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TOriDOtyDOsc+Azr/OuM6uzrrOtc+Fz4POtyDPhM6/z4UgJXtmaWxlbmFtZX06IFsle21lc3NhZ2V9XVwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JcIjogXCLOlM61zr0gzq7PhM6xzr0gzrTPhc69zrHPhM6uIM63IM6xz4DOv864zq7Ous61z4XPg863IM+Ezr/PhSAle2ZpbGVuYW1lfVwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV80MDNfRVJST1JcIjogXCLOlM61zr0gzq3Ph861z4TOtSDOtM65zrrOsc6vz4nOvM6xIM60zrnOsc6zz4HOsc+Gzq7PgiDPhM6/z4UgJyV7ZmlsZW5hbWV9Jy48YnI+PGJyPs6Kz4PPic+CIM+Hz4HOtc65zqzOts61z4TOtSDOvc6xIM6+zrHOvc6xz4PPhc69zrTOtc64zrXOr8+EzrUuIFwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV9FUlJPUlwiOiBcIs6UzrXOvSDOrs+EzrHOvSDOtM+Fzr3Osc+Ezq4gzrcgzrTOuc6xzrPPgc6xz4bOriDPhM6/z4UgJXtmaWxlbmFtZX0gXCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FXzQwM19FUlJPUlwiOiBcIs6UzrXOvSDOrc+HzrXPhM61IM60zrnOus6xzq/Pic68zrEgzrzOtc+Ezr/Ovc6/zrzOsc+Dzq/Osc+CIM+Ezr/PhSAnJXtmaWxlbmFtZX0nLjxicj48YnI+zorPg8+Jz4Igz4fPgc61zrnOrM62zrXPhM61IM69zrEgzr7Osc69zrHPg8+Fzr3OtM61zrjOtc6vz4TOtS4gXCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FX0VSUk9SXCI6IFwizpTOtc69IM6uz4TOsc69IM60z4XOvc6xz4TOriDOtyDOvM61z4TOv869zr/OvM6xz4POr86xIM+Ezr/PhSAle2ZpbGVuYW1lfSBcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fU0FWRV9USVRMRVwiOiBcIs6gz4HOv861zrnOtM6/z4DOv86vzrfPg863IENvbmNvcmQgQ2xvdWRcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkFMRVJUX1NBVkVfVElUTEVcIjogXCLOoM+Bzr/Otc65zrTOv8+Azr/Or863z4POtyBDb25jb3JkIENsb3VkXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfRUxTRVdIRVJFXCI6IFwizpHPgM6/zrjOrs66zrXPhc+DzrcgzpHOu867zr/PjVwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9ET19JVF9MQVRFUlwiOiBcIs6YzrEgz4TOvyDOus6szr3PiSDOsc+BzrPPjM+EzrXPgc6xXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5TSFVUX0RPV05fTUVTU0FHRVwiOiBcIs6kzr8gQ29uY29yZCBDbG91ZCDOrc+HzrXOuSDOus67zrXOr8+DzrXOuSFcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLlBMRUFTRV9TQVZFX0VMU0VXSEVSRVwiOiBcIs6gzrHPgc6xzrrOsc67zr/Pjc68zrUgzrHPgM6/zrjOt866zrXPjc+Dz4TOtSDPhM6xIM6tzrPOs8+BzrHPhs6sIM+DzrHPgiDPg861IM6szrvOu863IM+Ezr/PgM6/zrjOtc+Dzq/OsS5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVcIjogXCLOms6/zrnOvc+Mz4fPgc63z4PPhM63IM+Az4HOv86yzr/Ou86uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFX0VOQUJMRURcIjogXCLOtc69zrXPgc6zzr/PgM6/zrnOt868zq3Ovc63XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFX0RJU0FCTEVEXCI6IFwizrHPgM61zr3Otc+BzrPOv8+Azr/Ouc63zrzOrc69zrdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdcIjogXCLOlc69zrXPgc6zzr/PgM6/zq/Ot8+DzrcgzrrOv865zr3Ors+CIM+Hz4HOrs+DzrfPglwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TVE9QX1NIQVJJTkdcIjogXCLOlM65zrHOus6/z4DOriDOus6/zrnOvc6uz4Igz4fPgc6uz4POt8+CXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlVQREFURV9TSEFSSU5HXCI6IFwizpXPgM65zrrOsc65z4HOv8+Azr/Or863z4POtyDOus6/zrnOvc+Mz4fPgc63z4PPhM63z4Igz4DPgc6/zrLOv867zq7PglwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5QUkVWSUVXX1NIQVJJTkdcIjogXCLOoM+Bzr/Otc+AzrnPg866z4zPgM63z4POtyDOus6/zrnOvc+Mz4fPgc63z4PPhM63z4Igz4DPgc6/zrLOv867zq7PglwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTkFCTEVfU0hBUklOR19NRVNTQUdFXCI6IFwizozPhM6xzr0gzrXOvc61z4HOs86/z4DOv865zrXOr8+EzrHOuSDOtyDOus6/zrnOvc6uIM+Hz4HOrs+DzrcsIM60zrfOvM65zr/Phc+BzrPOtc6vz4TOsc65IM6tzr3OsSDOsc69z4TOr86zz4HOsc+Gzr8gz4TOt8+CIM+Dz4XOs866zrXOus+BzrnOvM6tzr3Ot8+CIM+Az4HOv86yzr/Ou86uz4IuIM6Rz4XPhM+MIM+Ezr8gzrHOvc+Ezq/Os8+BzrHPhs6/IM68z4DOv8+BzrXOryDOvc6xIM66zr/Ouc69zr/PgM6/zrnOt864zrXOry5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTElOS19UQUJcIjogXCLOo8+Nzr3OtM61z4POvM6/z4JcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTElOS19NRVNTQUdFXCI6IFwizpXPgM65zrrOv867zrvOrs+Dz4TOtSDPhM6/IM+DzrUgzq3Ovc6xIGVtYWlsIM6uIM6tzr3OsSDOvM6uzr3Phc68zrEgzrrOtc65zrzOrc69zr/PhVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9UQUJcIjogXCLOlc69z4PPic68zqzPhM+Jz4POt1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9NRVNTQUdFXCI6IFwizprPjs60zrnOus6xz4IgzrPOuc6xIM61zr3Pg8+JzrzOrM+Ez4nPg863IM+DzrUgzrnPg8+Ezr/Pg861zrvOr860zrXPgiDOriDOrM67zrvOvyDOtM65zrrPhM+FzrHOus+MIM+AzrXPgc65zrXPh8+MzrzOtc69zr9cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCI6IFwizqfPgc63z4POuc68zr/PgM6/zrnOrs+Dz4TOtSDOsc+Fz4TPjCDPhM6/IM+Dz43Ovc60zrXPg868zr8gz4zPhM6xzr0gzrTOt868zrnOv8+Fz4HOs861zq/PhM61IM68zrnOsSDOtM+BzrHPg8+EzrfPgc65z4zPhM63z4TOsSDPg8+Ezr8gTEFSQVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0NPREFQX1VSTFwiOiBcIlVSTCDPhM6/z4UgzrTOuc6xzrrOv868zrnPg8+Ezq4gQ09EQVA6XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfQVVUT0xBVU5DSF9QQUdFXCI6IFwizqPOtc67zq/OtM6xIM6xz4XPhM+MzrzOsc+EzrfPgiDOtc66z4TOrc67zrXPg863z4JcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9GVUxMU0NSRUVOX0JVVFRPTl9BTkRfU0NBTElOR1wiOiBcIs6gzrvOrs66z4TPgc6/IM+AzrvOrs+Bzr/Phc+CIM6/zrjPjM69zrfPgiDOus6xzrkgzrrOu865zrzOrM66z4nPg863XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfTEFVTkNIX0JVVFRPTl9URVhUXCI6IFwizprOtc6vzrzOtc69zr8gzqDOu86uzrrPhM+Bzr/PhSDOlc66z4TOrc67zrXPg863z4JcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9ESVNQTEFZX1ZJU0lCSUxJVFlfVE9HR0xFU1wiOiBcIs6XIM+Az4HOv86yzr/Ou86uIM60zrXOtM6/zrzOrc69z4nOvSDOtc69zrXPgc6zzr/PgM6/zrnOtc6vIM+EzrEgzrPPgc6xz4bOrs68zrHPhM6xXCIsXG4gICAgXCJ+Q09ORklSTS5DSEFOR0VfTEFOR1VBR0VcIjogXCLOiM+HzrXPhM61IM68zrcgzrHPgM6/zrjOt866zrXPhc68zq3Ovc61z4IgzrHOu867zrHOs86tz4IuIM6Vzq/Pg8+EzrUgz4POr86zzr/Phc+Bzr/OuSDPjM+EzrkgzrjOrc67zrXPhM61IM69zrEgzrHOu867zqzOvs61z4TOtSDOs867z47Pg8+DzrE7XCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwifk1FTlVCQVIuVU5USVRMRURfRE9DVU1FTlRcIjogXCJVbnRpdGxlZCBEb2N1bWVudFwiLFxuXG4gIFwifk1FTlUuTkVXXCI6IFwiTmV3XCIsXG4gIFwifk1FTlUuT1BFTlwiOiBcIk9wZW4gLi4uXCIsXG4gIFwifk1FTlUuQ0xPU0VcIjogXCJDbG9zZVwiLFxuICBcIn5NRU5VLklNUE9SVF9EQVRBXCI6IFwiSW1wb3J0IGRhdGEuLi5cIixcbiAgXCJ+TUVOVS5TQVZFXCI6IFwiU2F2ZVwiLFxuICBcIn5NRU5VLlNBVkVfQVNcIjogXCJTYXZlIEFzIC4uLlwiLFxuICBcIn5NRU5VLkVYUE9SVF9BU1wiOiBcIkV4cG9ydCBGaWxlIEFzIC4uLlwiLFxuICBcIn5NRU5VLkNSRUFURV9DT1BZXCI6IFwiQ3JlYXRlIGEgY29weVwiLFxuICBcIn5NRU5VLlNIQVJFXCI6IFwiU2hhcmUuLi5cIixcbiAgXCJ+TUVOVS5TSEFSRV9HRVRfTElOS1wiOiBcIkdldCBsaW5rIHRvIHNoYXJlZCB2aWV3XCIsXG4gIFwifk1FTlUuU0hBUkVfVVBEQVRFXCI6IFwiVXBkYXRlIHNoYXJlZCB2aWV3XCIsXG4gIFwifk1FTlUuRE9XTkxPQURcIjogXCJEb3dubG9hZFwiLFxuICBcIn5NRU5VLlJFTkFNRVwiOiBcIlJlbmFtZVwiLFxuICBcIn5NRU5VLlJFVkVSVF9UT1wiOiBcIlJldmVydCB0by4uLlwiLFxuICBcIn5NRU5VLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIlJlY2VudGx5IG9wZW5lZCBzdGF0ZVwiLFxuICBcIn5NRU5VLlJFVkVSVF9UT19TSEFSRURfVklFV1wiOiBcIlNoYXJlZCB2aWV3XCIsXG5cbiAgXCJ+RElBTE9HLlNBVkVcIjogXCJTYXZlXCIsXG4gIFwifkRJQUxPRy5TQVZFX0FTXCI6IFwiU2F2ZSBBcyAuLi5cIixcbiAgXCJ+RElBTE9HLkVYUE9SVF9BU1wiOiBcIkV4cG9ydCBGaWxlIEFzIC4uLlwiLFxuICBcIn5ESUFMT0cuQ1JFQVRFX0NPUFlcIjogXCJDcmVhdGUgQSBDb3B5IC4uLlwiLFxuICBcIn5ESUFMT0cuT1BFTlwiOiBcIk9wZW5cIixcbiAgXCJ+RElBTE9HLkRPV05MT0FEXCI6IFwiRG93bmxvYWRcIixcbiAgXCJ+RElBTE9HLlJFTkFNRVwiOiBcIlJlbmFtZVwiLFxuICBcIn5ESUFMT0cuU0hBUkVEXCI6IFwiU2hhcmVcIixcbiAgXCJ+RElBTE9HLklNUE9SVF9EQVRBXCI6IFwiSW1wb3J0IERhdGFcIixcblxuICBcIn5QUk9WSURFUi5MT0NBTF9TVE9SQUdFXCI6IFwiTG9jYWwgU3RvcmFnZVwiLFxuICBcIn5QUk9WSURFUi5SRUFEX09OTFlcIjogXCJSZWFkIE9ubHlcIixcbiAgXCJ+UFJPVklERVIuR09PR0xFX0RSSVZFXCI6IFwiR29vZ2xlIERyaXZlXCIsXG4gIFwiflBST1ZJREVSLkRPQ1VNRU5UX1NUT1JFXCI6IFwiQ29uY29yZCBDbG91ZFwiLFxuICBcIn5QUk9WSURFUi5MT0NBTF9GSUxFXCI6IFwiTG9jYWwgRmlsZVwiLFxuXG4gIFwifkZJTEVfU1RBVFVTLlNBVklOR1wiOiBcIlNhdmluZy4uLlwiLFxuICBcIn5GSUxFX1NUQVRVUy5TQVZFRFwiOiBcIkFsbCBjaGFuZ2VzIHNhdmVkXCIsXG4gIFwifkZJTEVfU1RBVFVTLlNBVkVEX1RPX1BST1ZJREVSXCI6IFwiQWxsIGNoYW5nZXMgc2F2ZWQgdG8gJXtwcm92aWRlck5hbWV9XCIsXG4gIFwifkZJTEVfU1RBVFVTLlVOU0FWRURcIjogXCJVbnNhdmVkXCIsXG5cbiAgXCJ+RklMRV9ESUFMT0cuRklMRU5BTUVcIjogXCJGaWxlbmFtZVwiLFxuICBcIn5GSUxFX0RJQUxPRy5PUEVOXCI6IFwiT3BlblwiLFxuICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwiU2F2ZVwiLFxuICBcIn5GSUxFX0RJQUxPRy5DQU5DRUxcIjogXCJDYW5jZWxcIixcbiAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCI6IFwiRGVsZXRlXCIsXG4gIFwifkZJTEVfRElBTE9HLlJFTU9WRV9DT05GSVJNXCI6IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSAle2ZpbGVuYW1lfT9cIixcbiAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiOiBcIkRlbGV0ZWQgRmlsZVwiLFxuICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVEX01FU1NBR0VcIjogXCIle2ZpbGVuYW1lfSB3YXMgZGVsZXRlZFwiLFxuICBcIn5GSUxFX0RJQUxPRy5MT0FESU5HXCI6IFwiTG9hZGluZy4uLlwiLFxuICBcIn5GSUxFX0RJQUxPRy5MT0FEX0ZPTERFUl9FUlJPUlwiOiBcIioqKiBFcnJvciBsb2FkaW5nIGZvbGRlciBjb250ZW50cyAqKipcIixcbiAgXCJ+RklMRV9ESUFMT0cuRE9XTkxPQURcIjogXCJEb3dubG9hZFwiLFxuICBcIn5GSUxFX0RJQUxPRy5ET1dOTE9BRF9OT1RFXCI6IFwiTk9URTogT24gU2FmYXJpIGZpbGUgbWF5IGJlIFxcXCJVbmtub3duXFxcIiBhbmQgc2hvdWxkIGJlIG1hbnVhbGx5IHJlbmFtZWQgd2l0aCBhIC5jb2RhcCBleHRlbnNpb24uXCIsXG5cblxuICBcIn5ET1dOTE9BRF9ESUFMT0cuRE9XTkxPQURcIjogXCJEb3dubG9hZFwiLFxuICBcIn5ET1dOTE9BRF9ESUFMT0cuQ0FOQ0VMXCI6IFwiQ2FuY2VsXCIsXG4gIFwifkRPV05MT0FEX0RJQUxPRy5JTkNMVURFX1NIQVJFX0lORk9cIjogXCJJbmNsdWRlIHNoYXJpbmcgaW5mb3JtYXRpb24gaW4gZG93bmxvYWRlZCBmaWxlXCIsXG5cbiAgXCJ+UkVOQU1FX0RJQUxPRy5SRU5BTUVcIjogXCJSZW5hbWVcIixcbiAgXCJ+UkVOQU1FX0RJQUxPRy5DQU5DRUxcIjogXCJDYW5jZWxcIixcblxuICBcIn5TSEFSRV9ESUFMT0cuQ09QWVwiOiBcIkNvcHlcIixcbiAgXCJ+U0hBUkVfRElBTE9HLlZJRVdcIjogXCJWaWV3XCIsXG4gIFwiflNIQVJFX0RJQUxPRy5DTE9TRVwiOiBcIkNsb3NlXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5DT1BZX1NVQ0NFU1NcIjogXCJUaGUgaW5mbyBoYXMgYmVlbiBjb3BpZWQgdG8gdGhlIGNsaXBib2FyZC5cIixcbiAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfRVJST1JcIjogXCJTb3JyeSwgdGhlIGluZm8gd2FzIG5vdCBhYmxlIHRvIGJlIGNvcGllZCB0byB0aGUgY2xpcGJvYXJkLlwiLFxuICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9USVRMRVwiOiBcIkNvcHkgUmVzdWx0XCIsXG4gIFwiflNIQVJFX0RJQUxPRy5MT05HRVZJVFlfV0FSTklOR1wiOiBcIlRoZSBzaGFyZWQgY29weSBvZiB0aGlzIGRvY3VtZW50IHdpbGwgYmUgcmV0YWluZWQgdW50aWwgaXQgaGFzIG5vdCBiZWVuIGFjY2Vzc2VkIGZvciBvdmVyIGEgeWVhci5cIixcblxuICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVcIjogXCJTaGFyZWQgdmlldzogXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9FTkFCTEVEXCI6IFwiZW5hYmxlZFwiLFxuICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVfRElTQUJMRURcIjogXCJkaXNhYmxlZFwiLFxuICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdcIjogXCJFbmFibGUgc2hhcmluZ1wiLFxuICBcIn5TSEFSRV9ESUFMT0cuU1RPUF9TSEFSSU5HXCI6IFwiU3RvcCBzaGFyaW5nXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5VUERBVEVfU0hBUklOR1wiOiBcIlVwZGF0ZSBzaGFyZWQgdmlld1wiLFxuICBcIn5TSEFSRV9ESUFMT0cuUFJFVklFV19TSEFSSU5HXCI6IFwiUHJldmlldyBzaGFyZWQgdmlld1wiLFxuICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdfTUVTU0FHRVwiOiBcIldoZW4gc2hhcmluZyBpcyBlbmFibGVkLCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlldyBpcyBjcmVhdGVkLiAgVGhpcyBjb3B5IGNhbiBiZSBzaGFyZWQuXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5MSU5LX1RBQlwiOiBcIkxpbmtcIixcbiAgXCJ+U0hBUkVfRElBTE9HLkxJTktfTUVTU0FHRVwiOiBcIlBhc3RlIHRoaXMgaW50byBhbiBlbWFpbCBvciB0ZXh0IG1lc3NhZ2UgXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9UQUJcIjogXCJFbWJlZFwiLFxuICBcIn5TSEFSRV9ESUFMT0cuRU1CRURfTUVTU0FHRVwiOiBcIkVtYmVkIGNvZGUgZm9yIGluY2x1ZGluZyBpbiB3ZWJwYWdlcyBvciBvdGhlciB3ZWItYmFzZWQgY29udGVudFwiLFxuICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCI6IFwiVXNlIHRoaXMgbGluayB3aGVuIGNyZWF0aW5nIGFuIGFjdGl2aXR5IGluIExBUkFcIixcbiAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfQ09EQVBfVVJMXCI6IFwiQ09EQVAgU2VydmVyIFVSTDpcIixcbiAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfQVVUT0xBVU5DSF9QQUdFXCI6IFwiQXV0b2xhdW5jaCBwYWdlXCIsXG4gIFwiflNIQVJFX0RJQUxPRy5MQVJBX0ZVTExTQ1JFRU5fQlVUVE9OX0FORF9TQ0FMSU5HXCI6IFwiRnVsbHNjcmVlbiBidXR0b24gYW5kIHNjYWxpbmdcIixcbiAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfTEFVTkNIX0JVVFRPTl9URVhUXCI6IFwiTGF1bmNoIEJ1dHRvbiBUZXh0OlwiLFxuICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9ESVNQTEFZX1ZJU0lCSUxJVFlfVE9HR0xFU1wiOiBcIkRpc3BsYXkgZGF0YSB2aXNpYmlsaXR5IHRvZ2dsZXMgb24gZ3JhcGhzXCIsXG5cbiAgXCJ+U0hBUkVfVVBEQVRFLlRJVExFXCI6IFwiU2hhcmVkIFZpZXcgVXBkYXRlZFwiLFxuICBcIn5TSEFSRV9VUERBVEUuTUVTU0FHRVwiOiBcIlRoZSBzaGFyZWQgdmlldyB3YXMgdXBkYXRlZCBzdWNjZXNzZnVsbHkuXCIsXG5cbiAgXCJ+Q09ORklSTS5PUEVOX0ZJTEVcIjogXCJZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMuIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBvcGVuIGEgbmV3IGRvY3VtZW50P1wiLFxuICBcIn5DT05GSVJNLk5FV19GSUxFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY3JlYXRlIGEgbmV3IGRvY3VtZW50P1wiLFxuICBcIn5DT05GSVJNLkFVVEhPUklaRV9PUEVOXCI6IFwiQXV0aG9yaXphdGlvbiBpcyByZXF1aXJlZCB0byBvcGVuIHRoZSBkb2N1bWVudC4gV291bGQgeW91IGxpa2UgdG8gcHJvY2VlZCB3aXRoIGF1dGhvcml6YXRpb24/XCIsXG4gIFwifkNPTkZJUk0uQVVUSE9SSVpFX1NBVkVcIjogXCJBdXRob3JpemF0aW9uIGlzIHJlcXVpcmVkIHRvIHNhdmUgdGhlIGRvY3VtZW50LiBXb3VsZCB5b3UgbGlrZSB0byBwcm9jZWVkIHdpdGggYXV0aG9yaXphdGlvbj9cIixcbiAgXCJ+Q09ORklSTS5DTE9TRV9GSUxFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2xvc2UgdGhlIGRvY3VtZW50P1wiLFxuICBcIn5DT05GSVJNLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXZlcnQgdGhlIGRvY3VtZW50IHRvIGl0cyBtb3N0IHJlY2VudGx5IG9wZW5lZCBzdGF0ZT9cIixcbiAgXCJ+Q09ORklSTS5SRVZFUlRfVE9fU0hBUkVEX1ZJRVdcIjogXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcmV2ZXJ0IHRoZSBkb2N1bWVudCB0byBpdHMgbW9zdCByZWNlbnRseSBzaGFyZWQgc3RhdGU/XCIsXG4gIFwifkNPTkZJUk0uQ0hBTkdFX0xBTkdVQUdFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2hhbmdlIGxhbmd1YWdlcz9cIixcblxuICBcIn5DT05GSVJNX0RJQUxPRy5USVRMRVwiOiBcIkFyZSB5b3Ugc3VyZT9cIixcbiAgXCJ+Q09ORklSTV9ESUFMT0cuWUVTXCI6IFwiWWVzXCIsXG4gIFwifkNPTkZJUk1fRElBTE9HLk5PXCI6IFwiTm9cIixcblxuICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5EUk9QX0ZJTEVfSEVSRVwiOiBcIkRyb3AgZmlsZSBoZXJlIG9yIGNsaWNrIGhlcmUgdG8gc2VsZWN0IGEgZmlsZS5cIixcbiAgXCJ+TE9DQUxfRklMRV9ESUFMT0cuTVVMVElQTEVfRklMRVNfU0VMRUNURURcIjogXCJTb3JyeSwgeW91IGNhbiBjaG9vc2Ugb25seSBvbmUgZmlsZSB0byBvcGVuLlwiLFxuICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19EUk9QUEVEXCI6IFwiU29ycnksIHlvdSBjYW4ndCBkcm9wIG1vcmUgdGhhbiBvbmUgZmlsZS5cIixcblxuICBcIn5JTVBPUlQuTE9DQUxfRklMRVwiOiBcIkxvY2FsIEZpbGVcIixcbiAgXCJ+SU1QT1JULlVSTFwiOiBcIlVSTFwiLFxuXG4gIFwifklNUE9SVF9VUkwuTVVMVElQTEVfVVJMU19EUk9QUEVEXCI6IFwiU29ycnksIHlvdSBjYW4gY2hvb3NlIG9ubHkgb25lIHVybCB0byBvcGVuLlwiLFxuICBcIn5JTVBPUlRfVVJMLlBMRUFTRV9FTlRFUl9VUkxcIjogXCJQbGVhc2UgZW50ZXIgYSB1cmwgdG8gaW1wb3J0LlwiLFxuXG4gIFwiflVSTF9UQUIuRFJPUF9VUkxfSEVSRVwiOiBcIkRyb3AgVVJMIGhlcmUgb3IgZW50ZXIgVVJMIGJlbG93XCIsXG4gIFwiflVSTF9UQUIuSU1QT1JUXCI6IFwiSW1wb3J0XCIsXG5cbiAgXCJ+Q0xJRU5UX0VSUk9SLlRJVExFXCI6IFwiRXJyb3JcIixcblxuICBcIn5BTEVSVF9ESUFMT0cuVElUTEVcIjogXCJBbGVydFwiLFxuICBcIn5BTEVSVF9ESUFMT0cuQ0xPU0VcIjogXCJDbG9zZVwiLFxuXG4gIFwifkFMRVJULk5PX1BST1ZJREVSXCI6IFwiQ291bGQgbm90IG9wZW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudCBiZWNhdXNlIGFuIGFwcHJvcHJpYXRlIHByb3ZpZGVyIGlzIG5vdCBhdmFpbGFibGUuXCIsXG5cbiAgXCJ+R09PR0xFX0RSSVZFLkxPR0lOX0JVVFRPTl9MQUJFTFwiOiBcIkxvZ2luIHRvIEdvb2dsZVwiLFxuICBcIn5HT09HTEVfRFJJVkUuQ09OTkVDVElOR19NRVNTQUdFXCI6IFwiQ29ubmVjdGluZyB0byBHb29nbGUuLi5cIixcbiAgXCJ+R09PR0xFX0RSSVZFLkVSUk9SX01JU1NJTkdfQ0xJRU5USURcIjogXCJNaXNzaW5nIHJlcXVpcmVkIGNsaWVudElkIGluIGdvb2dsZURyaXZlIHByb3ZpZGVyIG9wdGlvbnNcIixcblxuICBcIn5ET0NTVE9SRS5MT0FEXzQwM19FUlJPUlwiOiBcIllvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gbG9hZCAle2ZpbGVuYW1lfS48YnI+PGJyPklmIHlvdSBhcmUgdXNpbmcgc29tZSBlbHNlJ3Mgc2hhcmVkIGRvY3VtZW50IGl0IG1heSBoYXZlIGJlZW4gdW5zaGFyZWQuXCIsXG4gIFwifkRPQ1NUT1JFLkxPQURfU0hBUkVEXzQwNF9FUlJPUlwiOiBcIlVuYWJsZSB0byBsb2FkIHRoZSByZXF1ZXN0ZWQgc2hhcmVkIGRvY3VtZW50Ljxicj48YnI+UGVyaGFwcyB0aGUgZmlsZSB3YXMgbm90IHNoYXJlZD9cIixcbiAgXCJ+RE9DU1RPUkUuTE9BRF80MDRfRVJST1JcIjogXCJVbmFibGUgdG8gbG9hZCAle2ZpbGVuYW1lfVwiLFxuICBcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiOiBcIllvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gc2F2ZSAnJXtmaWxlbmFtZX0nLjxicj48YnI+WW91IG1heSBuZWVkIHRvIGxvZyBpbiBhZ2Fpbi5cIixcbiAgXCJ+RE9DU1RPUkUuU0FWRV9EVVBMSUNBVEVfRVJST1JcIjogXCJVbmFibGUgdG8gY3JlYXRlICV7ZmlsZW5hbWV9LiAgRmlsZSBhbHJlYWR5IGV4aXN0cy5cIixcbiAgXCJ+RE9DU1RPUkUuU0FWRV9FUlJPUl9XSVRIX01FU1NBR0VcIjogXCJVbmFibGUgdG8gc2F2ZSAle2ZpbGVuYW1lfTogWyV7bWVzc2FnZX1dXCIsXG4gIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JcIjogXCJVbmFibGUgdG8gc2F2ZSAle2ZpbGVuYW1lfVwiLFxuICBcIn5ET0NTVE9SRS5SRU1PVkVfNDAzX0VSUk9SXCI6IFwiWW91IGRvbid0IGhhdmUgcGVybWlzc2lvbiB0byByZW1vdmUgJXtmaWxlbmFtZX0uPGJyPjxicj5Zb3UgbWF5IG5lZWQgdG8gbG9nIGluIGFnYWluLlwiLFxuICBcIn5ET0NTVE9SRS5SRU1PVkVfRVJST1JcIjogXCJVbmFibGUgdG8gcmVtb3ZlICV7ZmlsZW5hbWV9XCIsXG4gIFwifkRPQ1NUT1JFLlJFTkFNRV80MDNfRVJST1JcIjogXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHJlbmFtZSAle2ZpbGVuYW1lfS48YnI+PGJyPllvdSBtYXkgbmVlZCB0byBsb2cgaW4gYWdhaW4uXCIsXG4gIFwifkRPQ1NUT1JFLlJFTkFNRV9FUlJPUlwiOiBcIlVuYWJsZSB0byByZW5hbWUgJXtmaWxlbmFtZX1cIixcblxuICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fU0FWRV9USVRMRVwiOiBcIkNvbmNvcmQgQ2xvdWQgQWxlcnRcIixcbiAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5BTEVSVF9TQVZFX1RJVExFXCI6IFwiQ29uY29yZCBDbG91ZCBBbGVydFwiLFxuICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fU0FWRV9FTFNFV0hFUkVcIjogXCJTYXZlIEVsc2V3aGVyZVwiLFxuICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fRE9fSVRfTEFURVJcIjogXCJJJ2xsIGRvIGl0IGxhdGVyXCIsXG4gIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uU0hVVF9ET1dOX01FU1NBR0VcIjogXCJUaGUgQ29uY29yZCBDbG91ZCBoYXMgYmVlbiBzaHV0IGRvd24hXCIsXG4gIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uUExFQVNFX1NBVkVfRUxTRVdIRVJFXCI6IFwiUGxlYXNlIHNhdmUgeW91ciBkb2N1bWVudHMgdG8gYW5vdGhlciBsb2NhdGlvbi5cIlxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJ+TUVOVUJBUi5VTlRJVExFRF9ET0NVTUVOVFwiOiBcIkRvY3VtZW50byBzaW4gdMOtdHVsb1wiLFxuICAgIFwifk1FTlUuTkVXXCI6IFwiTnVldm9cIixcbiAgICBcIn5NRU5VLk9QRU5cIjogXCJBYnJpciAuLi5cIixcbiAgICBcIn5NRU5VLkNMT1NFXCI6IFwiQ2VycmFyXCIsXG4gICAgXCJ+TUVOVS5JTVBPUlRfREFUQVwiOiBcIkltcG9ydGFyIGRhdG9zLi4uXCIsXG4gICAgXCJ+TUVOVS5TQVZFXCI6IFwiR3VhcmRhclwiLFxuICAgIFwifk1FTlUuU0FWRV9BU1wiOiBcIkd1YXJkYXIgY29tbyAuLi5cIixcbiAgICBcIn5NRU5VLkVYUE9SVF9BU1wiOiBcIkV4cG9ydGFyIGFyY2hpdm8gY29tbyAuLi5cIixcbiAgICBcIn5NRU5VLkNSRUFURV9DT1BZXCI6IFwiQ3JlYXIgdW5hIGNvcGlhXCIsXG4gICAgXCJ+TUVOVS5TSEFSRVwiOiBcIkNvbXBhcnRpci4uLlwiLFxuICAgIFwifk1FTlUuU0hBUkVfR0VUX0xJTktcIjogXCJPYnRlbmVyIGVubGFjZSBkZSBsYSB2aXN0YSBjb21wYXJ0aWRhXCIsXG4gICAgXCJ+TUVOVS5TSEFSRV9VUERBVEVcIjogXCJBY3R1YWxpemFyIHZpc3RhIGNvbXBhcnRpZGFcIixcbiAgICBcIn5NRU5VLkRPV05MT0FEXCI6IFwiQmFqYXJcIixcbiAgICBcIn5NRU5VLlJFTkFNRVwiOiBcIlJlbm9tYnJhclwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPXCI6IFwiUmV2ZXJ0aXIgYS4uLlwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCI6IFwiRXN0YWRvIHJlY2llbnRlbWVudGUgYWJpZXJ0b1wiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwiVmlzdGEgY29tcGFydGlkYVwiLFxuICAgIFwifkRJQUxPRy5TQVZFXCI6IFwiR3VhcmRhclwiLFxuICAgIFwifkRJQUxPRy5TQVZFX0FTXCI6IFwiR3VhcmRhciBjb21vIC4uLlwiLFxuICAgIFwifkRJQUxPRy5FWFBPUlRfQVNcIjogXCJFeHBvcnRhciBhcmNoaXZvIGNvbW8gLi4uXCIsXG4gICAgXCJ+RElBTE9HLkNSRUFURV9DT1BZXCI6IFwiQ3JlYXIgdW5hIGNvcGlhIC4uLlwiLFxuICAgIFwifkRJQUxPRy5PUEVOXCI6IFwiQWJyaXJcIixcbiAgICBcIn5ESUFMT0cuRE9XTkxPQURcIjogXCJCYWphclwiLFxuICAgIFwifkRJQUxPRy5SRU5BTUVcIjogXCJSZW5vbWJyYXJcIixcbiAgICBcIn5ESUFMT0cuU0hBUkVEXCI6IFwiQ29tcGFydGlyXCIsXG4gICAgXCJ+RElBTE9HLklNUE9SVF9EQVRBXCI6IFwiSW1wb3J0YXIgZGF0b3NcIixcbiAgICBcIn5QUk9WSURFUi5MT0NBTF9TVE9SQUdFXCI6IFwiQWxtYWNlbmFtaWVudG8gbG9jYWxcIixcbiAgICBcIn5QUk9WSURFUi5SRUFEX09OTFlcIjogXCJTw7NsbyBsZWN0dXJhXCIsXG4gICAgXCJ+UFJPVklERVIuR09PR0xFX0RSSVZFXCI6IFwiR29vZ2xlIERyaXZlXCIsXG4gICAgXCJ+UFJPVklERVIuRE9DVU1FTlRfU1RPUkVcIjogXCJDb25jb3JkIENsb3VkXCIsXG4gICAgXCJ+UFJPVklERVIuTE9DQUxfRklMRVwiOiBcIkFyY2hpdm8gbG9jYWxcIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZJTkdcIjogXCJHdWFyZGFuZG8uLi5cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZFRFwiOiBcIlNlIGd1YXJkYXJvbiB0b2RvcyBsb3MgY2FtYmlvc1wiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVkVEX1RPX1BST1ZJREVSXCI6IFwiU2UgZ3VhcmRhcm9uIHRvZG9zIGxvcyBjYW1iaW9zIGVuICV7cHJvdmlkZXJOYW1lfVwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlVOU0FWRURcIjogXCJTaW4gZ3VhcmRhclwiLFxuICAgIFwifkZJTEVfRElBTE9HLkZJTEVOQU1FXCI6IFwiTm9tYnJlIGRlIGFyY2hpdm9cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5PUEVOXCI6IFwiQWJyaXJcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwiR3VhcmRhclwiLFxuICAgIFwifkZJTEVfRElBTE9HLkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCI6IFwiRWxpbWluYXJcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVfQ09ORklSTVwiOiBcIsK/Q29uZmlybWEgZWxpbWluYXIgZWwgYXJjaGl2byAle2ZpbGVuYW1lfT9cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVEX1RJVExFXCI6IFwiQXJjaGl2byBlbGltaW5hZG9cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVEX01FU1NBR0VcIjogXCIle2ZpbGVuYW1lfSBmdWUgZWxpbWluYWRvXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRElOR1wiOiBcIkNhcmdhbmRvLi4uXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRF9GT0xERVJfRVJST1JcIjogXCIqKiogRXJyb3IgYWwgY2FyZ2FyIGNvbnRlbmlkbyBkZSBsYSBjYXJwZXRhICoqKlwiLFxuICAgIFwifkZJTEVfRElBTE9HLkRPV05MT0FEXCI6IFwiQmFqYXJcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5ET1dOTE9BRF9OT1RFXCI6IFwiTk9UQTogRW4gU2FmYXJpIGVsIGFyY2hpdm8gcHVlZGUgc2VyIFxcXCJEZXNjb25vY2lkb1xcXCIgeSBkZWJlbiBzZXIgcmVub21icmFkbyBkZSBtYW5lcmEgbWFudWFsIGNvbiBleHRlbnNpw7NuIC5jb2RhcFwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRFwiOiBcIkJhamFyXCIsXG4gICAgXCJ+RE9XTkxPQURfRElBTE9HLkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG4gICAgXCJ+RE9XTkxPQURfRElBTE9HLklOQ0xVREVfU0hBUkVfSU5GT1wiOiBcIkluY2x1aXIgaW5mb3JtYWNpw7NuIHBhcmEgY29tcGFydGlyIGVuIGFyY2hpdm8gYmFqYWRvXCIsXG4gICAgXCJ+UkVOQU1FX0RJQUxPRy5SRU5BTUVcIjogXCJSZW5vbWJyYXJcIixcbiAgICBcIn5SRU5BTUVfRElBTE9HLkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlcIjogXCJDb3BpYXJcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuVklFV1wiOiBcIlZlclwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DTE9TRVwiOiBcIkNlcnJhclwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX1NVQ0NFU1NcIjogXCJMYSBpbmZvcm1hY2nDs24gaGEgc2lkbyBjb3BpYWRhIGFsIHBvcnRhcGFwZWxlc1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX0VSUk9SXCI6IFwiRGlzY3VscGFzLCBsYSBpbmZvcm1hY2nDs24gbm8gcHVkbyBjb3BpYXJzZSBhbCBwb3J0YXBhcGVsZXNcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9USVRMRVwiOiBcIlJlc3VsdGFkbyBkZSBsYSBjb3BpYVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MT05HRVZJVFlfV0FSTklOR1wiOiBcIkxhIGNvcGlhIGNvbXBhcnRpZGEgZGUgZXN0ZSBkb2N1bWVudG8gc2Vyw6EgcmV0ZW5pZGEgaGFzdGEgcXVlIG5vIHNlYSBhY2NlZGlkYSBhIGxvIGxhcmdvIGRlIHVuIGHDsW8uXCIsXG4gICAgXCJ+U0hBUkVfVVBEQVRFLlRJVExFXCI6IFwiU2UgYWN0dWFsaXrDsyBsYSB2aXN0YSBjb21wYXJ0aWRhXCIsXG4gICAgXCJ+U0hBUkVfVVBEQVRFLk1FU1NBR0VcIjogXCJMYSB2aXN0YSBjb21wYXJ0aWRhIGZ1ZSBhY3R1YWxpemFkYSBleGl0b3NhbWVudGUuXCIsXG4gICAgXCJ+Q09ORklSTS5PUEVOX0ZJTEVcIjogXCJIYXkgY2FtYmlvcyBzaW4gZ3VhcmRhci4gwr9EZXNlYSBpZ3VhbCBhYnJpciB1biBudWV2byBkb2N1bWVudG8/XCIsXG4gICAgXCJ+Q09ORklSTS5ORVdfRklMRVwiOiBcIkhheSBjYW1iaW9zIHNpbiBndWFyZGFyLiDCv0Rlc2VhIGlndWFsIGNyZWFyIHVuIG51ZXZvIGRvY3VtZW50bz9cIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9PUEVOXCI6IFwiU2UgcmVxdWllcmUgYXV0b3JpemFjacOzbiBwYXJhIGFicmlyIGVsIGRvY3VtZW50by4gwr9EZXNlYSBwcm9jZWRlciBjb24gbGEgYXV0b3JpemFjacOzbj9cIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9TQVZFXCI6IFwiU2UgcmVxdWllcmUgYXV0b3JpemFjacOzbiBwYXJhIGd1YXJkYXIgZWwgZG9jdW1lbnRvLiDCv0Rlc2VhIHByb2NlZGVyIGNvbiBsYSBhdXRvcml6YWNpw7NuP1wiLFxuICAgIFwifkNPTkZJUk0uQ0xPU0VfRklMRVwiOiBcIkhheSBjYW1iaW9zIHNpbiBndWFyZGFyLiDCv0Rlc2VhIGlndWFsIGNlcnJhciBlbCBkb2N1bWVudG8/XCIsXG4gICAgXCJ+Q09ORklSTS5SRVZFUlRfVE9fTEFTVF9PUEVORURcIjogXCLCv0NvbmZpcm1hIHF1ZSBxdWllcmUgcmV2ZXJ0aXIgZWwgZG9jdW1lbnRvIGEgc3UgZXN0YWRvIGFiaWVydG8gbcOhcyByZWNpZW50ZT9cIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19TSEFSRURfVklFV1wiOiBcIsK/Q29uZmlybWEgcXVlIHF1aWVyZSByZXZlcnRpciBlbCBkb2N1bWVudG8gYSBzdSBlc3RhZG8gY29tcGFydGlkbyBtw6FzIHJlY2llbnRlP1wiLFxuICAgIFwifkNPTkZJUk1fRElBTE9HLlRJVExFXCI6IFwiwr9Db25maXJtYT9cIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5ZRVNcIjogXCJTw61cIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5OT1wiOiBcIk5vXCIsXG4gICAgXCJ+TE9DQUxfRklMRV9ESUFMT0cuRFJPUF9GSUxFX0hFUkVcIjogXCJBcnJhc3RyYXIgYXJjaGl2byBhY8OhIG8gY2xpYyBhY8OhIHBhcmEgc2VsZWNjaW9uYXIgdW4gYXJjaGl2by5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19TRUxFQ1RFRFwiOiBcIkRpc2N1bHBhcywgc8OzbG8gc2UgcHVlZGUgZWxlZ2lyIHVuIGFyY2hpdm8gcGFyYSBhYnJpci5cIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19EUk9QUEVEXCI6IFwiRGlzY3VscGFzLCBubyBzZSBwdWVkZW4gc29sdGFyIG3DoXMgZGUgdW4gYXJjaGl2by5cIixcbiAgICBcIn5JTVBPUlQuTE9DQUxfRklMRVwiOiBcIkFyY2hpdm8gbG9jYWxcIixcbiAgICBcIn5JTVBPUlQuVVJMXCI6IFwiVVJMXCIsXG4gICAgXCJ+SU1QT1JUX1VSTC5NVUxUSVBMRV9VUkxTX0RST1BQRURcIjogXCJEaXNjdWxwYXMsIHPDs2xvIHNlIHB1ZWRlIGVsZWdpciB1bmEgVVJMIHBhcmEgYWJyaXJcIixcbiAgICBcIn5JTVBPUlRfVVJMLlBMRUFTRV9FTlRFUl9VUkxcIjogXCJQb3IgZmF2b3IgaW5ncmVzYXIgdW5hIFVSTCBwYXJhIGltcG9ydGFyLlwiLFxuICAgIFwiflVSTF9UQUIuRFJPUF9VUkxfSEVSRVwiOiBcIkFycmFzdHJhciBVUkwgYWPDoSBvciBpbmdyZXNhciBVUkwgZGViYWpvXCIsXG4gICAgXCJ+VVJMX1RBQi5JTVBPUlRcIjogXCJJbXBvcnRhclwiLFxuICAgIFwifkNMSUVOVF9FUlJPUi5USVRMRVwiOiBcIkVycm9yXCIsXG4gICAgXCJ+QUxFUlRfRElBTE9HLlRJVExFXCI6IFwiQWxlcnRhXCIsXG4gICAgXCJ+QUxFUlRfRElBTE9HLkNMT1NFXCI6IFwiQ2VycmFyXCIsXG4gICAgXCJ+QUxFUlQuTk9fUFJPVklERVJcIjogXCJObyBzZSBwdWRvIGFicmlyIGVsIGRvY3VtZW50byBlc3BlY2lmaWNhZG8gcG9ycXVlIG5vIGhheSBkaXNwb25pYmxlIHVuIHByb3ZlZWRvciBhcHJvcGlhZG8uXCIsXG4gICAgXCJ+R09PR0xFX0RSSVZFLkxPR0lOX0JVVFRPTl9MQUJFTFwiOiBcIkxvZ3VlYXJzZSBlbiBHb29nbGVcIixcbiAgICBcIn5HT09HTEVfRFJJVkUuQ09OTkVDVElOR19NRVNTQUdFXCI6IFwiQ29uZWN0YW5kbyBjb24gR29vZ2xlLi4uXCIsXG4gICAgXCJ+R09PR0xFX0RSSVZFLkVSUk9SX01JU1NJTkdfQ0xJRU5USURcIjogXCJGYWx0YSBlbCBpZCBkZSBjbGllbnRlIHJlcXVlcmlkbyBlbiBsYXMgb3BjaW9uZXMgZGUgcHJvdmVlZG9yIGRlIEdvb2dsZURyaXZlXCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF80MDNfRVJST1JcIjogXCJObyB0aWVuZSBwZXJtaXNvIHBhcmEgY2FyZ2FyIGVsIGFyY2hpdm8gJXtmaWxlbmFtZX0uPGJyPjxicj5TaSBlc3TDoSB1c2FuZG8gdW4gZG9jdW1lbnRvIGNvbXBhcnRpZG8gcG9yIG90cm8gcXVpesOhcyBubyBlc3TDqSBtw6FzIGNvbXBhcnRpZG8uXCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF9TSEFSRURfNDA0X0VSUk9SXCI6IFwiTm8gc2UgcHVkbyBjYXJnYXIgZWwgZG9jdW1lbnRvIGNvbXBhcnRpZG8gcmVxdWVyaWRvLjxicj48YnI+UXVpesOhcyBlbCBhcmNoaXZvIG5vIGhheWEgc2lkbyBjb21wYXJ0aWRvIGRlIG1vZG8gYWRlY3VhZG9cIixcbiAgICBcIn5ET0NTVE9SRS5MT0FEXzQwNF9FUlJPUlwiOiBcIk5vIHNlIHB1ZG8gY2FyZ2FyIGVsIGFyY2hpdm8gJXtmaWxlbmFtZX1cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiOiBcIk5vIHRpZW5lIHBlcm1pc28gcGFyYSBndWFyZGFyIGVsIGFyY2hpdm8gJyV7ZmlsZW5hbWV9Jy48YnI+PGJyPk5lY2VzaXRhIGxvZ3VlYXJzZSBkZSBudWV2by5cXG5cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0RVUExJQ0FURV9FUlJPUlwiOiBcIk5vIHNlIHB1ZG8gY3JlYXIgJXtmaWxlbmFtZX0uIFlhIGV4aXN0ZSB1biBhcmNoaXZvIGNvbiBlc2Ugbm9tYnJlLlxcblwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JfV0lUSF9NRVNTQUdFXCI6IFwiTm8gc2UgcHVkbyBndWFyZGFyICV7ZmlsZW5hbWV9OiBbJXttZXNzYWdlfV1cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0VSUk9SXCI6IFwiTm8gc2UgcHVkbyBndWFyZGFyICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVNT1ZFXzQwM19FUlJPUlwiOiBcIk5vIHRpZW5lIHBlcm1pc28gcGFyYSBxdWl0YXIgZWwgYXJjaGl2byAle2ZpbGVuYW1lfS48YnI+PGJyPk5lY2VzaXRhIGxvZ3VlYXJzZSBkZSBudWV2by5cIixcbiAgICBcIn5ET0NTVE9SRS5SRU1PVkVfRVJST1JcIjogXCJObyBzZSBwdWRvIHJlbW92ZXIgJXtmaWxlbmFtZX1cIixcbiAgICBcIn5ET0NTVE9SRS5SRU5BTUVfNDAzX0VSUk9SXCI6IFwiTm8gdGllbmUgcGVybWlzbyBwYXJhIHJlbm9tYnJhciBlbCBhcmNoaXZvICV7ZmlsZW5hbWV9Ljxicj48YnI+TmVjZXNpdGEgbG9ndWVhcnNlIGRlIG51ZXZvLlwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTkFNRV9FUlJPUlwiOiBcIk5vIHNlIHB1ZG8gcmVub21icmFyICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfVElUTEVcIjogXCJBbGVydGEgZGUgQ29uY29yZCBDbG91ZFwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQUxFUlRfU0FWRV9USVRMRVwiOiBcIkFsZXJ0YSBkZSBDb25jb3JkIENsb3VkXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfRUxTRVdIRVJFXCI6IFwiR3VhcmRhciBlbiBjdWFscXVpZXIgbHVnYXJcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fRE9fSVRfTEFURVJcIjogXCJMbyBoYXLDqSBtw6FzIHRhcmRlXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5TSFVUX0RPV05fTUVTU0FHRVwiOiBcIkNvbmNvcmQgQ2xvdWQgaGEgc2lkbyBjZXJyYWRvXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5QTEVBU0VfU0FWRV9FTFNFV0hFUkVcIjogXCJQb3IgZmF2b3IgZ3VhcmRhciBzdXMgZG9jdW1lbnRvcyBlbiBvdHJhIHViaWNhY2nDs24uXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFXCI6IFwiU2hhcmVkIHZpZXc6IFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9FTkFCTEVEXCI6IFwiZW5hYmxlZFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9ESVNBQkxFRFwiOiBcImRpc2FibGVkXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVOQUJMRV9TSEFSSU5HXCI6IFwiRW5hYmxlIHNoYXJpbmdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU1RPUF9TSEFSSU5HXCI6IFwiU3RvcCBzaGFyaW5nXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlVQREFURV9TSEFSSU5HXCI6IFwiVXBkYXRlIHNoYXJlZCB2aWV3XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlBSRVZJRVdfU0hBUklOR1wiOiBcIlByZXZpZXcgc2hhcmVkIHZpZXdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdfTUVTU0FHRVwiOiBcIldoZW4gc2hhcmluZyBpcyBlbmFibGVkLCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlldyBpcyBjcmVhdGVkLiAgVGhpcyBjb3B5IGNhbiBiZSBzaGFyZWQuXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfVEFCXCI6IFwiTGlua1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MSU5LX01FU1NBR0VcIjogXCJQYXN0ZSB0aGlzIGludG8gYW4gZW1haWwgb3IgdGV4dCBtZXNzYWdlIFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9UQUJcIjogXCJFbWJlZFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9NRVNTQUdFXCI6IFwiRW1iZWQgY29kZSBmb3IgaW5jbHVkaW5nIGluIHdlYnBhZ2VzIG9yIG90aGVyIHdlYi1iYXNlZCBjb250ZW50XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfTUVTU0FHRVwiOiBcIlVzZSB0aGlzIGxpbmsgd2hlbiBjcmVhdGluZyBhbiBhY3Rpdml0eSBpbiBMQVJBXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfQ09EQVBfVVJMXCI6IFwiQ09EQVAgU2VydmVyIFVSTDpcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9BVVRPTEFVTkNIX1BBR0VcIjogXCJBdXRvbGF1bmNoIHBhZ2VcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9GVUxMU0NSRUVOX0JVVFRPTl9BTkRfU0NBTElOR1wiOiBcIkZ1bGxzY3JlZW4gYnV0dG9uIGFuZCBzY2FsaW5nXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfTEFVTkNIX0JVVFRPTl9URVhUXCI6IFwiTGF1bmNoIEJ1dHRvbiBUZXh0OlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0RJU1BMQVlfVklTSUJJTElUWV9UT0dHTEVTXCI6IFwiRGlzcGxheSBkYXRhIHZpc2liaWxpdHkgdG9nZ2xlcyBvbiBncmFwaHNcIixcbiAgICBcIn5DT05GSVJNLkNIQU5HRV9MQU5HVUFHRVwiOiBcIllvdSBoYXZlIHVuc2F2ZWQgY2hhbmdlcy4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNoYW5nZSBsYW5ndWFnZXM/XCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJ+TUVOVUJBUi5VTlRJVExFRF9ET0NVTUVOVFwiOiBcItee16HXnteaINec15Ag16nXnteV16hcIixcbiAgICBcIn5NRU5VLk5FV1wiOiBcIteX15PXqVwiLFxuICAgIFwifk1FTlUuT1BFTlwiOiBcItek16rXl1wiLFxuICAgIFwifk1FTlUuQ0xPU0VcIjogXCLXodeS15XXqFwiLFxuICAgIFwifk1FTlUuSU1QT1JUX0RBVEFcIjogXCLXmdeR15Ag16DXqteV16DXmdedXCIsXG4gICAgXCJ+TUVOVS5TQVZFXCI6IFwi16nXnteV16hcIixcbiAgICBcIn5NRU5VLlNBVkVfQVNcIjogXCLXqdee15XXqCDXkdep151cIixcbiAgICBcIn5NRU5VLkVYUE9SVF9BU1wiOiBcIteZ16bXkCDXp9eV15HXpVwiLFxuICAgIFwifk1FTlUuQ1JFQVRFX0NPUFlcIjogXCLXpteV16gg16LXldeq16dcIixcbiAgICBcIn5NRU5VLlNIQVJFXCI6IFwi16nXqtejXCIsXG4gICAgXCJ+TUVOVS5TSEFSRV9HRVRfTElOS1wiOiBcIten15HXnCDXp9eZ16nXldeoINec16bXpNeZ15Qg16nXmdeq15XXpNeZ16pcIixcbiAgICBcIn5NRU5VLlNIQVJFX1VQREFURVwiOiBcItei15PXm9efINem16TXmdeUINep15nXqteV16TXmdeqXCIsXG4gICAgXCJ+TUVOVS5ET1dOTE9BRFwiOiBcIteU15XXqNeTXCIsXG4gICAgXCJ+TUVOVS5SRU5BTUVcIjogXCLXqdeg15Qg16nXnVwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPXCI6IFwi15TXl9eW16gg15xcIixcbiAgICBcIn5NRU5VLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcItee16bXkSDXpNeq15XXlyDXnNeQ15fXqNeV16DXlFwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwi16bXpNeZ15Qg16nXmdeq15XXpNeZ16pcIixcbiAgICBcIn5ESUFMT0cuU0FWRVwiOiBcItep157XldeoXCIsXG4gICAgXCJ+RElBTE9HLlNBVkVfQVNcIjogXCLXqdee15XXqCDXkdep151cIixcbiAgICBcIn5ESUFMT0cuRVhQT1JUX0FTXCI6IFwi15nXpteQINen15XXkdelINebXCIsXG4gICAgXCJ+RElBTE9HLkNSRUFURV9DT1BZXCI6IFwi16bXldeoINei15XXqtenLi4uXCIsXG4gICAgXCJ+RElBTE9HLk9QRU5cIjogXCLXpNeq15dcIixcbiAgICBcIn5ESUFMT0cuRE9XTkxPQURcIjogXCLXlNeV16jXk1wiLFxuICAgIFwifkRJQUxPRy5SRU5BTUVcIjogXCLXqdeg15Qg16nXnVwiLFxuICAgIFwifkRJQUxPRy5TSEFSRURcIjogXCLXqdeq16NcIixcbiAgICBcIn5ESUFMT0cuSU1QT1JUX0RBVEFcIjogXCLXmdeR15Ag16DXqteV16DXmdedXCIsXG4gICAgXCJ+UFJPVklERVIuTE9DQUxfU1RPUkFHRVwiOiBcIteQ15fXodeV158g157Xp9eV157XmVwiLFxuICAgIFwiflBST1ZJREVSLlJFQURfT05MWVwiOiBcIten16jXmdeQ15Qg15HXnNeR15NcIixcbiAgICBcIn5QUk9WSURFUi5HT09HTEVfRFJJVkVcIjogXCLXqdeo16ogR09PR0xFXCIsXG4gICAgXCJ+UFJPVklERVIuRE9DVU1FTlRfU1RPUkVcIjogXCLXoteg158gQ09OQ09SRFwiLFxuICAgIFwiflBST1ZJREVSLkxPQ0FMX0ZJTEVcIjogXCLXp9eV15HXpSDXnten15XXnteZXCIsXG4gICAgXCJ+RklMRV9TVEFUVVMuU0FWSU5HXCI6IFwi16nXldee16guLi5cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZFRFwiOiBcIteb15wg15TXqdeZ16DXldeZ15nXnSDXoNep157XqNeVXCIsXG4gICAgXCJ+RklMRV9TVEFUVVMuU0FWRURfVE9fUFJPVklERVJcIjogXCLXm9ecINeU16nXmdeg15XXmdeZ150g16DXqdee16jXlSDXnCAle3Byb3ZpZGVyTmFtZX1cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5VTlNBVkVEXCI6IFwi15zXkCDXqdee15XXqFwiLFxuICAgIFwifkZJTEVfRElBTE9HLkZJTEVOQU1FXCI6IFwi16nXnSDXp9eV15HXpVwiLFxuICAgIFwifkZJTEVfRElBTE9HLk9QRU5cIjogXCLXpNeq15dcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwi16nXnteV16hcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5DQU5DRUxcIjogXCLXkdeY15xcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVcIjogXCLXnteX16dcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVfQ09ORklSTVwiOiBcIteU15DXnSDXkNeq150g15HXmNeV15fXmdedINep15HXqNem15XXoNeb150g15zXnteX15XXpyDXkNeqICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiOiBcIten15XXkdelINee15fXldenXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9NRVNTQUdFXCI6IFwiJXtmaWxlbmFtZX0g16DXnteX16dcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5MT0FESU5HXCI6IFwi15jXldei158uLi5cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5MT0FEX0ZPTERFUl9FUlJPUlwiOiBcIioqKiDXmNei15XXqiDXkdei16og15jXoteZ16DXqiDXqteV15vXnyDXlNen15XXkdelICoqKlwiLFxuICAgIFwifkZJTEVfRElBTE9HLkRPV05MT0FEXCI6IFwi15TXldeo15NcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5ET1dOTE9BRF9OT1RFXCI6IFwi16nXmdedINec15E6INeU16fXldeR16Ug16DXqdee16gg15sn15zXkCDXmdeT15XXoicg15XXpteo15nXmiDXnNep16DXldeqINeQ16og15TXqdedINeZ15PXoNeZ16og16LXnSDXqteV16HXpNeqIC5DT0RBUFwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRFwiOiBcIteU15XXqNeTXCIsXG4gICAgXCJ+RE9XTkxPQURfRElBTE9HLkNBTkNFTFwiOiBcIteR15jXnFwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5JTkNMVURFX1NIQVJFX0lORk9cIjogXCLXpteo16Mg16DXqteV16DXmSDXqdeZ16rXldejINeR16fXldeR16Ug16nXlNeV16jXk1wiLFxuICAgIFwiflJFTkFNRV9ESUFMT0cuUkVOQU1FXCI6IFwi16nXoNeUINep151cIixcbiAgICBcIn5SRU5BTUVfRElBTE9HLkNBTkNFTFwiOiBcIteR15jXnFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZXCI6IFwi15TXoteq16dcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuVklFV1wiOiBcItem16TXlFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DTE9TRVwiOiBcIteh15LXldeoXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfU1VDQ0VTU1wiOiBcIteU157XmdeT16Ig15TXldei16rXpyDXnNec15XXl1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX0VSUk9SXCI6IFwi16HXnNeZ15fXlCwg15TXnteZ15PXoiDXnNeQINeg15nXqtefINec15TXoteq16fXlCDXnNec15XXl1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX1RJVExFXCI6IFwi15TXoteq16cg16rXldem15DXlFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MT05HRVZJVFlfV0FSTklOR1wiOiBcIteU16LXldeq16cg15TXqdeZ16rXldek15kg16nXnCDXnteh157XmiDXlteUINeZ16nXnteoINei15Mg16nXoNeUINec15zXkCDXqdeZ157XldepXCIsXG4gICAgXCJ+U0hBUkVfVVBEQVRFLlRJVExFXCI6IFwi16bXpNeZ15Qg16nXmdeq15XXpNeZ16og16LXldeT15vXoNeUXCIsXG4gICAgXCJ+U0hBUkVfVVBEQVRFLk1FU1NBR0VcIjogXCLXlNem16TXmdeUINeU16nXmdeq15XXpNeZ16og16LXldeT15vXoNeUINeR15TXptec15fXlFwiLFxuICAgIFwifkNPTkZJUk0uT1BFTl9GSUxFXCI6IFwi15nXqdeg150g16nXmdeg15XXmdeZ150g15zXkCDXqdee15XXqNeZ150uINeU15DXnSDXkNeq150g15HXmNeV15fXmdedINep15HXqNem15XXoNeb150g15zXpNeq15XXlyDXnteh157XmiDXl9eT16k/XCIsXG4gICAgXCJ+Q09ORklSTS5ORVdfRklMRVwiOiBcIteZ16nXoNedINep15nXoNeV15nXmdedINec15Ag16nXnteV16jXmdedLiDXlNeQ150g15DXqtedINeR15jXldeX15nXnSDXqdeR16jXpteV16DXm9edINec15nXpteV16gg157Xodee15og15fXk9epP1wiLFxuICAgIFwifkNPTkZJUk0uQVVUSE9SSVpFX09QRU5cIjogXCLXoNeT16jXqSDXkNeZ16nXldeoINec16TXqteZ15fXqiDXlNee16HXnteaLiDXnNeU157XqdeZ15og16LXnSDXkNeZ16nXldeoP1wiLFxuICAgIFwifkNPTkZJUk0uQVVUSE9SSVpFX1NBVkVcIjogXCLXoNeT16jXqSDXkNeZ16nXldeoINec16nXnteZ16jXqiDXlNee16HXnteaLiDXnNeU157XqdeZ15og16LXnSDXkNeZ16nXldeoP1wiLFxuICAgIFwifkNPTkZJUk0uQ0xPU0VfRklMRVwiOiBcIteZ16nXoNedINep15nXoNeV15nXmdedINec15Ag16nXnteV16jXmdedLiDXnNeh15LXldeoINeQ16og15TXnteh157Xmj9cIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIteR15jXldeXINep15HXqNem15XXoNeb150g15zXlNeX15bXmdeoINeQ16og15TXnteh157XmiDXnNee16bXkSDXlNek16rXldeXINeU15DXl9eo15XXnz9cIixcbiAgICBcIn5DT05GSVJNLlJFVkVSVF9UT19TSEFSRURfVklFV1wiOiBcIteR15jXldeXINep15HXqNem15XXoNeb150g15zXlNeX15bXmdeoINeQ16og15TXnteh157XmiDXnNee16bXkSDXlNep15nXqteV16TXmSDXlNeQ15fXqNeV158/XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuVElUTEVcIjogXCLXkdeY15XXlz9cIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5ZRVNcIjogXCLXm9efXCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuTk9cIjogXCLXnNeQXCIsXG4gICAgXCJ+TE9DQUxfRklMRV9ESUFMT0cuRFJPUF9GSUxFX0hFUkVcIjogXCLXqdeX16jXqCDXp9eV15HXpSDXm9eQ158g15DXlSDXlNen15zXpyDXnNeR15fXmdeo16og16fXldeR16VcIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19TRUxFQ1RFRFwiOiBcIteh15zXmdeX15QsINeg15nXqtefINec15HXl9eV16gg16jXpyDXp9eV15HXpSDXkNeX15Mg15zXpNeq15nXl9eULlwiLFxuICAgIFwifkxPQ0FMX0ZJTEVfRElBTE9HLk1VTFRJUExFX0ZJTEVTX0RST1BQRURcIjogXCLXodec15nXl9eULCDXnNeQINeg15nXqtefINec16nXl9eo16gg15nXldeq16gg157Xp9eV15HXpSDXkNeX15MuXCIsXG4gICAgXCJ+SU1QT1JULkxPQ0FMX0ZJTEVcIjogXCLXp9eV15HXpSDXnten15XXnteZXCIsXG4gICAgXCJ+SU1QT1JULlVSTFwiOiBcIlVSTFwiLFxuICAgIFwifklNUE9SVF9VUkwuTVVMVElQTEVfVVJMU19EUk9QUEVEXCI6IFwi16HXnNeZ15fXlCwg16DXmdeq158g15zXpNeq15XXlyDXqNenINen15nXqdeV16gg15DXl9eTXCIsXG4gICAgXCJ+SU1QT1JUX1VSTC5QTEVBU0VfRU5URVJfVVJMXCI6IFwi15TXp9ec15nXk9eVIFVSTCDXnNeZ15HXldeQXCIsXG4gICAgXCJ+VVJMX1RBQi5EUk9QX1VSTF9IRVJFXCI6IFwi16nXl9eo16ggVVJMINek15Qg15DXlSDXlNen15zXkyBVUkwg157XqteX16pcIixcbiAgICBcIn5VUkxfVEFCLklNUE9SVFwiOiBcIteZ15HXkFwiLFxuICAgIFwifkNMSUVOVF9FUlJPUi5USVRMRVwiOiBcIteY16LXldeqXCIsXG4gICAgXCJ+QUxFUlRfRElBTE9HLlRJVExFXCI6IFwi15DXlteU16jXlFwiLFxuICAgIFwifkFMRVJUX0RJQUxPRy5DTE9TRVwiOiBcIteh15LXldeoXCIsXG4gICAgXCJ+QUxFUlQuTk9fUFJPVklERVJcIjogXCLXnNeQINeg15nXqtefINec16TXqteV15cg15DXqiDXlNee16HXnteaINee16TXoNeZINep15TXqdeo16og15DXmdeg15Ug15bXnteZ159cIixcbiAgICBcIn5HT09HTEVfRFJJVkUuTE9HSU5fQlVUVE9OX0xBQkVMXCI6IFwi15TXm9eg16Eg15xHT09HTEVcIixcbiAgICBcIn5HT09HTEVfRFJJVkUuQ09OTkVDVElOR19NRVNTQUdFXCI6IFwi157XqteX15HXqCDXnEdPT0dMRVwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5FUlJPUl9NSVNTSU5HX0NMSUVOVElEXCI6IFwi15fXodeo15nXnSDXpNeo15jXmSDXnNen15XXlyDXkUdPT0dMRVwiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfNDAzX0VSUk9SXCI6IFwi15DXmdefINeQ15nXqdeV16gg15zXpNeq15XXlyDXkNeqICUuINeQ150g15DXqtedINee16nXqtee16nXmdedINeR157Xodee15og16nXmdeq15XXpNeZINep15wg157Xmdep15TXlSDXkNeX16gg15nXmdeq15vXnyDXqdeU16fXldeR16Ug15zXkCDXoNep157XqC5cIixcbiAgICBcIn5ET0NTVE9SRS5MT0FEX1NIQVJFRF80MDRfRVJST1JcIjogXCLXnNeQINeg15nXqtefINec15TXotec15XXqiDXkNeqINeU157Xodee15og15TXqdeZ16rXldek15kg15TXnteR15XXp9epLiDXkNeV15zXmSDXlNen15XXkdelINec15Ag16nXldeq16M/XCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF80MDRfRVJST1JcIjogXCLXnNeQINeg15nXqtefINec15TXotec15XXqiDXkNeqICVcIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiOiBcIteQ15nXnyDXkNeZ16nXldeoINec16nXnteZ16jXqiAnJXtmaWxlbmFtZX0nLjxicj48YnI+INeZ15nXqteb158g16nXqtem15jXqNeb15Ug15zXlNeb16DXoSDXqdeV15EuXCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV9EVVBMSUNBVEVfRVJST1JcIjogXCLXnNeQINeg15nXqtefINec15nXpteV16gg15DXqiAle2ZpbGVuYW1lfSDXlNen15XXkdelINeb15HXqCDXp9eZ15nXnS5cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0VSUk9SX1dJVEhfTUVTU0FHRVwiOiBcItec15Ag16DXmdeq158g15zXqdee15XXqCDXkNeqICV7ZmlsZW5hbWV9OiBbJXttZXNzYWdlfV1cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0VSUk9SXCI6IFwi15zXkCDXoNeZ16rXnyDXnNep157XldeoINeQ16ogJXtmaWxlbmFtZX1cIixcbiAgICBcIn5ET0NTVE9SRS5SRU1PVkVfNDAzX0VSUk9SXCI6IFwi15DXmdefINeQ15nXqdeV16gg15zXlNeh16jXqiAle2ZpbGVuYW1lfS48YnI+PGJyPiDXmdepINem15XXqNeaINec15TXm9eg16Eg16nXldeRLlwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV9FUlJPUlwiOiBcItec15Ag16DXmdeq158g15zXlNeh15nXqCDXkNeqICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FXzQwM19FUlJPUlwiOiBcIteQ15nXnyDXkNeZ16nXldeoINec16nXmdeg15XXmSDXqdedICV7ZmlsZW5hbWV9Ljxicj48YnI+INeZ16kg16bXldeo15og15zXlNeb16DXoSDXqdeV15EuXCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FX0VSUk9SXCI6IFwi15zXkCDXoNeZ16rXnyDXnNep16DXldeqINeQ16og16nXnSAle2ZpbGVuYW1lfVwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9TQVZFX1RJVExFXCI6IFwi15DXlteU16jXqiDXoteg158gQ09OQ09SRFwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQUxFUlRfU0FWRV9USVRMRVwiOiBcIteQ15bXlNeo16og16LXoNefIENPTkNPUkRcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fU0FWRV9FTFNFV0hFUkVcIjogXCLXqdee15XXqCDXkdee16fXldedINeQ15fXqFwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9ET19JVF9MQVRFUlwiOiBcIteZ15XXqteoINee15DXldeX16hcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLlNIVVRfRE9XTl9NRVNTQUdFXCI6IFwi16LXoNefIENPTkNPUkQg16DXodeS16ghXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5QTEVBU0VfU0FWRV9FTFNFV0hFUkVcIjogXCLXqdee15XXqCDXnteh157XmiDXkdee15nXp9eV150g15DXl9eoLlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURVwiOiBcIteq16bXldeS15Qg16nXmdeq15XXpNeZ16o64pCjXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFX0VOQUJMRURcIjogXCLXpNei15nXnFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9ESVNBQkxFRFwiOiBcItec15Ag16TXoteZ15xcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdcIjogXCLXlNek16LXnNeqINep15nXqteV16NcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU1RPUF9TSEFSSU5HXCI6IFwi16LXpteZ16jXqiDXqdeZ16rXldejXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlVQREFURV9TSEFSSU5HXCI6IFwi16LXk9eb15XXnyDXqtem15XXkteUINep15nXqteV16TXmdeqXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlBSRVZJRVdfU0hBUklOR1wiOiBcItem16TXmdeUINee15XXp9eT157XqiDXkdeq16bXldeS15Qg16nXmdeq15XXpNeZ16pcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdfTUVTU0FHRVwiOiBcIteb15DXqdeoINeU16nXmdeq15XXoyDXpNei15nXnCwgINeg15XXpteoINei15XXqtenINep15wg15TXqtem15XXkteUINeU16DXldeb15fXmdeqLiDXoteV16rXpyDXlteUINeZ15vXldecINec15TXmdeV16og157XqdeV16rXoy5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTElOS19UQUJcIjogXCLXp9eZ16nXldeoXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfTUVTU0FHRVwiOiBcIteU15PXkdeZ16fXlSDXkNeqINeU16fXmdep15XXqCDXnNeQ15nXnteZ15nXnCDXkNeVINec15TXldeT16LXqiDXmNen16HXmFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTUJFRF9UQUJcIjogXCLXqdeZ15zXldeRXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVNQkVEX01FU1NBR0VcIjogXCLXqdeZ15zXldeRINeU16fXldeTINec15TXldeh16TXlCDXkdei157XldeT15kg16jXqdeqINeQ15Ug16rXldeb158g16jXqdeq15kg15DXl9eoXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfTUVTU0FHRVwiOiBcIteU16nXqtee16nXlSDXkden15nXqdeV16gg15bXlCDXkdei16og15nXpteZ16jXqiDXpNei15nXnNeV16ogTEFSQVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0NPREFQX1VSTFwiOiBcIlVSTCDXqdecINep16jXqiBDT0RBUDpcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9BVVRPTEFVTkNIX1BBR0VcIjogXCLXlNek16LXnNeUINeQ15XXmNeV157XmNeZ16og16nXnCDXlNeT16NcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9GVUxMU0NSRUVOX0JVVFRPTl9BTkRfU0NBTElOR1wiOiBcIteb16TXqteV16gg157XodeaINee15zXkCDXldee15nXqNeb15XXllwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0xBVU5DSF9CVVRUT05fVEVYVFwiOiBcIteU16TXotec16og15vXpNeq15XXqCDXmNen16HXmDpcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9ESVNQTEFZX1ZJU0lCSUxJVFlfVE9HR0xFU1wiOiBcIteU16bXkteqINee15nXk9eiINeV15nXlteV15DXnNeZINeR15LXqNek15nXnVwiLFxuICAgIFwifkNPTkZJUk0uQ0hBTkdFX0xBTkdVQUdFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2hhbmdlIGxhbmd1YWdlcz9cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIn5NRU5VQkFSLlVOVElUTEVEX0RPQ1VNRU5UXCI6IFwixLBzaW1zaXogRG9zeWFcIixcbiAgICBcIn5NRU5VLk5FV1wiOiBcIlllbmlcIixcbiAgICBcIn5NRU5VLk9QRU5cIjogXCJBw6dcIixcbiAgICBcIn5NRU5VLkNMT1NFXCI6IFwiS2FwYXRcIixcbiAgICBcIn5NRU5VLklNUE9SVF9EQVRBXCI6IFwiVmVyaWxlcmkgYWt0YXIuLi5cIixcbiAgICBcIn5NRU5VLlNBVkVcIjogXCJLYXlkZXRcIixcbiAgICBcIn5NRU5VLlNBVkVfQVNcIjogXCJGYXJrbMSxIGtheWRldC4uLlwiLFxuICAgIFwifk1FTlUuRVhQT1JUX0FTXCI6IFwiRG9zeWF5xLEgZMSxxZ9hIGFrdGFyIC4uLlwiLFxuICAgIFwifk1FTlUuQ1JFQVRFX0NPUFlcIjogXCJZZW5pIGJpciBrb3B5YSBvbHXFn3R1clwiLFxuICAgIFwifk1FTlUuU0hBUkVcIjogXCJQYXlsYcWfLi4uXCIsXG4gICAgXCJ+TUVOVS5TSEFSRV9HRVRfTElOS1wiOiBcIlBheWxhxZ/EsWxhYmlsaXIgQmHEn2xhbnTEsXnEsSBBbFwiLFxuICAgIFwifk1FTlUuU0hBUkVfVVBEQVRFXCI6IFwiUGF5bGHFn8SxbcSxIEfDvG5jZWxsZVwiLFxuICAgIFwifk1FTlUuRE9XTkxPQURcIjogXCLEsG5kaXJcIixcbiAgICBcIn5NRU5VLlJFTkFNRVwiOiBcIlllbmlkZW4gQWRsYW5kxLFyXCIsXG4gICAgXCJ+TUVOVS5SRVZFUlRfVE9cIjogXCJEw7Zuw7zFn3TDvHJcIixcbiAgICBcIn5NRU5VLlJFVkVSVF9UT19MQVNUX09QRU5FRFwiOiBcIlNvbiBBw6fEsWxhbiBWZXJzaXlvblwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwiUGF5bGHFn8SxbWzEsSBnw7Zyw7xuw7xtXCIsXG4gICAgXCJ+RElBTE9HLlNBVkVcIjogXCJLYXlkZXRcIixcbiAgICBcIn5ESUFMT0cuU0FWRV9BU1wiOiBcIkZhcmtsxLEga2F5ZGV0XCIsXG4gICAgXCJ+RElBTE9HLkVYUE9SVF9BU1wiOiBcIkRvc3lhecSxIETEscWfYSBBa3Rhci4uLlwiLFxuICAgIFwifkRJQUxPRy5DUkVBVEVfQ09QWVwiOiBcIktvcHlhc8SxbsSxIE9sdcWfdHVyLi4uXCIsXG4gICAgXCJ+RElBTE9HLk9QRU5cIjogXCJBw6dcIixcbiAgICBcIn5ESUFMT0cuRE9XTkxPQURcIjogXCLEsG5kaXJcIixcbiAgICBcIn5ESUFMT0cuUkVOQU1FXCI6IFwiWWVuaWRlbiBBZGxhbmTEsXJcIixcbiAgICBcIn5ESUFMT0cuU0hBUkVEXCI6IFwiUGF5bGHFn1wiLFxuICAgIFwifkRJQUxPRy5JTVBPUlRfREFUQVwiOiBcIlZlcmlsZXJpIEFrdGFyXCIsXG4gICAgXCJ+UFJPVklERVIuTE9DQUxfU1RPUkFHRVwiOiBcIlllcmVsIERlcG9sYW1hXCIsXG4gICAgXCJ+UFJPVklERVIuUkVBRF9PTkxZXCI6IFwiWWFsbsSxemNhIE9rdW5hYmlsaXJcIixcbiAgICBcIn5QUk9WSURFUi5HT09HTEVfRFJJVkVcIjogXCJHb29nbGUgRHJpdmVcIixcbiAgICBcIn5QUk9WSURFUi5ET0NVTUVOVF9TVE9SRVwiOiBcIkNvbmNvcmQgQnVsdXQgRGVwb2xhbWFcIixcbiAgICBcIn5QUk9WSURFUi5MT0NBTF9GSUxFXCI6IFwiWWVyZWwgRG9zeWFsYXJcIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZJTkdcIjogXCJLYXlkZWRpbGl5b3IuLi5cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZFRFwiOiBcIlTDvG0gZGXEn2nFn2lrbGlrbGVyIGtheWRlZGlsZGlcIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZFRF9UT19QUk9WSURFUlwiOiBcIlTDvG0gRGXEn2nFn2lrbGlrbGVyICV7cHJvdmlkZXJOYW1lfSBPbGFyYWsgS2F5ZGVkaWxkaVwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlVOU0FWRURcIjogXCJLYXlkZWRpbG1lbWnFn1wiLFxuICAgIFwifkZJTEVfRElBTE9HLkZJTEVOQU1FXCI6IFwiRG9zeWEgQWTEsVwiLFxuICAgIFwifkZJTEVfRElBTE9HLk9QRU5cIjogXCJBw6dcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwiS2F5ZGV0XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuQ0FOQ0VMXCI6IFwixLBwdGFsXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCI6IFwiU2lsXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFX0NPTkZJUk1cIjogXCIle2ZpbGVuYW1lfSBkb3N5YXPEsW7EsSBzaWxtZWsgaXN0ZWRpxJ9pbml6ZSBlbWluIG1pc2luaXo/XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiOiBcIkRvc3lhIFNpbGluZGlcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5SRU1PVkVEX01FU1NBR0VcIjogXCIle2ZpbGVuYW1lfSBkb3N5YXPEsSBzaWxpbmRpXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRElOR1wiOiBcIlnDvGtsZW5peW9yLi4uXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuTE9BRF9GT0xERVJfRVJST1JcIjogXCLEsMOnZXJpayB5w7xrbGVuaXJrZW4gaGF0YSBvbHXFn3R1LlwiLFxuICAgIFwifkZJTEVfRElBTE9HLkRPV05MT0FEXCI6IFwixLBuZGlyXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuRE9XTkxPQURfTk9URVwiOiBcIk5PVDogU2FmYXJpIGlsZSDDp2FsxLHFn8SxcmtlbiBkb3N5YSBcXFwiQmlsaW5tZXllblxcXCIgb2xhcmFrIGfDtnLDvGxlYmlsaXIgdmUgLmNvZGFwIHV6YW50xLFzxLEgb2xhcmFrIGVsIGlsZSB5ZW5pZGVuIGFkbGFuZMSxcsSxbG1hc8SxIGdlcmVrZWJpbGlyLlwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRFwiOiBcIsSwbmRpclwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5DQU5DRUxcIjogXCLEsHB0YWxcIixcbiAgICBcIn5ET1dOTE9BRF9ESUFMT0cuSU5DTFVERV9TSEFSRV9JTkZPXCI6IFwiUGF5bGHFn8SxbGFuIGJpbGdpbGVyaSBpbmRpcmlsZW4gZG9zeWF5YSBkYWhpbCBldC5cIixcbiAgICBcIn5SRU5BTUVfRElBTE9HLlJFTkFNRVwiOiBcIlllbmlkZW4gQWRsYW5kxLFyXCIsXG4gICAgXCJ+UkVOQU1FX0RJQUxPRy5DQU5DRUxcIjogXCLEsHB0YWxcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWVwiOiBcIktvcHlhbGFcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuVklFV1wiOiBcIkfDtnLDvG50w7xsZVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DTE9TRVwiOiBcIkthcGF0XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfU1VDQ0VTU1wiOiBcIsSww6dlcmlrIHBhbm95YSBrb3B5YWxhbmTEsS5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9FUlJPUlwiOiBcIsOcemfDvG7DvHosIGJ1IGnDp2VyaWsgcGFub3lhIGtvcHlhbGFuYW1hZMSxLlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZX1RJVExFXCI6IFwiU29udWN1IEtvcHlhbGFcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTE9OR0VWSVRZX1dBUk5JTkdcIjogXCJCdSBkb3N5YW7EsW4gYmlyIMO2cm5lxJ9pIGJpciB5xLFsZGFuIGZhemxhIGJpciBzw7xyZSBlcmnFn2lsbWVkacSfaSB0YWt0aXJkZSBzYWtsYW5hY2FrdMSxci5cIixcbiAgICBcIn5TSEFSRV9VUERBVEUuVElUTEVcIjogXCJQYXlsYcWfxLFsYW4gZ8O2csO8bsO8bSBnw7xuY2VsbGVuZGlcIixcbiAgICBcIn5TSEFSRV9VUERBVEUuTUVTU0FHRVwiOiBcIlBheWxhxZ/EsWxhbiBnw7Zyw7xuw7xtIGJhxZ9hcsSxeWxhIGfDvG5jZWxsZW5kaS5cIixcbiAgICBcIn5DT05GSVJNLk9QRU5fRklMRVwiOiBcIkRlxJ9pxZ9pa2xpa2xlcmkga2F5ZGV0bWVkaW5pei4gWWVuaSBiaXIgZG9zeWEgYcOnbWFrIGlzdGVkacSfaW5pemUgZW1pbiBtaXNpbml6P1wiLFxuICAgIFwifkNPTkZJUk0uTkVXX0ZJTEVcIjogXCJEZcSfacWfaWtsaWtsZXJpIGtheWRldG1lZGluaXouIFllbmkgYmlyIGRvc3lhIG9sdcWfdHVybWFrIGlzdGVkacSfaW5pemUgZW1pbiBtaXNpbml6P1wiLFxuICAgIFwifkNPTkZJUk0uQVVUSE9SSVpFX09QRU5cIjogXCJCdSBkb3N5YXnEsSBhw6dtYWsgacOnaW4geWV0a2lsaSBvbG1hbsSxeiBnZXJla21la3RlZGlyLiBEZXZhbSBldG1layBpc3RpeW9yIG11c3VudXo/XCIsXG4gICAgXCJ+Q09ORklSTS5BVVRIT1JJWkVfU0FWRVwiOiBcIkJ1IGRvc3lhecSxIGtheWRldG1layBpw6dpbiB5ZXRraWxpIG9sbWFuxLF6IGdlcmVrbWVrdGVkaXIuIERldmFtIGV0bWVrIGlzdGl5b3IgbXVzdW51ej9cIixcbiAgICBcIn5DT05GSVJNLkNMT1NFX0ZJTEVcIjogXCJEZcSfacWfaWtsaWtsZXJpIGtheWRldG1lZGluaXouIERvc3lhecSxIGthcGF0bWFrIGlzdGVkacSfaW5pemUgZW1pbiBtaXNpbml6P1wiLFxuICAgIFwifkNPTkZJUk0uUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCI6IFwiRG9zeWF5xLEgZW4gc29uIGHDp8SxbGFuIGhhbGluZSBnZXJpIGTDtm5kw7xybWVrIGlzdGVkacSfaW5pemUgZW1pbiBtaXNpbml6P1wiLFxuICAgIFwifkNPTkZJUk0uUkVWRVJUX1RPX1NIQVJFRF9WSUVXXCI6IFwiRG9zeWF5xLEgZW4gc29uIHBheWxhxZ/EsWxhbiBoYWxpbmUgZ2VyaSBkw7ZuZMO8cm1layBpc3RlZGnEn2luaXplIGVtaW4gbWlzaW5pej9cIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5USVRMRVwiOiBcIkVtaW4gbWlzaW5pej9cIixcbiAgICBcIn5DT05GSVJNX0RJQUxPRy5ZRVNcIjogXCJFdmV0XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuTk9cIjogXCJIYXnEsXJcIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5EUk9QX0ZJTEVfSEVSRVwiOiBcIkRvc3lhecSxIGJ1cmF5YSBzw7xyw7xrbGV5aW5peiB2ZXlhIGJpciBkb3N5YSBzZcOnbWVrIGnDp2luIHTEsWtsYXnEsW7EsXouXCIsXG4gICAgXCJ+TE9DQUxfRklMRV9ESUFMT0cuTVVMVElQTEVfRklMRVNfU0VMRUNURURcIjogXCLDnHpnw7xuw7x6LCBhw6dtYWsgacOnaW4geWFsbsSxemNhIGJpciBkb3N5YSBzZcOnZWJpbGlyc2luaXouXCIsXG4gICAgXCJ+TE9DQUxfRklMRV9ESUFMT0cuTVVMVElQTEVfRklMRVNfRFJPUFBFRFwiOiBcIsOcemfDvG7DvHosIGJpciBkb3N5YWRhbiBkYWhhIGZhemxhc8SxbsSxIHPDvHLDvGtsZXllbWV6c2luaXouXCIsXG4gICAgXCJ+SU1QT1JULkxPQ0FMX0ZJTEVcIjogXCJZZXJlbCBEb3N5YVwiLFxuICAgIFwifklNUE9SVC5VUkxcIjogXCJVUkxcIixcbiAgICBcIn5JTVBPUlRfVVJMLk1VTFRJUExFX1VSTFNfRFJPUFBFRFwiOiBcIsOcemfDvG7DvHosIHlhbG7EsXpjYSBiaXIgZG9zeWF5xLEgdXJsIGlsZSBhw6dhYmlsaXJzaW5pei5cIixcbiAgICBcIn5JTVBPUlRfVVJMLlBMRUFTRV9FTlRFUl9VUkxcIjogXCJMw7x0ZmVuIGnDp2VyaSBha3Rhcm1hayBpw6dpbiB1cmwgZ2lyaW5pei5cIixcbiAgICBcIn5VUkxfVEFCLkRST1BfVVJMX0hFUkVcIjogXCJVUkwneWkgYnVyYXlhIHPDvHLDvGtsZXlpbml6IHZleWEgVVJMJ3lpIGdpcmluaXouXCIsXG4gICAgXCJ+VVJMX1RBQi5JTVBPUlRcIjogXCLEsMOnZSBBa3RhclwiLFxuICAgIFwifkNMSUVOVF9FUlJPUi5USVRMRVwiOiBcIkhhdGFcIixcbiAgICBcIn5BTEVSVF9ESUFMT0cuVElUTEVcIjogXCJVeWFyxLFcIixcbiAgICBcIn5BTEVSVF9ESUFMT0cuQ0xPU0VcIjogXCJLYXBhdFwiLFxuICAgIFwifkFMRVJULk5PX1BST1ZJREVSXCI6IFwiQmVsaXJ0aWxlbiBkb3N5YSB1eWd1biBiaXIgc2HEn2xhecSxY8SxIGJ1bHVubWFkxLHEn8SxbmRhbiBhw6fEsWxhbcSxeW9yLlwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5MT0dJTl9CVVRUT05fTEFCRUxcIjogXCJHb29nbGUgaWxlIE90dXJ1bSBBw6dcIixcbiAgICBcIn5HT09HTEVfRFJJVkUuQ09OTkVDVElOR19NRVNTQUdFXCI6IFwiR29vZ2xlJ2EgYmHEn2xhbsSxbMSxeW9yLi4uXCIsXG4gICAgXCJ+R09PR0xFX0RSSVZFLkVSUk9SX01JU1NJTkdfQ0xJRU5USURcIjogXCJHb29nbGUgS3VsbGFuxLFjxLEgS2ltbGnEn2kgYnVsdW5hbWFkxLEuXCIsXG4gICAgXCJ+RE9DU1RPUkUuTE9BRF80MDNfRVJST1JcIjogXCIle2ZpbGVuYW1lfSBkb3N5YXPEsW7EsSBhw6dtYWsgacOnaW4gZ2VyZWtsaSBpemlubGVyZSBzYWhpcCBkZcSfaWxzaW5pei48YnI+PGJyPkXEn2VyIGJhxZ9rYXPEsW7EsW4gZG9zeWFzxLFuxLEga3VsbGFuxLF5b3JzYW7EsXogZG9zeWEgcGF5bGHFn8SxbWRhIG9sbWF5YWJpbGlyLlwiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfU0hBUkVEXzQwNF9FUlJPUlwiOiBcIlBheWxhxZ/EsWxtYWsgaXN0ZW5lbiBkw7Zrw7xtYW4gecO8a2xlbmVtaXlvci48YnI+PGJyPkRvc3lhIHBheWxhxZ/EsW1kYSBvbG1heWFiaWxpcj9cIixcbiAgICBcIn5ET0NTVE9SRS5MT0FEXzQwNF9FUlJPUlwiOiBcIiV7ZmlsZW5hbWV9IGRvc3lhc8SxIHnDvGtsZW5lbWl5b3JcIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFXzQwM19FUlJPUlwiOiBcIicle2ZpbGVuYW1lfScgZG9zeWFzxLFuxLEga2F5ZGV0bWVrIGnDp2luIGdlcmVrbGkgaXppbmxlcmUgc2FoaXAgZGXEn2lsc2luaXogLjxicj48YnI+VGVrcmFyIG90dXJ1bSBhw6dtYW7EsXogZ2VyZWttZWt0ZWRpci5cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0RVUExJQ0FURV9FUlJPUlwiOiBcIiV7ZmlsZW5hbWV9IGRvc3lhc8SxIG9sdcWfdHVydWxhbcSxeW9yLiBEb3N5YSB6YXRlbiBtZXZjdXQuXCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV9FUlJPUl9XSVRIX01FU1NBR0VcIjogXCIle2ZpbGVuYW1lfSBkb3N5YXPEsSBrYXlkZWRpbGVtZXouOiBbJXttZXNzYWdlfV1cIixcbiAgICBcIn5ET0NTVE9SRS5TQVZFX0VSUk9SXCI6IFwiJXtmaWxlbmFtZX0gZG9zeWFzxLEga2F5ZGVkaWxlbWV6LlwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV80MDNfRVJST1JcIjogXCIle2ZpbGVuYW1lfSBkb3N5YXPEsW7EsSBrYWxkxLFybWFrIGnDp2luIGdlcmVrbGkgaXppbmxlcmUgc2FoaXAgZGXEn2lsc2luaXouPGJyPjxicj5UZWtyYXIgb3R1cnVtIGHDp21hbsSxeiBnZXJla21la3RlZGlyLlwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTU9WRV9FUlJPUlwiOiBcIiV7ZmlsZW5hbWV9IGRvc3lhc8SxIGthbGTEsXLEsWxhbWF6XCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FXzQwM19FUlJPUlwiOiBcIiV7ZmlsZW5hbWV9IGRvc3lhc8SxbsSxIHllbmlkZW4gYWRsYW5kxLFybWFrIGnDp2luIGdlcmVrbGkgaXppbmxlcmUgc2FoaXAgZGXEn2lsc2luaXouPGJyPjxicj5UZWtyYXIgb3R1cnVtIGHDp21hbsSxeiBnZXJla21la3RlZGlyLlwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTkFNRV9FUlJPUlwiOiBcIiV7ZmlsZW5hbWV9IGRvc3lhc8SxIHllbmlkZW4gYWRsYW5kxLFyxLFsYW1hZMSxXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfVElUTEVcIjogXCJDb25jb3JkIEJ1bHV0IERlcG9sYW1hIFV5YXLEsXPEsVwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQUxFUlRfU0FWRV9USVRMRVwiOiBcIkNvbmNvcmQgQnVsdXQgRGVwb2xhbWEgVXlhcsSxc8SxXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5DT05GSVJNX1NBVkVfRUxTRVdIRVJFXCI6IFwiRmFya2zEsSBiaXIgeWVyZSBrYXlkZXRcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkNPTkZJUk1fRE9fSVRfTEFURVJcIjogXCJCdW51IHNvbnJhIHlhcGFjYcSfxLFtXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5TSFVUX0RPV05fTUVTU0FHRVwiOiBcIkNvbmNvcmQgQnVsdXQgRGVwb2xhbWEgc2lzdGVtaSBrYXBhdMSxbGTEsSFcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLlBMRUFTRV9TQVZFX0VMU0VXSEVSRVwiOiBcIkzDvHRmZW4gZG9zeWFuxLF6xLEgZmFya2zEsSBiaXIgeWVyZSBrYXlkZWRpbi5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVcIjogXCJTaGFyZWQgdmlldzogXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFX0VOQUJMRURcIjogXCJlbmFibGVkXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNIQVJFX1NUQVRFX0RJU0FCTEVEXCI6IFwiZGlzYWJsZWRcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdcIjogXCJFbmFibGUgc2hhcmluZ1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TVE9QX1NIQVJJTkdcIjogXCJTdG9wIHNoYXJpbmdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuVVBEQVRFX1NIQVJJTkdcIjogXCJVcGRhdGUgc2hhcmVkIHZpZXdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuUFJFVklFV19TSEFSSU5HXCI6IFwiUHJldmlldyBzaGFyZWQgdmlld1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTkFCTEVfU0hBUklOR19NRVNTQUdFXCI6IFwiV2hlbiBzaGFyaW5nIGlzIGVuYWJsZWQsIGEgY29weSBvZiB0aGUgY3VycmVudCB2aWV3IGlzIGNyZWF0ZWQuICBUaGlzIGNvcHkgY2FuIGJlIHNoYXJlZC5cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTElOS19UQUJcIjogXCJMaW5rXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfTUVTU0FHRVwiOiBcIlBhc3RlIHRoaXMgaW50byBhbiBlbWFpbCBvciB0ZXh0IG1lc3NhZ2UgXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVNQkVEX1RBQlwiOiBcIkVtYmVkXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVNQkVEX01FU1NBR0VcIjogXCJFbWJlZCBjb2RlIGZvciBpbmNsdWRpbmcgaW4gd2VicGFnZXMgb3Igb3RoZXIgd2ViLWJhc2VkIGNvbnRlbnRcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCI6IFwiVXNlIHRoaXMgbGluayB3aGVuIGNyZWF0aW5nIGFuIGFjdGl2aXR5IGluIExBUkFcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9DT0RBUF9VUkxcIjogXCJDT0RBUCBTZXJ2ZXIgVVJMOlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0FVVE9MQVVOQ0hfUEFHRVwiOiBcIkF1dG9sYXVuY2ggcGFnZVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0ZVTExTQ1JFRU5fQlVUVE9OX0FORF9TQ0FMSU5HXCI6IFwiRnVsbHNjcmVlbiBidXR0b24gYW5kIHNjYWxpbmdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9MQVVOQ0hfQlVUVE9OX1RFWFRcIjogXCJMYXVuY2ggQnV0dG9uIFRleHQ6XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfRElTUExBWV9WSVNJQklMSVRZX1RPR0dMRVNcIjogXCJEaXNwbGF5IGRhdGEgdmlzaWJpbGl0eSB0b2dnbGVzIG9uIGdyYXBoc1wiLFxuICAgIFwifkNPTkZJUk0uQ0hBTkdFX0xBTkdVQUdFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2hhbmdlIGxhbmd1YWdlcz9cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIn5NRU5VQkFSLlVOVElUTEVEX0RPQ1VNRU5UXCI6IFwi5pyq5ZG95ZCN5paH5Lu2XCIsXG4gICAgXCJ+TUVOVS5ORVdcIjogXCLmlrDlop5cIixcbiAgICBcIn5NRU5VLk9QRU5cIjogXCLplovllZ8gLi4uXCIsXG4gICAgXCJ+TUVOVS5DTE9TRVwiOiBcIumXnOmWiVwiLFxuICAgIFwifk1FTlUuSU1QT1JUX0RBVEFcIjogXCLljK/lhaXos4fmlpkuLi5cIixcbiAgICBcIn5NRU5VLlNBVkVcIjogXCLlhLLlrZhcIixcbiAgICBcIn5NRU5VLlNBVkVfQVNcIjogXCLlj6blrZjoh7MgLi4uXCIsXG4gICAgXCJ+TUVOVS5FWFBPUlRfQVNcIjogXCLljK/lh7rmlofku7YgLi4uXCIsXG4gICAgXCJ+TUVOVS5DUkVBVEVfQ09QWVwiOiBcIuW7uueri+ikh+acrFwiLFxuICAgIFwifk1FTlUuU0hBUkVcIjogXCLliIbkuqsuLi5cIixcbiAgICBcIn5NRU5VLlNIQVJFX0dFVF9MSU5LXCI6IFwi5Y+W5b6X6YCj57WQXCIsXG4gICAgXCJ+TUVOVS5TSEFSRV9VUERBVEVcIjogXCLmm7TmlrDmlofku7blhaflrrlcIixcbiAgICBcIn5NRU5VLkRPV05MT0FEXCI6IFwi5LiL6LyJXCIsXG4gICAgXCJ+TUVOVS5SRU5BTUVcIjogXCLph43mlrDlkb3lkI1cIixcbiAgICBcIn5NRU5VLlJFVkVSVF9UT1wiOiBcIuW+qeWOn+iHsy4uLlwiLFxuICAgIFwifk1FTlUuUkVWRVJUX1RPX0xBU1RfT1BFTkVEXCI6IFwi6ZaL5ZWf54uA5oWLXCIsXG4gICAgXCJ+TUVOVS5SRVZFUlRfVE9fU0hBUkVEX1ZJRVdcIjogXCLliIbkuqvmlofku7ZcIixcbiAgICBcIn5ESUFMT0cuU0FWRVwiOiBcIuWEsuWtmFwiLFxuICAgIFwifkRJQUxPRy5TQVZFX0FTXCI6IFwi5Y+m5a2Y6IezIC4uLlwiLFxuICAgIFwifkRJQUxPRy5FWFBPUlRfQVNcIjogXCLljK/lh7rmlofku7YgLi4uXCIsXG4gICAgXCJ+RElBTE9HLkNSRUFURV9DT1BZXCI6IFwi5bu656uL6KSH5pysIC4uLlwiLFxuICAgIFwifkRJQUxPRy5PUEVOXCI6IFwi6ZaL5ZWfXCIsXG4gICAgXCJ+RElBTE9HLkRPV05MT0FEXCI6IFwi5LiL6LyJXCIsXG4gICAgXCJ+RElBTE9HLlJFTkFNRVwiOiBcIumHjeaWsOWRveWQjVwiLFxuICAgIFwifkRJQUxPRy5TSEFSRURcIjogXCLliIbkuqtcIixcbiAgICBcIn5ESUFMT0cuSU1QT1JUX0RBVEFcIjogXCLph43opoHos4fmlplcIixcbiAgICBcIn5QUk9WSURFUi5MT0NBTF9TVE9SQUdFXCI6IFwi5pys5Zyw5YSy5a2YXCIsXG4gICAgXCJ+UFJPVklERVIuUkVBRF9PTkxZXCI6IFwi5ZSv6K6AXCIsXG4gICAgXCJ+UFJPVklERVIuR09PR0xFX0RSSVZFXCI6IFwiR29vZ2xlIOmbsuerr+ehrOein1wiLFxuICAgIFwiflBST1ZJREVSLkRPQ1VNRU5UX1NUT1JFXCI6IFwiQ29uY29yZCBDbG91ZFwiLFxuICAgIFwiflBST1ZJREVSLkxPQ0FMX0ZJTEVcIjogXCLmnKzlnLDmqpTmoYhcIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZJTkdcIjogXCLlhLLlrZguLi5cIixcbiAgICBcIn5GSUxFX1NUQVRVUy5TQVZFRFwiOiBcIuW3suWEsuWtmOaJgOacieabtOaUuVwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlNBVkVEX1RPX1BST1ZJREVSXCI6IFwi5YSy5a2Y5pu05pS56IezICV7cHJvdmlkZXJOYW1lfVwiLFxuICAgIFwifkZJTEVfU1RBVFVTLlVOU0FWRURcIjogXCLmnKrlhLLlrZhcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5GSUxFTkFNRVwiOiBcIuaqlOahiOWQjeeosVwiLFxuICAgIFwifkZJTEVfRElBTE9HLk9QRU5cIjogXCLplovllZ9cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5TQVZFXCI6IFwi5YSy5a2YXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuQ0FOQ0VMXCI6IFwi5Y+W5raIXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCI6IFwi5Yiq6ZmkXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFX0NPTkZJUk1cIjogXCLmgqjnorrlrpropoHliKrpmaQgJXtmaWxlbmFtZX0/XCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiOiBcIuWIqumZpOaqlOahiFwiLFxuICAgIFwifkZJTEVfRElBTE9HLlJFTU9WRURfTUVTU0FHRVwiOiBcIiV7ZmlsZW5hbWV9IOW3suWIqumZpFwiLFxuICAgIFwifkZJTEVfRElBTE9HLkxPQURJTkdcIjogXCLoroDlj5bkuK0uLi5cIixcbiAgICBcIn5GSUxFX0RJQUxPRy5MT0FEX0ZPTERFUl9FUlJPUlwiOiBcIioqKiDovInlhaXmlofku7bmmYLnmbznlJ/pjK/oqqQgKioqXCIsXG4gICAgXCJ+RklMRV9ESUFMT0cuRE9XTkxPQURcIjogXCLkuIvovIlcIixcbiAgICBcIn5GSUxFX0RJQUxPRy5ET1dOTE9BRF9OT1RFXCI6IFwiTk9URTog5L2/55SoU2FmYXJpIOaqlOahiOWPr+iDveiuiueCuiBcXFwiVW5rbm93blxcXCIg5oKo6ZyA6KaB5Zyo5omL5YuV5pu05pS55Ymv5qqU5ZCN54K6IC5jb2RhcFwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRFwiOiBcIuS4i+i8iVwiLFxuICAgIFwifkRPV05MT0FEX0RJQUxPRy5DQU5DRUxcIjogXCLlj5bmtohcIixcbiAgICBcIn5ET1dOTE9BRF9ESUFMT0cuSU5DTFVERV9TSEFSRV9JTkZPXCI6IFwi5LiL6LyJ55qE5qqU5qGI5Lit5YyF5ZCr5YiG5Lqr55qE5qqU5qGIXCIsXG4gICAgXCJ+UkVOQU1FX0RJQUxPRy5SRU5BTUVcIjogXCLph43mlrDlkb3lkI1cIixcbiAgICBcIn5SRU5BTUVfRElBTE9HLkNBTkNFTFwiOiBcIuWPlua2iFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5DT1BZXCI6IFwi6KSH6KO9XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlZJRVdcIjogXCLmqqLoppZcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ0xPU0VcIjogXCLpl5zplolcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9TVUNDRVNTXCI6IFwi6KiK5oGv5bey6KSH6KO9XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkNPUFlfRVJST1JcIjogXCLmirHmrYnvvIzoqIrmga/nhKHms5XopIfoo71cIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuQ09QWV9USVRMRVwiOiBcIuikh+ijvee1kOaenFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MT05HRVZJVFlfV0FSTklOR1wiOiBcIuiLpeS4gOW5tOaykuS6uuS9v+eUqOacrOaWh+S7tuS5i+ikh+acrO+8jOWJh+atpOikh+acrOWwh+acg+iiq+WIqumZpFwiLFxuICAgIFwiflNIQVJFX1VQREFURS5USVRMRVwiOiBcIuabtOaWsOaWh+S7tuWFp+WuuVwiLFxuICAgIFwiflNIQVJFX1VQREFURS5NRVNTQUdFXCI6IFwi5paH5Lu25YWn5a655bey5pu05pawXCIsXG4gICAgXCJ+Q09ORklSTS5PUEVOX0ZJTEVcIjogXCLlsJrmnKrlhLLlrZjorormm7TvvIzmgqjnorrlrpropoHplovllZ/mlrDnmoTmlofku7Y/XCIsXG4gICAgXCJ+Q09ORklSTS5ORVdfRklMRVwiOiBcIuWwmuacquWEsuWtmOiuiuabtO+8jOaCqOeiuuWumuimgeW7uueri+aWsOeahOaWh+S7tj9cIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9PUEVOXCI6IFwi5pys5paH5Lu26ZyA6KaB5o6I5qyK5omN6IO96ZaL5ZWf77yM5oKo6KaB5YmN5b6A6KqN6K2J5ZeOPyBcIixcbiAgICBcIn5DT05GSVJNLkFVVEhPUklaRV9TQVZFXCI6IFwi5pys5paH5Lu26ZyA6KaB5o6I5qyK5omN6IO95YSy5a2Y77yM5oKo6KaB5YmN5b6A6KqN6K2J5ZeOPyBcIixcbiAgICBcIn5DT05GSVJNLkNMT1NFX0ZJTEVcIjogXCLlsJrmnKrlhLLlrZjorormm7TvvIzmgqjnorrlrpropoHpl5zplonmlofku7bll44/XCIsXG4gICAgXCJ+Q09ORklSTS5SRVZFUlRfVE9fTEFTVF9PUEVORURcIjogXCLmgqjnorrlrpropoHlsIfmlofku7blm57lvqnoh7PmnIDov5HplovllZ/nmoTni4DmhYvll44/XCIsXG4gICAgXCJ+Q09ORklSTS5SRVZFUlRfVE9fU0hBUkVEX1ZJRVdcIjogXCLmgqjnorrlrpropoHlsIfmlofku7blm57lvqnoh7PmnIDov5HliIbkuqvnmoTni4DmhYvll44/XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuVElUTEVcIjogXCLnorrlrpo/XCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuWUVTXCI6IFwi5pivXCIsXG4gICAgXCJ+Q09ORklSTV9ESUFMT0cuTk9cIjogXCLlkKZcIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5EUk9QX0ZJTEVfSEVSRVwiOiBcIuWwh+aqlOahiOaLluabs+iHs+atpOaIlum7nuaTiuS7pemBuOWPluaqlOahiFwiLFxuICAgIFwifkxPQ0FMX0ZJTEVfRElBTE9HLk1VTFRJUExFX0ZJTEVTX1NFTEVDVEVEXCI6IFwi5oqx5q2JLCDmgqjlj6rog73pgbjlj5bkuIDlgIvmqpTmoYhcIixcbiAgICBcIn5MT0NBTF9GSUxFX0RJQUxPRy5NVUxUSVBMRV9GSUxFU19EUk9QUEVEXCI6IFwi5oqx5q2JLCDmgqjnhKHms5Xmi5bmm7PotoXpgY7kuIDlgIvmqpTmoYhcIixcbiAgICBcIn5JTVBPUlQuTE9DQUxfRklMRVwiOiBcIuacrOWcsOaqlOahiFwiLFxuICAgIFwifklNUE9SVC5VUkxcIjogXCLntrLlnYBcIixcbiAgICBcIn5JTVBPUlRfVVJMLk1VTFRJUExFX1VSTFNfRFJPUFBFRFwiOiBcIuaKseatiSwg5oKo5Y+q6IO96YG45pOH5LiA5YCL6ZaL5ZWf57ay5Z2AXCIsXG4gICAgXCJ+SU1QT1JUX1VSTC5QTEVBU0VfRU5URVJfVVJMXCI6IFwi6KuL6Ly45YWl6KaB5Yyv5YWl55qE57ay5Z2AXCIsXG4gICAgXCJ+VVJMX1RBQi5EUk9QX1VSTF9IRVJFXCI6IFwi5Zyo5LiL6Z2i6Ly45YWl57ay5Z2AXCIsXG4gICAgXCJ+VVJMX1RBQi5JTVBPUlRcIjogXCLljK/lhaVcIixcbiAgICBcIn5DTElFTlRfRVJST1IuVElUTEVcIjogXCLpjK/oqqRcIixcbiAgICBcIn5BTEVSVF9ESUFMT0cuVElUTEVcIjogXCLorablkYpcIixcbiAgICBcIn5BTEVSVF9ESUFMT0cuQ0xPU0VcIjogXCLpl5zplolcIixcbiAgICBcIn5BTEVSVC5OT19QUk9WSURFUlwiOiBcIueEoeazlemWi+WVn+aMh+WumueahOaWh+S7tu+8jOWboOeCuuaqlOahiOmhnuWei+S4jeWPl+aUr+aPtFwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5MT0dJTl9CVVRUT05fTEFCRUxcIjogXCLnmbvlhaVHb29nbGVcIixcbiAgICBcIn5HT09HTEVfRFJJVkUuQ09OTkVDVElOR19NRVNTQUdFXCI6IFwi6YCj57WQ6IezIEdvb2dsZS4uLlwiLFxuICAgIFwifkdPT0dMRV9EUklWRS5FUlJPUl9NSVNTSU5HX0NMSUVOVElEXCI6IFwi5ZyoZ29vZ2xlRHJpdmXnqIvluo/kuK3nvLrlsJHluLPmiLbos4fmlplcIixcbiAgICBcIn5ET0NTVE9SRS5MT0FEXzQwM19FUlJPUlwiOiBcIuaCqOaykuacieasiumZkOiugOWPliAle2ZpbGVuYW1lfS48YnI+PGJyPuiLpeaCqOaYr+S9v+eUqOWFtuS7luS6uuWFseS6q+eahOaqlOahiOWJh+WPr+iDveW3sue2k+WPlua2iOWFseS6q1wiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfU0hBUkVEXzQwNF9FUlJPUlwiOiBcIueEoeazleiugOWPluatpOWFseS6q+aqlOahiDxicj48YnI+5Y+v6IO95qqU5qGI5bey5Y+W5raI5YWx5LqrP1wiLFxuICAgIFwifkRPQ1NUT1JFLkxPQURfNDA0X0VSUk9SXCI6IFwi54Sh5rOV6K6A5Y+WICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV80MDNfRVJST1JcIjogXCLmgqjmspLmnInmrIrpmZDlhLLlrZggJyV7ZmlsZW5hbWV9Jy48YnI+PGJyPuaCqOWPr+iDvemcgOimgeWGjeasoeeZu+WFpVwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRFVQTElDQVRFX0VSUk9SXCI6IFwi54Sh5rOV5bu656uLICV7ZmlsZW5hbWV9LiAg5qqU5qGI5bey5a2Y5ZyoXCIsXG4gICAgXCJ+RE9DU1RPUkUuU0FWRV9FUlJPUl9XSVRIX01FU1NBR0VcIjogXCLnhKHms5XlhLLlrZggJXtmaWxlbmFtZX06IFsle21lc3NhZ2V9XVwiLFxuICAgIFwifkRPQ1NUT1JFLlNBVkVfRVJST1JcIjogXCLnhKHms5XlhLLlrZggJXtmaWxlbmFtZX1cIixcbiAgICBcIn5ET0NTVE9SRS5SRU1PVkVfNDAzX0VSUk9SXCI6IFwi5oKo5rKS5pyJ5qyK6ZmQ56e76ZmkICV7ZmlsZW5hbWV9Ljxicj48YnI+5oKo5Y+v6IO96ZyA6KaB5YaN5qyh55m75YWlXCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVNT1ZFX0VSUk9SXCI6IFwi54Sh5rOV56e76ZmkICV7ZmlsZW5hbWV9XCIsXG4gICAgXCJ+RE9DU1RPUkUuUkVOQU1FXzQwM19FUlJPUlwiOiBcIuaCqOaykuacieasiumZkOabtOaUueWQjeeosSAle2ZpbGVuYW1lfS48YnI+PGJyPuaCqOWPr+iDvemcgOimgeWGjeasoeeZu+WFpVwiLFxuICAgIFwifkRPQ1NUT1JFLlJFTkFNRV9FUlJPUlwiOiBcIueEoeazleabtOaUueWQjeeosSAle2ZpbGVuYW1lfVwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9TQVZFX1RJVExFXCI6IFwiQ29uY29yZCBDbG91ZCDorablkYpcIixcbiAgICBcIn5DT05DT1JEX0NMT1VEX0RFUFJFQ0FUSU9OLkFMRVJUX1NBVkVfVElUTEVcIjogXCJDb25jb3JkIENsb3VkIOitpuWRilwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9TQVZFX0VMU0VXSEVSRVwiOiBcIuWEsuWtmOiHs+WFtuS7luS9jee9rlwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uQ09ORklSTV9ET19JVF9MQVRFUlwiOiBcIueojeW+jOaTjeS9nFwiLFxuICAgIFwifkNPTkNPUkRfQ0xPVURfREVQUkVDQVRJT04uU0hVVF9ET1dOX01FU1NBR0VcIjogXCJUaGUgQ29uY29yZCBDbG91ZCBoYXMgYmVlbiBzaHV0IGRvd24hXCIsXG4gICAgXCJ+Q09OQ09SRF9DTE9VRF9ERVBSRUNBVElPTi5QTEVBU0VfU0FWRV9FTFNFV0hFUkVcIjogXCJQbGVhc2Ugc2F2ZSB5b3VyIGRvY3VtZW50cyB0byBhbm90aGVyIGxvY2F0aW9uLlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURVwiOiBcIlNoYXJlZCB2aWV3OiBcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuU0hBUkVfU1RBVEVfRU5BQkxFRFwiOiBcIuWVn+eUqFwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9ESVNBQkxFRFwiOiBcIuS4reatolwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5FTkFCTEVfU0hBUklOR1wiOiBcIkVuYWJsZSBzaGFyaW5nXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLlNUT1BfU0hBUklOR1wiOiBcIlN0b3Agc2hhcmluZ1wiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5VUERBVEVfU0hBUklOR1wiOiBcIuabtOaWsOaWh+S7tuWFp+WuuVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5QUkVWSUVXX1NIQVJJTkdcIjogXCLpoJDnv5Lmlofku7blhaflrrlcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdfTUVTU0FHRVwiOiBcIldoZW4gc2hhcmluZyBpcyBlbmFibGVkLCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlldyBpcyBjcmVhdGVkLiAgVGhpcyBjb3B5IGNhbiBiZSBzaGFyZWQuXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfVEFCXCI6IFwi5paH5Lu26YCj57WQXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxJTktfTUVTU0FHRVwiOiBcIlBhc3RlIHRoaXMgaW50byBhbiBlbWFpbCBvciB0ZXh0IG1lc3NhZ2UgXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVNQkVEX1RBQlwiOiBcIkVtYmVkXCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkVNQkVEX01FU1NBR0VcIjogXCJFbWJlZCBjb2RlIGZvciBpbmNsdWRpbmcgaW4gd2VicGFnZXMgb3Igb3RoZXIgd2ViLWJhc2VkIGNvbnRlbnRcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCI6IFwiVXNlIHRoaXMgbGluayB3aGVuIGNyZWF0aW5nIGFuIGFjdGl2aXR5IGluIExBUkFcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9DT0RBUF9VUkxcIjogXCJDT0RBUCBTZXJ2ZXIgVVJMOlwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0FVVE9MQVVOQ0hfUEFHRVwiOiBcIkF1dG9sYXVuY2ggcGFnZVwiLFxuICAgIFwiflNIQVJFX0RJQUxPRy5MQVJBX0ZVTExTQ1JFRU5fQlVUVE9OX0FORF9TQ0FMSU5HXCI6IFwiRnVsbHNjcmVlbiBidXR0b24gYW5kIHNjYWxpbmdcIixcbiAgICBcIn5TSEFSRV9ESUFMT0cuTEFSQV9MQVVOQ0hfQlVUVE9OX1RFWFRcIjogXCJMYXVuY2ggQnV0dG9uIFRleHQ6XCIsXG4gICAgXCJ+U0hBUkVfRElBTE9HLkxBUkFfRElTUExBWV9WSVNJQklMSVRZX1RPR0dMRVNcIjogXCJEaXNwbGF5IGRhdGEgdmlzaWJpbGl0eSB0b2dnbGVzIG9uIGdyYXBoc1wiLFxuICAgIFwifkNPTkZJUk0uQ0hBTkdFX0xBTkdVQUdFXCI6IFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2hhbmdlIGxhbmd1YWdlcz9cIlxufSIsInVybFBhcmFtcyA9IHJlcXVpcmUgJy4vdXJsLXBhcmFtcydcblxubGFuZ3VhZ2VGaWxlcyA9IFtcbiAge2tleTogJ2RlJyAsICAgY29udGVudHM6IHJlcXVpcmUgJy4vbGFuZy9kZSd9XG4gIHtrZXk6ICdlbCcgLCAgIGNvbnRlbnRzOiByZXF1aXJlICcuL2xhbmcvZWwnfVxuICB7a2V5OiAnZW4tVVMnLCBjb250ZW50czogcmVxdWlyZSAnLi9sYW5nL2VuLVVTJ31cbiAge2tleTogJ2VzJyAsICAgY29udGVudHM6IHJlcXVpcmUgJy4vbGFuZy9lcyd9XG4gIHtrZXk6ICdoZScgLCAgIGNvbnRlbnRzOiByZXF1aXJlICcuL2xhbmcvaGUnfVxuICB7a2V5OiAndHInICwgICBjb250ZW50czogcmVxdWlyZSAnLi9sYW5nL3RyJ31cbiAge2tleTogJ3poLVRXJywgY29udGVudHM6IHJlcXVpcmUgJy4vbGFuZy96aC1UVyd9XG5dXG5cbnRyYW5zbGF0aW9ucyA9ICB7fVxubGFuZ3VhZ2VGaWxlcy5mb3JFYWNoIChsYW5nKSAtPlxuICB0cmFuc2xhdGlvbnNbbGFuZy5rZXldID0gbGFuZy5jb250ZW50c1xuICAjIGFjY2VwdCBmdWxsIGtleSB3aXRoIHJlZ2lvbiBjb2RlIG9yIGp1c3QgdGhlIGxhbmd1YWdlIGNvZGVcbiAgaWYgKGRhc2hMb2MgPSBsYW5nLmtleS5pbmRleE9mKCctJykpID4gMFxuICAgIHRyYW5zbGF0aW9uc1tsYW5nLmtleS5zdWJzdHJpbmcoMCwgZGFzaExvYyldID0gbGFuZy5jb250ZW50c1xuXG5kZWZhdWx0TGFuZyA9IG51bGxcbiMgZGVmYXVsdCB0byBFbmdsaXNoIHVubGVzcyB0aGUgdXNlciBleHByZXNzZXMgYW5vdGhlciBwcmVmZXJlbmNlICh2aWEgVVJMIHBhcmFtIGZvciBub3cpXG5kZWZhdWx0TGFuZyA9IHVybFBhcmFtcy5sYW5nIGlmIHVybFBhcmFtcy5sYW5nIGFuZCB0cmFuc2xhdGlvbnNbdXJsUGFyYW1zLmxhbmddXG4jIHVzZSBsYW5ndWFnZSBvZiBwYWdlLCB3aGljaCBpcyB1c2VkIGJ5IENPREFQLCB3aXRoIHNlcGFyYXRlIGJ1aWxkIGZvciBlYWNoIGxhbmd1YWdlXG5pZiAobm90IGRlZmF1bHRMYW5nPykgYW5kIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nIGFuZCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgaXNudCBcInVua25vd25cIilcbiAgZGVmYXVsdExhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZ1xuZGVmYXVsdExhbmcgPSAnZW4nIGlmIG5vdCBkZWZhdWx0TGFuZz9cblxudmFyUmVnRXhwID0gLyVcXHtcXHMqKFtefVxcc10qKVxccypcXH0vZ1xuXG50cmFuc2xhdGUgPSAoa2V5LCB2YXJzPXt9LCBsYW5nPWRlZmF1bHRMYW5nKSAtPlxuICB0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uc1tsYW5nXT9ba2V5XVxuICB0cmFuc2xhdGlvbiA9IGtleSBpZiBub3QgdHJhbnNsYXRpb24/XG4gIHRyYW5zbGF0aW9uLnJlcGxhY2UgdmFyUmVnRXhwLCAobWF0Y2gsIGtleSkgLT5cbiAgICBpZiB2YXJzLmhhc093blByb3BlcnR5IGtleSB0aGVuIHZhcnNba2V5XSBlbHNlIFwiJyoqIFVLTk9XTiBLRVk6ICN7a2V5fSAqKlwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNsYXRlXG4iLCIvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODgwOTI5XG52YXIgdXJsUGFyYW1zID0ge307XG5pZiAod2luZG93ICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG4gICh3aW5kb3cub25wb3BzdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICBwbCAgICAgPSAvXFwrL2csICAvLyBSZWdleCBmb3IgcmVwbGFjaW5nIGFkZGl0aW9uIHN5bWJvbCB3aXRoIGEgc3BhY2VcbiAgICAgICAgICBzZWFyY2ggPSAvKFteJj1dKyk9PyhbXiZdKikvZyxcbiAgICAgICAgICBkZWNvZGUgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHMucmVwbGFjZShwbCwgXCIgXCIpKTsgfSxcbiAgICAgICAgICBxdWVyeSAgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHNlYXJjaC5leGVjKHF1ZXJ5KSkpXG4gICAgICAgICB1cmxQYXJhbXNbZGVjb2RlKG1hdGNoWzFdKV0gPSBkZWNvZGUobWF0Y2hbMl0pO1xuICB9KSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcmFtcztcbiIsIntkaXYsIGJ1dHRvbn0gPSBSZWFjdC5ET01cblxuTW9kYWxEaWFsb2cgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vbW9kYWwtZGlhbG9nLXZpZXcnXG5cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZGlzcGxheU5hbWU6ICdBbGVydERpYWxvZ1ZpZXcnXG5cbiAgY2xvc2U6IC0+XG4gICAgQHByb3BzLmNsb3NlPygpXG4gICAgQHByb3BzLmNhbGxiYWNrPygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIChNb2RhbERpYWxvZyB7dGl0bGU6IEBwcm9wcy50aXRsZSBvciAodHIgJ35BTEVSVF9ESUFMT0cuVElUTEUnKSwgY2xvc2U6IEBjbG9zZSwgekluZGV4OiA1MDB9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnYWxlcnQtZGlhbG9nJ30sXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ2FsZXJ0LWRpYWxvZy1tZXNzYWdlJywgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtfX2h0bWw6IEBwcm9wcy5tZXNzYWdlfX0pXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ2J1dHRvbnMnfSxcbiAgICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAY2xvc2V9LCB0ciAnfkFMRVJUX0RJQUxPRy5DTE9TRScpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4iLCJNZW51QmFyID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL21lbnUtYmFyLXZpZXcnXG5Qcm92aWRlclRhYmJlZERpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9wcm92aWRlci10YWJiZWQtZGlhbG9nLXZpZXcnXG5Eb3dubG9hZERpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9kb3dubG9hZC1kaWFsb2ctdmlldydcblJlbmFtZURpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9yZW5hbWUtZGlhbG9nLXZpZXcnXG5TaGFyZURpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9zaGFyZS1kaWFsb2ctdmlldydcbkJsb2NraW5nTW9kYWwgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vYmxvY2tpbmctbW9kYWwtdmlldydcbkFsZXJ0RGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL2FsZXJ0LWRpYWxvZy12aWV3J1xuQ29uZmlybURpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9jb25maXJtLWRpYWxvZy12aWV3J1xuSW1wb3J0VGFiYmVkRGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL2ltcG9ydC10YWJiZWQtZGlhbG9nLXZpZXcnXG5cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuaXNTdHJpbmcgPSByZXF1aXJlICcuLi91dGlscy9pcy1zdHJpbmcnXG5cbntkaXYsIGlmcmFtZX0gPSBSZWFjdC5ET01cblxuSW5uZXJBcHAgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZGlzcGxheU5hbWU6ICdDbG91ZEZpbGVNYW5hZ2VySW5uZXJBcHAnXG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAobmV4dFByb3BzKSAtPlxuICAgIG5leHRQcm9wcy5hcHAgaXNudCBAcHJvcHMuYXBwXG5cbiAgcmVuZGVyOiAtPlxuICAgIChkaXYge2NsYXNzTmFtZTogJ2lubmVyQXBwJ30sXG4gICAgICAoaWZyYW1lIHtzcmM6IEBwcm9wcy5hcHB9KVxuICAgIClcblxuQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ0Nsb3VkRmlsZU1hbmFnZXInXG5cbiAgZ2V0RmlsZW5hbWU6IChtZXRhZGF0YSkgLT5cbiAgICBpZiBtZXRhZGF0YT8uaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpIGFuZCBtZXRhZGF0YS5uYW1lPy5sZW5ndGggPiAwIHRoZW4gbWV0YWRhdGEubmFtZSBlbHNlIG51bGxcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZmlsZW5hbWU6IEBnZXRGaWxlbmFtZSBAcHJvcHMuY2xpZW50LnN0YXRlLm1ldGFkYXRhXG4gICAgcHJvdmlkZXI6IEBwcm9wcy5jbGllbnQuc3RhdGUubWV0YWRhdGE/LnByb3ZpZGVyXG4gICAgbWVudUl0ZW1zOiBAcHJvcHMuY2xpZW50Ll91aS5tZW51Py5pdGVtcyBvciBbXVxuICAgIG1lbnVPcHRpb25zOiBAcHJvcHMudWk/Lm1lbnVCYXIgb3Ige31cbiAgICBwcm92aWRlckRpYWxvZzogbnVsbFxuICAgIGRvd25sb2FkRGlhbG9nOiBudWxsXG4gICAgcmVuYW1lRGlhbG9nOiBudWxsXG4gICAgc2hhcmVEaWFsb2c6IG51bGxcbiAgICBhbGVydERpYWxvZzogbnVsbFxuICAgIGNvbmZpcm1EaWFsb2c6IG51bGxcbiAgICBkaXJ0eTogZmFsc2VcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IC0+XG4gICAgQHByb3BzLmNsaWVudC5saXN0ZW4gKGV2ZW50KSA9PlxuICAgICAgZmlsZVN0YXR1cyA9IGlmIGV2ZW50LnN0YXRlLnNhdmluZ1xuICAgICAgICB7bWVzc2FnZTogdHIoJ35GSUxFX1NUQVRVUy5TQVZJTkcnKSwgdHlwZTogJ2luZm8nfVxuICAgICAgZWxzZSBpZiBldmVudC5zdGF0ZS5zYXZlZFxuICAgICAgICBwcm92aWRlck5hbWUgPSBldmVudC5zdGF0ZS5tZXRhZGF0YS5wcm92aWRlcj8uZGlzcGxheU5hbWVcbiAgICAgICAgbWVzc2FnZSA9IGlmIHByb3ZpZGVyTmFtZSBcXFxuICAgICAgICAgICAgICAgICAgICB0aGVuIHRyKCd+RklMRV9TVEFUVVMuU0FWRURfVE9fUFJPVklERVInLCB7IHByb3ZpZGVyTmFtZTogcHJvdmlkZXJOYW1lIH0pIFxcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdHIoJ35GSUxFX1NUQVRVUy5TQVZFRCcpXG4gICAgICAgIHttZXNzYWdlOiBtZXNzYWdlLCB0eXBlOiAnaW5mbyd9XG4gICAgICBlbHNlIGlmIGV2ZW50LnN0YXRlLmRpcnR5XG4gICAgICAgIHttZXNzYWdlOiB0cignfkZJTEVfU1RBVFVTLlVOU0FWRUQnKSwgdHlwZTogJ2FsZXJ0J31cbiAgICAgIGVsc2VcbiAgICAgICAgbnVsbFxuICAgICAgQHNldFN0YXRlXG4gICAgICAgIGZpbGVuYW1lOiBAZ2V0RmlsZW5hbWUgZXZlbnQuc3RhdGUubWV0YWRhdGFcbiAgICAgICAgcHJvdmlkZXI6IGV2ZW50LnN0YXRlLm1ldGFkYXRhPy5wcm92aWRlclxuICAgICAgICBmaWxlU3RhdHVzOiBmaWxlU3RhdHVzXG5cbiAgICAgIHN3aXRjaCBldmVudC50eXBlXG4gICAgICAgIHdoZW4gJ2Nvbm5lY3RlZCdcbiAgICAgICAgICBAc2V0U3RhdGUgbWVudUl0ZW1zOiBAcHJvcHMuY2xpZW50Ll91aS5tZW51Py5pdGVtcyBvciBbXVxuXG4gICAgQHByb3BzLmNsaWVudC5fdWkubGlzdGVuIChldmVudCkgPT5cbiAgICAgIHN3aXRjaCBldmVudC50eXBlXG4gICAgICAgIHdoZW4gJ3Nob3dQcm92aWRlckRpYWxvZydcbiAgICAgICAgICBAc2V0U3RhdGUgcHJvdmlkZXJEaWFsb2c6IGV2ZW50LmRhdGFcbiAgICAgICAgd2hlbiAnc2hvd0Rvd25sb2FkRGlhbG9nJ1xuICAgICAgICAgIEBzZXRTdGF0ZSBkb3dubG9hZERpYWxvZzogZXZlbnQuZGF0YVxuICAgICAgICB3aGVuICdzaG93UmVuYW1lRGlhbG9nJ1xuICAgICAgICAgIEBzZXRTdGF0ZSByZW5hbWVEaWFsb2c6IGV2ZW50LmRhdGFcbiAgICAgICAgd2hlbiAnc2hvd0ltcG9ydERpYWxvZydcbiAgICAgICAgICBAc2V0U3RhdGUgaW1wb3J0RGlhbG9nOiBldmVudC5kYXRhXG4gICAgICAgIHdoZW4gJ3Nob3dTaGFyZURpYWxvZydcbiAgICAgICAgICBAc2V0U3RhdGUgc2hhcmVEaWFsb2c6IGV2ZW50LmRhdGFcbiAgICAgICAgd2hlbiAnc2hvd0Jsb2NraW5nTW9kYWwnXG4gICAgICAgICAgQHNldFN0YXRlIGJsb2NraW5nTW9kYWxQcm9wczogZXZlbnQuZGF0YVxuICAgICAgICB3aGVuICdoaWRlQmxvY2tpbmdNb2RhbCdcbiAgICAgICAgICBAc2V0U3RhdGUgYmxvY2tpbmdNb2RhbFByb3BzOiBudWxsXG4gICAgICAgIHdoZW4gJ3Nob3dBbGVydERpYWxvZydcbiAgICAgICAgICBAc2V0U3RhdGUgYWxlcnREaWFsb2c6IGV2ZW50LmRhdGFcbiAgICAgICAgd2hlbiAnc2hvd0NvbmZpcm1EaWFsb2cnXG4gICAgICAgICAgQHNldFN0YXRlIGNvbmZpcm1EaWFsb2c6IGV2ZW50LmRhdGFcbiAgICAgICAgd2hlbiAnYXBwZW5kTWVudUl0ZW0nXG4gICAgICAgICAgQHN0YXRlLm1lbnVJdGVtcy5wdXNoIGV2ZW50LmRhdGFcbiAgICAgICAgICBAc2V0U3RhdGUgbWVudUl0ZW1zOiBAc3RhdGUubWVudUl0ZW1zXG4gICAgICAgIHdoZW4gJ3ByZXBlbmRNZW51SXRlbSdcbiAgICAgICAgICBAc3RhdGUubWVudUl0ZW1zLnVuc2hpZnQgZXZlbnQuZGF0YVxuICAgICAgICAgIEBzZXRTdGF0ZSBtZW51SXRlbXM6IEBzdGF0ZS5tZW51SXRlbXNcbiAgICAgICAgd2hlbiAncmVwbGFjZU1lbnVJdGVtJ1xuICAgICAgICAgIGluZGV4ID0gQF9nZXRNZW51SXRlbUluZGV4IGV2ZW50LmRhdGEua2V5XG4gICAgICAgICAgaWYgaW5kZXggaXNudCAtMVxuICAgICAgICAgICAgQHN0YXRlLm1lbnVJdGVtc1tpbmRleF0gPSBldmVudC5kYXRhLml0ZW1cbiAgICAgICAgICAgIEBzZXRTdGF0ZSBtZW51SXRlbXM6IEBzdGF0ZS5tZW51SXRlbXNcbiAgICAgICAgd2hlbiAnaW5zZXJ0TWVudUl0ZW1CZWZvcmUnXG4gICAgICAgICAgaW5kZXggPSBAX2dldE1lbnVJdGVtSW5kZXggZXZlbnQuZGF0YS5rZXlcbiAgICAgICAgICBpZiBpbmRleCBpc250IC0xXG4gICAgICAgICAgICBpZiBpbmRleCBpcyAwXG4gICAgICAgICAgICAgIEBzdGF0ZS5tZW51SXRlbXMudW5zaGlmdCBldmVudC5kYXRhLml0ZW1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgQHN0YXRlLm1lbnVJdGVtcy5zcGxpY2UgaW5kZXgsIDAsIGV2ZW50LmRhdGEuaXRlbVxuICAgICAgICAgICAgQHNldFN0YXRlIG1lbnVJdGVtczogQHN0YXRlLm1lbnVJdGVtc1xuICAgICAgICB3aGVuICdpbnNlcnRNZW51SXRlbUFmdGVyJ1xuICAgICAgICAgIGluZGV4ID0gQF9nZXRNZW51SXRlbUluZGV4IGV2ZW50LmRhdGEua2V5XG4gICAgICAgICAgaWYgaW5kZXggaXNudCAtMVxuICAgICAgICAgICAgaWYgaW5kZXggaXMgQHN0YXRlLm1lbnVJdGVtcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIEBzdGF0ZS5tZW51SXRlbXMucHVzaCBldmVudC5kYXRhLml0ZW1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgQHN0YXRlLm1lbnVJdGVtcy5zcGxpY2UgaW5kZXggKyAxLCAwLCBldmVudC5kYXRhLml0ZW1cbiAgICAgICAgICAgIEBzZXRTdGF0ZSBtZW51SXRlbXM6IEBzdGF0ZS5tZW51SXRlbXNcbiAgICAgICAgd2hlbiAnc2V0TWVudUJhckluZm8nXG4gICAgICAgICAgQHN0YXRlLm1lbnVPcHRpb25zLmluZm8gPSBldmVudC5kYXRhXG4gICAgICAgICAgQHNldFN0YXRlIG1lbnVPcHRpb25zOiBAc3RhdGUubWVudU9wdGlvbnNcblxuICBfZ2V0TWVudUl0ZW1JbmRleDogKGtleSkgLT5cbiAgICBpZiBpc1N0cmluZyBrZXlcbiAgICAgIGZvciBpdGVtLCBpbmRleCBpbiBAc3RhdGUubWVudUl0ZW1zXG4gICAgICAgIHJldHVybiBpbmRleCBpZiBpdGVtLmtleSBpcyBrZXlcbiAgICAgIC0xXG4gICAgZWxzZVxuICAgICAgaW5kZXggPSBwYXJzZUludCBrZXksIDEwXG4gICAgICBpZiBpc05hTihpbmRleCkgb3IgaW5kZXggPCAwIG9yIGluZGV4ID4gQHN0YXRlLm1lbnVJdGVtcy5sZW5ndGggLSAxXG4gICAgICAgIC0xXG4gICAgICBlbHNlXG4gICAgICAgIGluZGV4XG5cbiAgY2xvc2VEaWFsb2dzOiAtPlxuICAgIEBzZXRTdGF0ZVxuICAgICAgcHJvdmlkZXJEaWFsb2c6IG51bGxcbiAgICAgIGRvd25sb2FkRGlhbG9nOiBudWxsXG4gICAgICByZW5hbWVEaWFsb2c6IG51bGxcbiAgICAgIHNoYXJlRGlhbG9nOiBudWxsXG4gICAgICBpbXBvcnREaWFsb2c6IG51bGxcblxuICBjbG9zZUFsZXJ0OiAtPlxuICAgIEBzZXRTdGF0ZSBhbGVydERpYWxvZzogbnVsbFxuXG4gIGNsb3NlQ29uZmlybTogLT5cbiAgICBAc2V0U3RhdGUgY29uZmlybURpYWxvZzogbnVsbFxuXG4gIHJlbmRlckRpYWxvZ3M6IC0+XG4gICAgKGRpdiB7fSxcbiAgICAgIGlmIEBzdGF0ZS5ibG9ja2luZ01vZGFsUHJvcHNcbiAgICAgICAgKEJsb2NraW5nTW9kYWwgQHN0YXRlLmJsb2NraW5nTW9kYWxQcm9wcylcbiAgICAgIGVsc2UgaWYgQHN0YXRlLnByb3ZpZGVyRGlhbG9nXG4gICAgICAgIChQcm92aWRlclRhYmJlZERpYWxvZyB7Y2xpZW50OiBAcHJvcHMuY2xpZW50LCBkaWFsb2c6IEBzdGF0ZS5wcm92aWRlckRpYWxvZywgY2xvc2U6IEBjbG9zZURpYWxvZ3N9KVxuICAgICAgZWxzZSBpZiBAc3RhdGUuZG93bmxvYWREaWFsb2dcbiAgICAgICAgKERvd25sb2FkRGlhbG9nIHtjbGllbnQ6IEBwcm9wcy5jbGllbnQsIGZpbGVuYW1lOiBAc3RhdGUuZG93bmxvYWREaWFsb2cuZmlsZW5hbWUsIG1pbWVUeXBlOiBAc3RhdGUuZG93bmxvYWREaWFsb2cubWltZVR5cGUsIGNvbnRlbnQ6IEBzdGF0ZS5kb3dubG9hZERpYWxvZy5jb250ZW50LCBjbG9zZTogQGNsb3NlRGlhbG9nc30pXG4gICAgICBlbHNlIGlmIEBzdGF0ZS5yZW5hbWVEaWFsb2dcbiAgICAgICAgKFJlbmFtZURpYWxvZyB7ZmlsZW5hbWU6IEBzdGF0ZS5yZW5hbWVEaWFsb2cuZmlsZW5hbWUsIGNhbGxiYWNrOiBAc3RhdGUucmVuYW1lRGlhbG9nLmNhbGxiYWNrLCBjbG9zZTogQGNsb3NlRGlhbG9nc30pXG4gICAgICBlbHNlIGlmIEBzdGF0ZS5pbXBvcnREaWFsb2dcbiAgICAgICAgKEltcG9ydFRhYmJlZERpYWxvZyB7Y2xpZW50OiBAcHJvcHMuY2xpZW50LCBkaWFsb2c6IEBzdGF0ZS5pbXBvcnREaWFsb2csIGNsb3NlOiBAY2xvc2VEaWFsb2dzfSlcbiAgICAgIGVsc2UgaWYgQHN0YXRlLnNoYXJlRGlhbG9nXG4gICAgICAgIChTaGFyZURpYWxvZyB7Y2xpZW50OiBAcHJvcHMuY2xpZW50LCBlbmFibGVMYXJhU2hhcmluZzogQHByb3BzLmVuYWJsZUxhcmFTaGFyaW5nLCBjbG9zZTogQGNsb3NlRGlhbG9ncywgc2V0dGluZ3M6IEBwcm9wcy51aT8uc2hhcmVEaWFsb2cgb3Ige319KVxuXG4gICAgICAjIGFsZXJ0IGFuZCBjb25maXJtIGRpYWxvZ3MgY2FuIGJlIG92ZXJsYXllZCBvbiBvdGhlciBkaWFsb2dzXG4gICAgICBpZiBAc3RhdGUuYWxlcnREaWFsb2dcbiAgICAgICAgKEFsZXJ0RGlhbG9nIHt0aXRsZTogQHN0YXRlLmFsZXJ0RGlhbG9nLnRpdGxlLCBtZXNzYWdlOiBAc3RhdGUuYWxlcnREaWFsb2cubWVzc2FnZSwgY2FsbGJhY2s6IEBzdGF0ZS5hbGVydERpYWxvZy5jYWxsYmFjaywgY2xvc2U6IEBjbG9zZUFsZXJ0fSlcbiAgICAgIGlmIEBzdGF0ZS5jb25maXJtRGlhbG9nXG4gICAgICAgIChDb25maXJtRGlhbG9nIF8ubWVyZ2Uge30sIEBzdGF0ZS5jb25maXJtRGlhbG9nLCB7IGNsb3NlOiBAY2xvc2VDb25maXJtIH0pXG4gICAgKVxuXG4gIHJlbmRlcjogLT5cbiAgICBtZW51SXRlbXMgPSB1bmxlc3MgQHByb3BzLmhpZGVNZW51QmFyIHRoZW4gQHN0YXRlLm1lbnVJdGVtcyBlbHNlIFtdXG4gICAgaWYgQHByb3BzLmFwcE9yTWVudUVsZW1JZFxuICAgICAgIyBDU1MgY2xhc3MgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGluIGFwcCAoaWZyYW1lKSBvciB2aWV3IChtZW51YmFyLW9ubHkpIG1vZGVcbiAgICAgIChkaXYge2NsYXNzTmFtZTogaWYgQHByb3BzLnVzaW5nSWZyYW1lIHRoZW4gJ2FwcCcgZWxzZSAndmlldycgfSxcbiAgICAgICAgKE1lbnVCYXIge2NsaWVudDogQHByb3BzLmNsaWVudCwgZmlsZW5hbWU6IEBzdGF0ZS5maWxlbmFtZSwgcHJvdmlkZXI6IEBzdGF0ZS5wcm92aWRlciwgZmlsZVN0YXR1czogQHN0YXRlLmZpbGVTdGF0dXMsIGl0ZW1zOiBtZW51SXRlbXMsIG9wdGlvbnM6IEBzdGF0ZS5tZW51T3B0aW9uc30pXG4gICAgICAgICMgb25seSByZW5kZXIgdGhlIHdyYXBwZWQgY2xpZW50IGFwcCBpbiBhcHAgKGlmcmFtZSkgbW9kZVxuICAgICAgICBpZiBAcHJvcHMudXNpbmdJZnJhbWVcbiAgICAgICAgICAoSW5uZXJBcHAge2FwcDogQHByb3BzLmFwcH0pXG4gICAgICAgIEByZW5kZXJEaWFsb2dzKClcbiAgICAgIClcbiAgICBlbHNlIGlmIEBzdGF0ZS5wcm92aWRlckRpYWxvZyBvciBAc3RhdGUuZG93bmxvYWREaWFsb2dcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2FwcCd9LFxuICAgICAgICBAcmVuZGVyRGlhbG9ncygpXG4gICAgICApXG4gICAgZWxzZVxuICAgICAgbnVsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcFxuIiwiQXV0aG9yaXplTWl4aW4gPVxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgQF9pc0F1dGhvcml6ZWQgPSBmYWxzZVxuICAgIGF1dGhvcml6ZWQ6IGZhbHNlXG5cbiAgIyBUaGUgY29uc3RyYWludHMgaGVyZSBhcmUgc29tZXdoYXQgc3VidGxlLiBXZSB3YW50IHRvIHRyeSB0b1xuICAjIGRldGVybWluZSB3aGV0aGVyIHRoZSB1c2VyIGlzIGF1dGhvcml6ZWQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIsXG4gICMgYmVjYXVzZSBhdXRob3JpemF0aW9uIHN0YXR1cyBjYW4gYWZmZWN0IHJlbmRlcmluZy4gVGh1cywgd2Ugd2FudFxuICAjIHRvIHBlcmZvcm0gdGhlIGNoZWNrIGluIGNvbXBvbmVudFdpbGxNb3VudCgpLiBTb21lIHByb3ZpZGVyc1xuICAjIGNhbi93aWxsIHJlc3BvbmQgaW1tZWRpYXRlbHksIGVpdGhlciBiZWNhdXNlIHRoZXkgZG9uJ3QgcmVxdWlyZVxuICAjIGF1dGhvcml6YXRpb24gb3IgYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5IGF1dGhvcml6ZWQuIFVuZm9ydHVuYXRlbHksXG4gICMgc2V0U3RhdGUoKSBjYW4ndCBiZSBjYWxsZWQgaW4gY29tcG9uZW50V2lsbE1vdW50KCksIHNvIGlmIHdlIGdldFxuICAjIGFuIGltbWVkaWF0ZSByZXNwb25zZSwgd2UgbmVlZCB0byBzdG9yZSBpdCBpbiBhbiBpbnN0YW5jZSB2YXJpYWJsZS5cbiAgIyBUaGVuIGluIGNvbXBvbmVudERpZE1vdW50KCksIHdlIGNhbiBwcm9wYWdhdGUgdGhlIGluc3RhbmNlIHZhcmlhYmxlXG4gICMgdG8gdGhlIHN0YXRlIHZpYSBhIGNhbGwgdG8gc2V0U3RhdGUoKS4gU29tZSBwcm92aWRlcnMgd2lsbCBuZWVkIHRvXG4gICMgbWFrZSBhbiBhc3luY2hyb25vdXMgY2FsbCB0byBkZXRlcm1pbmUgYXV0aG9yaXphdGlvbiBzdGF0dXMuIFRoaXNcbiAgIyBjYWxsIG1heSBjb21wbGV0ZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciwgaS5lLiBiZWZvcmUgb3JcbiAgIyBhZnRlciB0aGUgY29tcG9uZW50RGlkTW91bnQoKSBtZXRob2QuIE9uY2UgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLFxuICAjIHRoZSBjYWxsIHRvIHNldFN0YXRlKCkgaXMgcmVxdWlyZWQgdG8gc2V0IHRoZSBzdGF0ZSBhbmQgdHJpZ2dlciBhXG4gICMgcmUtcmVuZGVyLiBJbiB0aGUgZW5kIHdlIG5lZWQgdG8gbWFpbnRhaW4gYm90aCB0aGUgaW5zdGFuY2UgdmFyaWFibGVcbiAgIyBhbmQgdGhlIHN0YXRlIHRvIHRyYWNrIHRoZSBhdXRob3JpemF0aW9uIHN0YXR1cywgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZVxuICAjIGF1dGhvcml6YXRpb24gc3RhdHVzLCBhbmQgcmUtcmVuZGVyIHdoZW4gYXV0aG9yaXphdGlvbiBzdGF0dXMgY2hhbmdlcy5cblxuICBjb21wb25lbnRXaWxsTW91bnQ6IC0+XG4gICAgIyBDaGVjayBmb3IgYXV0aG9yaXphdGlvbiBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlci4gUHJvdmlkZXJzIHRoYXRcbiAgICAjIGRvbid0IHJlcXVpcmUgYXV0aG9yaXphdGlvbiBvciBhcmUgYWxyZWFkeSBhdXRob3JpemVkIHdpbGwgcmVzcG9uZFxuICAgICMgaW1tZWRpYXRlbHksIGJ1dCBzaW5jZSB0aGUgY29tcG9uZW50IGlzbid0IG1vdW50ZWQgeWV0IHdlIGNhbid0XG4gICAgIyBjYWxsIHNldFN0YXRlLCBzbyB3ZSBzZXQgYW4gaW5zdGFuY2UgdmFyaWFibGUgYW5kIHVwZGF0ZSBzdGF0ZVxuICAgICMgaW4gY29tcG9uZW50RGlkTW91bnQoKS4gUHJvdmlkZXJzIHRoYXQgcmVxdWlyZSBhc3luY2hyb25vdXMgY2hlY2tzXG4gICAgIyBmb3IgYXV0aG9yaXphdGlvbiBtYXkgcmV0dXJuIGJlZm9yZSBvciBhZnRlciB0aGUgZmlyc3QgcmVuZGVyLCBzb1xuICAgICMgY29kZSBzaG91bGQgYmUgcHJlcGFyZWQgZm9yIGVpdGhlciBldmVudHVhbGl0eS5cbiAgICBAcHJvcHMucHJvdmlkZXIuYXV0aG9yaXplZCAoYXV0aG9yaXplZCkgPT5cbiAgICAgICMgYWx3YXlzIHNldCB0aGUgaW5zdGFuY2UgdmFyaWFibGVcbiAgICAgIEBfaXNBdXRob3JpemVkID0gYXV0aG9yaXplZFxuICAgICAgIyBzZXQgdGhlIHN0YXRlIGlmIHdlIGNhblxuICAgICAgaWYgQF9pc01vdW50ZWRcbiAgICAgICAgQHNldFN0YXRlIGF1dGhvcml6ZWQ6IGF1dGhvcml6ZWRcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBAX2lzTW91bnRlZCA9IHRydWVcbiAgICAjIHN5bmNocm9uaXplIHN0YXRlIGlmIG5lY2Vzc2FyeVxuICAgIGlmIEBzdGF0ZS5hdXRob3JpemVkIGlzbnQgQF9pc0F1dGhvcml6ZWRcbiAgICAgIEBzZXRTdGF0ZSBhdXRob3JpemVkOiBAX2lzQXV0aG9yaXplZFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIEBfaXNNb3VudGVkID0gZmFsc2VcblxuICByZW5kZXI6IC0+XG4gICAgaWYgQF9pc0F1dGhvcml6ZWQgb3IgQHN0YXRlLmF1dGhvcml6ZWRcbiAgICAgIEByZW5kZXJXaGVuQXV0aG9yaXplZCgpXG4gICAgZWxzZVxuICAgICAgQHByb3BzLnByb3ZpZGVyLnJlbmRlckF1dGhvcml6YXRpb25EaWFsb2coKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhvcml6ZU1peGluXG4iLCJNb2RhbCA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9tb2RhbC12aWV3J1xue2RpdiwgaX0gPSBSZWFjdC5ET01cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnQmxvY2tpbmdNb2RhbCdcblxuICBjbG9zZTogLT5cbiAgICBAcHJvcHMuY2xvc2U/KClcblxuICAjIHVzZWQgYnkgQ09EQVAgdG8gZGlzbWlzcyB0aGUgc3RhcnR1cCBkaWFsb2cgaWYgYSBmaWxlIGlzIGRyb3BwZWQgb24gaXRcbiAgZHJvcDogKGUpIC0+XG4gICAgQHByb3BzLm9uRHJvcD8gZVxuXG4gIHJlbmRlcjogLT5cbiAgICAoTW9kYWwge2Nsb3NlOiBAcHJvcHMuY2xvc2V9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nJywgb25Ecm9wOiBAZHJvcH0sXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ21vZGFsLWRpYWxvZy13cmFwcGVyJ30sXG4gICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nLXRpdGxlJ30sXG4gICAgICAgICAgICBAcHJvcHMudGl0bGUgb3IgJ1VudGl0bGVkIERpYWxvZydcbiAgICAgICAgICApXG4gICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nLXdvcmtzcGFjZSd9LFxuICAgICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nLWJsb2NraW5nLW1lc3NhZ2UnfSwgQHByb3BzLm1lc3NhZ2UpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwie2RpdiwgYnV0dG9ufSA9IFJlYWN0LkRPTVxuXG5Nb2RhbERpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9tb2RhbC1kaWFsb2ctdmlldydcblxudHIgPSByZXF1aXJlICcuLi91dGlscy90cmFuc2xhdGUnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ0NvbmZpcm1EaWFsb2dWaWV3J1xuXG4gIGNvbmZpcm06IC0+XG4gICAgQHByb3BzLmNhbGxiYWNrPygpXG4gICAgQHByb3BzLmNsb3NlPygpXG5cbiAgcmVqZWN0OiAtPlxuICAgIEBwcm9wcy5yZWplY3RDYWxsYmFjaz8oKVxuICAgIEBwcm9wcy5jbG9zZT8oKVxuXG4gIHJlbmRlcjogLT5cbiAgICAoTW9kYWxEaWFsb2cge3RpdGxlOiAoQHByb3BzLnRpdGxlIG9yIHRyICd+Q09ORklSTV9ESUFMT0cuVElUTEUnKSwgY2xvc2U6IEByZWplY3QsIHpJbmRleDogNTAwfSxcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2NvbmZpcm0tZGlhbG9nJ30sXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ2NvbmZpcm0tZGlhbG9nLW1lc3NhZ2UnLCBkYW5nZXJvdXNseVNldElubmVySFRNTDoge19faHRtbDogQHByb3BzLm1lc3NhZ2V9fSlcbiAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnYnV0dG9ucyd9LFxuICAgICAgICAgIChidXR0b24ge29uQ2xpY2s6IEBjb25maXJtfSwgQHByb3BzLnllc1RpdGxlIG9yIHRyICd+Q09ORklSTV9ESUFMT0cuWUVTJylcbiAgICAgICAgICAoKGJ1dHRvbiB7b25DbGljazogQHJlamVjdH0sIEBwcm9wcy5ub1RpdGxlIG9yIHRyICd+Q09ORklSTV9ESUFMT0cuTk8nKSBpZiBub3QgQHByb3BzLmhpZGVOb0J1dHRvbilcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiIsIntkaXYsIGlucHV0LCBhLCBidXR0b259ID0gUmVhY3QuRE9NXG5cbk1vZGFsRGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL21vZGFsLWRpYWxvZy12aWV3J1xuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuLi9wcm92aWRlcnMvcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuXG50ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnRG93bmxvYWREaWFsb2dWaWV3J1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBmaWxlbmFtZSA9IENsb3VkTWV0YWRhdGEud2l0aEV4dGVuc2lvbihAcHJvcHMuZmlsZW5hbWUgb3IgKHRyIFwifk1FTlVCQVIuVU5USVRMRURfRE9DVU1FTlRcIiksICdqc29uJylcbiAgICBzdGF0ZSA9XG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgIHRyaW1tZWRGaWxlbmFtZTogQHRyaW0gZmlsZW5hbWVcbiAgICAgIGluY2x1ZGVTaGFyZUluZm86IGZhbHNlXG4gICAgICBzaGFyZWQ6IEBwcm9wcy5jbGllbnQuaXNTaGFyZWQoKVxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIEByZWZzLmZpbGVuYW1lLmZvY3VzKClcblxuICB1cGRhdGVGaWxlbmFtZTogLT5cbiAgICBmaWxlbmFtZSA9IEByZWZzLmZpbGVuYW1lLnZhbHVlXG4gICAgQHNldFN0YXRlXG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgIHRyaW1tZWRGaWxlbmFtZTogQHRyaW0gZmlsZW5hbWVcblxuICB1cGRhdGVJbmNsdWRlU2hhcmVJbmZvOiAtPlxuICAgIEBzZXRTdGF0ZSBpbmNsdWRlU2hhcmVJbmZvOiBAcmVmcy5pbmNsdWRlU2hhcmVJbmZvLmNoZWNrZWRcblxuICB0cmltOiAocykgLT5cbiAgICBzLnJlcGxhY2UgL15cXHMrfFxccyskLywgJydcblxuICBkb3dubG9hZDogKGUsIHNpbXVsYXRlQ2xpY2spIC0+XG4gICAgaWYgbm90IEBkb3dubG9hZERpc2FibGVkKClcbiAgICAgIEByZWZzLmRvd25sb2FkLnNldEF0dHJpYnV0ZSAnaHJlZicsIEBwcm9wcy5jbGllbnQuZ2V0RG93bmxvYWRVcmwoQHByb3BzLmNvbnRlbnQsIEBzdGF0ZS5pbmNsdWRlU2hhcmVJbmZvKVxuICAgICAgQHJlZnMuZG93bmxvYWQuY2xpY2soKSBpZiBzaW11bGF0ZUNsaWNrXG4gICAgICBAcHJvcHMuY2xvc2UoKVxuICAgIGVsc2VcbiAgICAgIGU/LnByZXZlbnREZWZhdWx0KClcbiAgICAgIEByZWZzLmZpbGVuYW1lLmZvY3VzKClcblxuICBkb3dubG9hZERpc2FibGVkOiAtPlxuICAgIEBzdGF0ZS50cmltbWVkRmlsZW5hbWUubGVuZ3RoIGlzIDBcblxuICB3YXRjaEZvckVudGVyOiAoZSkgLT5cbiAgICBpZiBlLmtleUNvZGUgaXMgMTMgYW5kIG5vdCBAZG93bmxvYWREaXNhYmxlZCgpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIEBkb3dubG9hZChudWxsLCB0cnVlKVxuXG4gIHJlbmRlcjogLT5cbiAgICAoTW9kYWxEaWFsb2cge3RpdGxlOiAodHIgJ35ESUFMT0cuRE9XTkxPQUQnKSwgY2xvc2U6IEBwcm9wcy5jbG9zZX0sXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdkb3dubG9hZC1kaWFsb2cnfSxcbiAgICAgICAgKGlucHV0IHt0eXBlOiAndGV4dCcsIHJlZjogJ2ZpbGVuYW1lJywgcGxhY2Vob2xkZXI6ICdGaWxlbmFtZScsIHZhbHVlOiBAc3RhdGUuZmlsZW5hbWUsIG9uQ2hhbmdlOiBAdXBkYXRlRmlsZW5hbWUsIG9uS2V5RG93bjogQHdhdGNoRm9yRW50ZXJ9KVxuICAgICAgICBpZiBAc3RhdGUuc2hhcmVkXG4gICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnZG93bmxvYWQtc2hhcmUnfSxcbiAgICAgICAgICAgIChpbnB1dCB7dHlwZTogJ2NoZWNrYm94JywgcmVmOiAnaW5jbHVkZVNoYXJlSW5mbycsIHZhbHVlOiBAc3RhdGUuaW5jbHVkZVNoYXJlSW5mbywgb25DaGFuZ2U6IEB1cGRhdGVJbmNsdWRlU2hhcmVJbmZvfSlcbiAgICAgICAgICAgICh0ciAnfkRPV05MT0FEX0RJQUxPRy5JTkNMVURFX1NIQVJFX0lORk8nKVxuICAgICAgICAgIClcbiAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnYnV0dG9ucyd9LFxuICAgICAgICAgIChhIHtocmVmOiAnIycsIHJlZjogJ2Rvd25sb2FkJywgY2xhc3NOYW1lOiAoaWYgQGRvd25sb2FkRGlzYWJsZWQoKSB0aGVuICdkaXNhYmxlZCcgZWxzZSAnJyksIGRvd25sb2FkOiBAc3RhdGUudHJpbW1lZEZpbGVuYW1lLCBvbkNsaWNrOiBAZG93bmxvYWR9LCB0ciAnfkRPV05MT0FEX0RJQUxPRy5ET1dOTE9BRCcpXG4gICAgICAgICAgKGJ1dHRvbiB7b25DbGljazogQHByb3BzLmNsb3NlfSwgdHIgJ35ET1dOTE9BRF9ESUFMT0cuQ0FOQ0VMJylcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiIsIntzdmcsIGcsIHJlY3QsIHBvbHlnb259ID0gUmVhY3QuRE9NXG5cbkRlZmF1bHRBbmNob3IgPVxuICAjIEhhbWJ1cmdlciBpY29uXG4gIChzdmcge2NsYXNzTmFtZTogJ2RlZmF1bHQtYW5jaG9yJywgdmVyc2lvbjogJzEuMScsIHdpZHRoOiAzMywgaGVpZ2h0OiAxOCwgdmlld0JveDogJzAgMCAzMyAxOCcsIGVuYWJsZUJhY2tncm91bmQ6ICduZXcgMCAwIDMzIDE4J30sXG4gICAgKGcge30sXG4gICAgICAocmVjdCB7eDogMiwgeTogMywgd2lkdGg6IDE2LCBoZWlnaHQ6IDJ9KVxuICAgICAgKHJlY3Qge3g6IDIsIHk6IDgsIHdpZHRoOiAxNiwgaGVpZ2h0OiAyfSlcbiAgICAgIChyZWN0IHt4OiAyLCB5OiAxMywgd2lkdGg6IDE2LCBoZWlnaHQ6IDJ9KVxuICAgICAgKHBvbHlnb24gKHBvaW50czogXCIyMSw3IDI1LDEzIDI5LDdcIikpXG4gICAgKVxuICApXG5cblRyaWFuZ2xlT25seUFuY2hvciA9XG4gIChzdmcge2NsYXNzTmFtZTogJ3RyaWFuZ2xlLW9ubHktYW5jaG9yJywgdmVyc2lvbjogJzEuMScsIHdpZHRoOiA4LCBoZWlnaHQ6IDE4LCB2aWV3Qm94OiAnMCAwIDggMTgnLCBlbmFibGVCYWNrZ3JvdW5kOiAnbmV3IDAgMCAzMyAxOCd9LFxuICAgIChwb2x5Z29uIChwb2ludHM6IFwiMCw3IDQsMTMgOCw3XCIpKVxuICApXG5cbm1vZHVsZS5leHBvcnRzID1cbiAgRGVmYXVsdEFuY2hvcjogRGVmYXVsdEFuY2hvclxuICBUcmlhbmdsZU9ubHlBbmNob3I6IFRyaWFuZ2xlT25seUFuY2hvclxuIiwie2RpdiwgaSwgc3BhbiwgdWwsIGxpfSA9IFJlYWN0LkRPTVxuXG57RGVmYXVsdEFuY2hvcn0gPSByZXF1aXJlIFwiLi9kcm9wZG93bi1hbmNob3JzXCJcbkRyb3Bkb3duSXRlbSA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ0Ryb3Bkb3duSXRlbSdcblxuICBjbGlja2VkOiAtPlxuICAgIGlmIEBwcm9wcy5pdGVtLml0ZW1zXG4gICAgICBAc2hvd1N1Yk1lbnUoKVxuICAgIGVsc2VcbiAgICAgIEBwcm9wcy5zZWxlY3QgQHByb3BzLml0ZW1cblxuICBtb3VzZUVudGVyOiAtPlxuICAgIEBzaG93U3ViTWVudSgpXG5cbiAgc2hvd1N1Yk1lbnU6IC0+XG4gICAgaWYgQHByb3BzLml0ZW0uaXRlbXNcbiAgICAgIG1lbnVJdGVtID0gJCBSZWFjdERPTS5maW5kRE9NTm9kZSBAcmVmcy5pdGVtXG4gICAgICBtZW51ID0gbWVudUl0ZW0ucGFyZW50KCkucGFyZW50KClcblxuICAgICAgQHByb3BzLnNldFN1Yk1lbnVcbiAgICAgICAgc3R5bGU6XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgICAgICBsZWZ0OiBtZW51LndpZHRoKClcbiAgICAgICAgICB0b3A6IG1lbnVJdGVtLnBvc2l0aW9uKCkudG9wIC0gcGFyc2VJbnQobWVudUl0ZW0uY3NzKCdwYWRkaW5nLXRvcCcpKVxuICAgICAgICBpdGVtczogQHByb3BzLml0ZW0uaXRlbXNcbiAgICBlbHNlXG4gICAgICBAcHJvcHMuc2V0U3ViTWVudT8gbnVsbFxuXG4gIHJlbmRlcjogLT5cbiAgICBlbmFibGVkID0gaWYgQHByb3BzLml0ZW0uaGFzT3duUHJvcGVydHkgJ2VuYWJsZWQnXG4gICAgICBpZiB0eXBlb2YgQHByb3BzLml0ZW0uZW5hYmxlZCBpcyAnZnVuY3Rpb24nXG4gICAgICAgIEBwcm9wcy5pdGVtLmVuYWJsZWQoKVxuICAgICAgZWxzZVxuICAgICAgICBAcHJvcHMuaXRlbS5lbmFibGVkXG4gICAgZWxzZVxuICAgICAgdHJ1ZVxuXG4gICAgY2xhc3NlcyA9IFsnbWVudUl0ZW0nXVxuICAgIGlmIEBwcm9wcy5pdGVtLnNlcGFyYXRvclxuICAgICAgY2xhc3Nlcy5wdXNoICdzZXBhcmF0b3InXG4gICAgICAobGkge2NsYXNzTmFtZTogY2xhc3Nlcy5qb2luKCcgJyl9LCAnJylcbiAgICBlbHNlXG4gICAgICBjbGFzc2VzLnB1c2ggJ2Rpc2FibGVkJyBpZiBub3QgZW5hYmxlZCBvciBub3QgKEBwcm9wcy5pdGVtLmFjdGlvbiBvciBAcHJvcHMuaXRlbS5pdGVtcylcbiAgICAgIGNvbnRlbnQgPSBAcHJvcHMuaXRlbS5uYW1lIG9yIEBwcm9wcy5pdGVtLmNvbnRlbnQgb3IgQHByb3BzLml0ZW1cbiAgICAgIChsaSB7cmVmOiAnaXRlbScsIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKCcgJyksIG9uQ2xpY2s6IEBjbGlja2VkLCBvbk1vdXNlRW50ZXI6IEBtb3VzZUVudGVyIH0sXG4gICAgICAgIGlmIEBwcm9wcy5pdGVtLml0ZW1zXG4gICAgICAgICAgKGkge2NsYXNzTmFtZTogJ2ljb24taW5zcGVjdG9yQXJyb3ctY29sbGFwc2UnfSlcbiAgICAgICAgY29udGVudFxuICAgICAgKVxuXG5jZm1NZW51Q2xhc3MgPSAnY2ZtLW1lbnUgZGctd2FudHMtdG91Y2gnXG5cbkRyb3BEb3duID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ0Ryb3Bkb3duJ1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBzaG93aW5nTWVudTogZmFsc2VcbiAgICBzdWJNZW51OiBudWxsXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiAtPlxuICAgIGlmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAnbW91c2Vkb3duJywgQGNoZWNrQ2xvc2UsIHRydWVcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICd0b3VjaHN0YXJ0JywgQGNoZWNrQ2xvc2UsIHRydWVcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBpZiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ21vdXNlZG93bicsIEBjaGVja0Nsb3NlLCB0cnVlXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciAndG91Y2hzdGFydCcsIEBjaGVja0Nsb3NlLCB0cnVlXG5cbiAgY2hlY2tDbG9zZTogKGV2dCkgLT5cbiAgICAjIG5vIG5lZWQgdG8gd2FsayB0aGUgRE9NIGlmIHRoZSBtZW51IGlzbid0IG9wZW5cbiAgICByZXR1cm4gaWYgbm90IEBzdGF0ZS5zaG93aW5nTWVudVxuICAgICMgaWYgdGhlIGNsaWNrIGlzIG9uIHRoZSBtZW51LCBsZXQgdGhlIG1lbnUgaGFuZGxlIGl0XG4gICAgZWx0ID0gZXZ0LnRhcmdldFxuICAgIHdoaWxlIGVsdD9cbiAgICAgIHJldHVybiBpZiB0eXBlb2YgZWx0LmNsYXNzTmFtZSBpcyBcInN0cmluZ1wiIGFuZCBlbHQuY2xhc3NOYW1lLmluZGV4T2YoY2ZtTWVudUNsYXNzKSA+PSAwXG4gICAgICBlbHQgPSBlbHQucGFyZW50Tm9kZVxuICAgICMgb3RoZXJ3aXNlLCBjbG9zZSB0aGUgbWVudVxuICAgIEBzZXRTdGF0ZSB7c2hvd2luZ01lbnU6IGZhbHNlLCBzdWJNZW51OiBmYWxzZX1cblxuICBzZXRTdWJNZW51OiAoc3ViTWVudSkgLT5cbiAgICBAc2V0U3RhdGUgc3ViTWVudTogc3ViTWVudVxuXG4gIHNlbGVjdDogKGl0ZW0pIC0+XG4gICAgcmV0dXJuIGlmIGl0ZW0/Lml0ZW1zXG4gICAgbmV4dFN0YXRlID0gKG5vdCBAc3RhdGUuc2hvd2luZ01lbnUpXG4gICAgQHNldFN0YXRlIHtzaG93aW5nTWVudTogbmV4dFN0YXRlfVxuICAgIHJldHVybiB1bmxlc3MgaXRlbVxuICAgIGl0ZW0uYWN0aW9uPygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIG1lbnVDbGFzcyA9IFwiI3tjZm1NZW51Q2xhc3N9ICN7aWYgQHN0YXRlLnNob3dpbmdNZW51IHRoZW4gJ21lbnUtc2hvd2luZycgZWxzZSAnbWVudS1oaWRkZW4nfVwiXG4gICAgZHJvcGRvd25DbGFzcyA9IFwibWVudSAje2lmIEBwcm9wcy5jbGFzc05hbWUgdGhlbiBAcHJvcHMuY2xhc3NOYW1lIGVsc2UgJyd9XCJcbiAgICBtZW51QW5jaG9yQ2xhc3MgPSBcIm1lbnUtYW5jaG9yICN7aWYgQHByb3BzLm1lbnVBbmNob3JDbGFzc05hbWUgdGhlbiBAcHJvcHMubWVudUFuY2hvckNsYXNzTmFtZSBlbHNlICcnfVwiXG4gICAgKGRpdiB7Y2xhc3NOYW1lOiBkcm9wZG93bkNsYXNzfSxcbiAgICAgIGlmIEBwcm9wcy5pdGVtcz8ubGVuZ3RoID4gMFxuICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogXCIje2NmbU1lbnVDbGFzc30gI3ttZW51QW5jaG9yQ2xhc3N9XCIsIG9uQ2xpY2s6ID0+IEBzZWxlY3QobnVsbCl9LFxuICAgICAgICAgICAgaWYgQHByb3BzLm1lbnVBbmNob3JcbiAgICAgICAgICAgICAgQHByb3BzLm1lbnVBbmNob3JcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgRGVmYXVsdEFuY2hvclxuICAgICAgICAgIClcbiAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6IG1lbnVDbGFzc30sXG4gICAgICAgICAgICAodWwge30sXG4gICAgICAgICAgICAgIChEcm9wZG93bkl0ZW0ge2tleTogaW5kZXgsIGl0ZW06IGl0ZW0sIHNlbGVjdDogQHNlbGVjdCwgc2V0U3ViTWVudTogQHNldFN1Yk1lbnV9KSBmb3IgaXRlbSwgaW5kZXggaW4gQHByb3BzLml0ZW1zXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiBAc3RhdGUuc3ViTWVudVxuICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6IG1lbnVDbGFzcywgc3R5bGU6IEBzdGF0ZS5zdWJNZW51LnN0eWxlfSxcbiAgICAgICAgICAgICAgICAodWwge30sXG4gICAgICAgICAgICAgICAgICAoRHJvcGRvd25JdGVtIHtrZXk6IGluZGV4LCBpdGVtOiBpdGVtLCBzZWxlY3Q6IEBzZWxlY3R9KSBmb3IgaXRlbSwgaW5kZXggaW4gQHN0YXRlLnN1Yk1lbnUuaXRlbXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICApXG4gICAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BEb3duXG4iLCJBdXRob3JpemVNaXhpbiA9IHJlcXVpcmUgJy4vYXV0aG9yaXplLW1peGluJ1xuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuLi9wcm92aWRlcnMvcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuXG50ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxue2RpdiwgaW1nLCBpLCBzcGFuLCBpbnB1dCwgYnV0dG9ufSA9IFJlYWN0LkRPTVxuXG5GaWxlTGlzdEZpbGUgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIGRpc3BsYXlOYW1lOiAnRmlsZUxpc3RGaWxlJ1xuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogLT5cbiAgICBAbGFzdENsaWNrID0gMFxuXG4gIGZpbGVTZWxlY3RlZDogIChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG4gICAgQHByb3BzLmZpbGVTZWxlY3RlZCBAcHJvcHMubWV0YWRhdGFcbiAgICBpZiBub3cgLSBAbGFzdENsaWNrIDw9IDI1MFxuICAgICAgQHByb3BzLmZpbGVDb25maXJtZWQoKVxuICAgIEBsYXN0Q2xpY2sgPSBub3dcblxuICByZW5kZXI6IC0+XG4gICAgc2VsZWN0YWJsZUNsYXNzID0gaWYgQHByb3BzLm1ldGFkYXRhLnR5cGUgaXNudCBDbG91ZE1ldGFkYXRhLkxhYmVsIHRoZW4gJ3NlbGVjdGFibGUnIGVsc2UgJydcbiAgICBzZWxlY3RlZENsYXNzID0gaWYgQHByb3BzLnNlbGVjdGVkIHRoZW4gJ3NlbGVjdGVkJyBlbHNlICcnXG4gICAgc3ViRm9sZGVyQ2xhc3MgPSBpZiBAcHJvcHMuaXNTdWJGb2xkZXIgdGhlbiAnc3ViZm9sZGVyJyBlbHNlICcnXG4gICAgKGRpdiB7Y2xhc3NOYW1lOiBcIiN7c2VsZWN0YWJsZUNsYXNzfSAje3NlbGVjdGVkQ2xhc3N9ICN7c3ViRm9sZGVyQ2xhc3N9XCJcbiAgICAgICAgICAsIHRpdGxlOiBAcHJvcHMubWV0YWRhdGEuZGVzY3JpcHRpb24gb3IgdW5kZWZpbmVkXG4gICAgICAgICAgLCBvbkNsaWNrOiBpZiBAcHJvcHMubWV0YWRhdGEudHlwZSBpc250IENsb3VkTWV0YWRhdGEuTGFiZWwgdGhlbiBAZmlsZVNlbGVjdGVkIGVsc2UgdW5kZWZpbmVkIH0sXG4gICAgICAoUmVhY3QuRE9NLmkge2NsYXNzTmFtZTogaWYgQHByb3BzLm1ldGFkYXRhLnR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5Gb2xkZXIgdGhlbiAnaWNvbi1pbnNwZWN0b3JBcnJvdy1jb2xsYXBzZScgZWxzZSBpZiBAcHJvcHMubWV0YWRhdGEudHlwZSBpcyBDbG91ZE1ldGFkYXRhLkZpbGUgdGhlbiAnaWNvbi1ub3RlVG9vbCd9KVxuICAgICAgQHByb3BzLm1ldGFkYXRhLm5hbWVcbiAgICApXG5cbkZpbGVMaXN0ID0gUmVhY3QuY3JlYXRlRmFjdG9yeSBSZWFjdC5jcmVhdGVDbGFzc1xuICBkaXNwbGF5TmFtZTogJ0ZpbGVMaXN0J1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBsb2FkaW5nOiB0cnVlXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgQF9pc01vdW50ZWQgPSB0cnVlXG4gICAgQGxvYWQgQHByb3BzLmZvbGRlclxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IChuZXh0UHJvcHMpIC0+XG4gICAgaWYgbmV4dFByb3BzLmZvbGRlciBpc250IEBwcm9wcy5mb2xkZXJcbiAgICAgIEBsb2FkIG5leHRQcm9wcy5mb2xkZXJcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBAX2lzTW91bnRlZCA9IGZhbHNlXG5cbiAgbG9hZDogKGZvbGRlcikgLT5cbiAgICBAcHJvcHMucHJvdmlkZXIubGlzdCBmb2xkZXIsIChlcnIsIGxpc3QpID0+XG4gICAgICByZXR1cm4gQHByb3BzLmNsaWVudC5hbGVydChlcnIpIGlmIGVyclxuICAgICAgIyBhc3luY2hyb25vdXMgY2FsbGJhY2sgbWF5IGJlIGNhbGxlZCBhZnRlciBkaWFsb2cgaGFzIGJlZW4gZGlzbWlzc2VkXG4gICAgICBpZiBAX2lzTW91bnRlZFxuICAgICAgICBAc2V0U3RhdGVcbiAgICAgICAgICBsb2FkaW5nOiBmYWxzZVxuICAgICAgQHByb3BzLmxpc3RMb2FkZWQgbGlzdFxuXG4gIHBhcmVudFNlbGVjdGVkOiAoZSkgLT5cbiAgICBAcHJvcHMuZmlsZVNlbGVjdGVkIEBwcm9wcy5mb2xkZXI/LnBhcmVudFxuXG4gIHJlbmRlcjogLT5cbiAgICBsaXN0ID0gW11cbiAgICBpc1N1YkZvbGRlciA9IEBwcm9wcy5mb2xkZXI/XG4gICAgaWYgaXNTdWJGb2xkZXJcbiAgICAgIGxpc3QucHVzaCAoZGl2IHtrZXk6ICdwYXJlbnQnLCBjbGFzc05hbWU6ICdzZWxlY3RhYmxlJywgb25DbGljazogQHBhcmVudFNlbGVjdGVkfSwgKFJlYWN0LkRPTS5pIHtjbGFzc05hbWU6ICdpY29uLXBhbGV0dGVBcnJvdy1jb2xsYXBzZSd9KSwgQHByb3BzLmZvbGRlci5uYW1lKVxuICAgIGZvciBtZXRhZGF0YSwgaSBpbiBAcHJvcHMubGlzdFxuICAgICAgbGlzdC5wdXNoIChGaWxlTGlzdEZpbGUge2tleTogaSwgbWV0YWRhdGE6IG1ldGFkYXRhLCBzZWxlY3RlZDogQHByb3BzLnNlbGVjdGVkRmlsZSBpcyBtZXRhZGF0YSwgZmlsZVNlbGVjdGVkOiBAcHJvcHMuZmlsZVNlbGVjdGVkLCBmaWxlQ29uZmlybWVkOiBAcHJvcHMuZmlsZUNvbmZpcm1lZCwgaXNTdWJGb2xkZXI6IGlzU3ViRm9sZGVyfSlcblxuICAgIChkaXYge2NsYXNzTmFtZTogJ2ZpbGVsaXN0J30sXG4gICAgICBpZiBAc3RhdGUubG9hZGluZ1xuICAgICAgICB0ciBcIn5GSUxFX0RJQUxPRy5MT0FESU5HXCJcbiAgICAgIGVsc2VcbiAgICAgICAgbGlzdFxuICAgIClcblxuRmlsZURpYWxvZ1RhYiA9IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIGRpc3BsYXlOYW1lOiAnRmlsZURpYWxvZ1RhYidcblxuICBtaXhpbnM6IFtBdXRob3JpemVNaXhpbl1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgQF9pc01vdW50ZWQgPSB0cnVlXG4gICAgaW5pdGlhbFN0YXRlID0gQGdldFN0YXRlRm9yRm9sZGVyKEBwcm9wcy5jbGllbnQuc3RhdGUubWV0YWRhdGE/LnBhcmVudCwgdHJ1ZSkgb3IgbnVsbFxuICAgIGluaXRpYWxTdGF0ZS5maWxlbmFtZSA9IGluaXRpYWxTdGF0ZS5tZXRhZGF0YT8ubmFtZSBvciAnJ1xuICAgIGluaXRpYWxTdGF0ZVxuXG4jICBjb21wb25lbnREaWRNb3VudDogLT5cbiMgICAgQF9pc01vdW50ZWQgPSB0cnVlXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IC0+XG4gICAgQF9pc01vdW50ZWQgPSBmYWxzZVxuXG4gIGlzT3BlbjogLT5cbiAgICBAcHJvcHMuZGlhbG9nLmFjdGlvbiBpcyAnb3BlbkZpbGUnXG5cbiAgZmlsZW5hbWVDaGFuZ2VkOiAoZSkgLT5cbiAgICBmaWxlbmFtZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgQHNldFN0YXRlXG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgIG1ldGFkYXRhOiBAZmluZE1ldGFkYXRhIGZpbGVuYW1lLCBAc3RhdGUubGlzdFxuXG4gIGxpc3RMb2FkZWQ6IChsaXN0KSAtPlxuICAgICMgYXN5bmNocm9ub3VzIGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgYWZ0ZXIgZGlhbG9nIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgIGlmIEBfaXNNb3VudGVkXG4gICAgICBAc2V0U3RhdGUgbGlzdDogbGlzdFxuXG4gIGdldFNhdmVNZXRhZGF0YTogLT5cbiAgICAjIFRoZSBzYXZlIG1ldGFkYXRhIGZvciBhIGZpbGUgdGhhdCBtYXkgaGF2ZSBiZWVuIG9wZW5lZCBmcm9tIGFub3RoZXJcbiAgICAjIHByb3ZpZGVyIG11c3QgYmUgY2xvbmVkLCBidXQgd2l0aG91dCBjbG9uaW5nIHRoZSBwcm92aWRlciBmaWVsZC5cbiAgICAjIEZ1cnRoZXJtb3JlLCBpZiB0aGUgcHJvdmlkZXIgaGFzIGNoYW5nZWQsIHRoZSBwcm92aWRlciBhbmQgcHJvdmlkZXJEYXRhXG4gICAgIyBmaWVsZHMgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAgc2F2ZU1ldGFkYXRhID0gaWYgQHByb3BzLmNsaWVudC5zdGF0ZS5tZXRhZGF0YSB0aGVuIF8uY2xvbmUgQHByb3BzLmNsaWVudC5zdGF0ZS5tZXRhZGF0YSBlbHNlIG51bGxcbiAgICBpZiBzYXZlTWV0YWRhdGFcbiAgICAgIGlmIEBwcm9wcy5wcm92aWRlciBpcyBzYXZlTWV0YWRhdGEucHJvdmlkZXJcbiAgICAgICAgc2F2ZU1ldGFkYXRhLnByb3ZpZGVyRGF0YSA9IF8uY2xvbmVEZWVwIHNhdmVNZXRhZGF0YS5wcm92aWRlckRhdGFcbiAgICAgIGVsc2VcbiAgICAgICAgc2F2ZU1ldGFkYXRhLnByb3ZpZGVyID0gbnVsbFxuICAgICAgICBzYXZlTWV0YWRhdGEucHJvdmlkZXJEYXRhID0gbnVsbFxuICAgICAgICBzYXZlTWV0YWRhdGEuZm9yY2VTYXZlRGlhbG9nID0gZmFsc2VcbiAgICBzYXZlTWV0YWRhdGFcblxuICBnZXRTdGF0ZUZvckZvbGRlcjogKGZvbGRlciwgaW5pdGlhbEZvbGRlcikgLT5cbiAgICBtZXRhZGF0YSA9IGlmIEBpc09wZW4oKSB0aGVuIEBzdGF0ZT8ubWV0YWRhdGEgb3IgbnVsbCBlbHNlIEBnZXRTYXZlTWV0YWRhdGEoKVxuXG4gICAgaWYgaW5pdGlhbEZvbGRlciBhbmQgKEBwcm9wcy5jbGllbnQuc3RhdGUubWV0YWRhdGE/LnByb3ZpZGVyIGlzbnQgQHByb3BzLnByb3ZpZGVyKVxuICAgICAgZm9sZGVyID0gbnVsbFxuICAgIGVsc2VcbiAgICAgIG1ldGFkYXRhPy5wYXJlbnQgPSBmb2xkZXJcblxuICAgIGZvbGRlcjogZm9sZGVyXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgbGlzdDogW11cblxuICBmaWxlU2VsZWN0ZWQ6IChtZXRhZGF0YSkgLT5cbiAgICBpZiBtZXRhZGF0YT8udHlwZSBpcyBDbG91ZE1ldGFkYXRhLkZvbGRlclxuICAgICAgQHNldFN0YXRlIEBnZXRTdGF0ZUZvckZvbGRlciBtZXRhZGF0YVxuICAgIGVsc2UgaWYgbWV0YWRhdGE/LnR5cGUgaXMgQ2xvdWRNZXRhZGF0YS5GaWxlXG4gICAgICBAc2V0U3RhdGVcbiAgICAgICAgZmlsZW5hbWU6IG1ldGFkYXRhLm5hbWVcbiAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgZWxzZVxuICAgICAgQHNldFN0YXRlIEBnZXRTdGF0ZUZvckZvbGRlciBudWxsXG5cbiAgY29uZmlybTogLT5cbiAgICBjb25maXJtZWQgPSAobWV0YWRhdGEpID0+XG4gICAgICAjIGVuc3VyZSB0aGUgbWV0YWRhdGEgcHJvdmlkZXIgaXMgdGhlIGN1cnJlbnRseS1zaG93aW5nIHRhYlxuICAgICAgQHN0YXRlLm1ldGFkYXRhID0gbWV0YWRhdGFcbiAgICAgIGlmIEBzdGF0ZS5tZXRhZGF0YS5wcm92aWRlciBpc250IEBwcm9wcy5wcm92aWRlclxuICAgICAgICBAc3RhdGUubWV0YWRhdGEucHJvdmlkZXIgPSBAcHJvcHMucHJvdmlkZXJcbiAgICAgICAgIyBpZiBzd2l0Y2hpbmcgcHJvdmlkZXIsIHRoZW4gY2xlYXIgcHJvdmlkZXJEYXRhXG4gICAgICAgIEBzdGF0ZS5tZXRhZGF0YS5wcm92aWRlckRhdGEgPSB7fVxuICAgICAgQHByb3BzLmRpYWxvZy5jYWxsYmFjaz8gQHN0YXRlLm1ldGFkYXRhXG4gICAgICBAcHJvcHMuY2xvc2UoKVxuXG4gICAgZmlsZW5hbWUgPSAkLnRyaW0gQHN0YXRlLmZpbGVuYW1lXG4gICAgZXhpc3RpbmdNZXRhZGF0YSA9IEBmaW5kTWV0YWRhdGEgZmlsZW5hbWUsIEBzdGF0ZS5saXN0XG4gICAgbWV0YWRhdGEgPSBAc3RhdGUubWV0YWRhdGEgb3IgZXhpc3RpbmdNZXRhZGF0YVxuXG4gICAgaWYgbWV0YWRhdGFcbiAgICAgIGlmIEBpc09wZW4oKVxuICAgICAgICBjb25maXJtZWQgbWV0YWRhdGFcbiAgICAgIGVsc2UgaWYgZXhpc3RpbmdNZXRhZGF0YVxuICAgICAgICBAcHJvcHMuY2xpZW50LmNvbmZpcm0gXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gb3ZlcndyaXRlICN7ZXhpc3RpbmdNZXRhZGF0YS5uYW1lfT9cIiwgLT4gY29uZmlybWVkIGV4aXN0aW5nTWV0YWRhdGFcbiAgICAgIGVsc2VcbiAgICAgICAgY29uZmlybWVkIG1ldGFkYXRhXG4gICAgZWxzZSBpZiBAaXNPcGVuKClcbiAgICAgIEBwcm9wcy5jbGllbnQuYWxlcnQgXCIje2ZpbGVuYW1lfSBub3QgZm91bmRcIlxuICAgIGVsc2VcbiAgICAgIGNvbmZpcm1lZCBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICBuYW1lOiBmaWxlbmFtZVxuICAgICAgICB0eXBlOiBDbG91ZE1ldGFkYXRhLkZpbGVcbiAgICAgICAgcGFyZW50OiBAc3RhdGUuZm9sZGVyIG9yIG51bGxcbiAgICAgICAgcHJvdmlkZXI6IEBwcm9wcy5wcm92aWRlclxuXG4gIHJlbW92ZTogLT5cbiAgICBpZiBAc3RhdGUubWV0YWRhdGEgYW5kIEBzdGF0ZS5tZXRhZGF0YS50eXBlIGlzbnQgQ2xvdWRNZXRhZGF0YS5Gb2xkZXJcbiAgICAgIEBwcm9wcy5jbGllbnQuY29uZmlybSB0cihcIn5GSUxFX0RJQUxPRy5SRU1PVkVfQ09ORklSTVwiLCB7ZmlsZW5hbWU6IEBzdGF0ZS5tZXRhZGF0YS5uYW1lfSksID0+XG4gICAgICAgIEBwcm9wcy5wcm92aWRlci5yZW1vdmUgQHN0YXRlLm1ldGFkYXRhLCAoZXJyKSA9PlxuICAgICAgICAgIGlmIG5vdCBlcnJcbiAgICAgICAgICAgIEBwcm9wcy5jbGllbnQuYWxlcnQgdHIoXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9NRVNTQUdFXCIsIHtmaWxlbmFtZTogQHN0YXRlLm1ldGFkYXRhLm5hbWV9KSwgdHIoXCJ+RklMRV9ESUFMT0cuUkVNT1ZFRF9USVRMRVwiKVxuICAgICAgICAgICAgbGlzdCA9IEBzdGF0ZS5saXN0LnNsaWNlIDBcbiAgICAgICAgICAgIGluZGV4ID0gbGlzdC5pbmRleE9mIEBzdGF0ZS5tZXRhZGF0YVxuICAgICAgICAgICAgbGlzdC5zcGxpY2UgaW5kZXgsIDFcbiAgICAgICAgICAgIEBzZXRTdGF0ZVxuICAgICAgICAgICAgICBsaXN0OiBsaXN0XG4gICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiAnJ1xuXG4gIGNhbmNlbDogLT5cbiAgICBAcHJvcHMuY2xvc2UoKVxuXG4gIGZpbmRNZXRhZGF0YTogKGZpbGVuYW1lLCBsaXN0KSAtPlxuICAgIGZvciBtZXRhZGF0YSBpbiBsaXN0XG4gICAgICBpZiBtZXRhZGF0YS5uYW1lIGlzIGZpbGVuYW1lXG4gICAgICAgIHJldHVybiBtZXRhZGF0YVxuICAgIG51bGxcblxuICB3YXRjaEZvckVudGVyOiAoZSkgLT5cbiAgICBpZiBlLmtleUNvZGUgaXMgMTMgYW5kIG5vdCBAY29uZmlybURpc2FibGVkKClcbiAgICAgIEBjb25maXJtKClcblxuICBjb25maXJtRGlzYWJsZWQ6IC0+XG4gICAgKEBzdGF0ZS5maWxlbmFtZS5sZW5ndGggaXMgMCkgb3IgKEBpc09wZW4oKSBhbmQgbm90IEBzdGF0ZS5tZXRhZGF0YSlcblxuICByZW5kZXJXaGVuQXV0aG9yaXplZDogLT5cbiAgICBjb25maXJtRGlzYWJsZWQgPSBAY29uZmlybURpc2FibGVkKClcbiAgICByZW1vdmVEaXNhYmxlZCA9IChAc3RhdGUubWV0YWRhdGEgaXMgbnVsbCkgb3IgKEBzdGF0ZS5tZXRhZGF0YS50eXBlIGlzIENsb3VkTWV0YWRhdGEuRm9sZGVyKVxuXG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnZGlhbG9nVGFiJ30sXG4gICAgICAoaW5wdXQge3R5cGU6ICd0ZXh0JywgdmFsdWU6IEBzdGF0ZS5maWxlbmFtZSwgcGxhY2Vob2xkZXI6ICh0ciBcIn5GSUxFX0RJQUxPRy5GSUxFTkFNRVwiKSwgb25DaGFuZ2U6IEBmaWxlbmFtZUNoYW5nZWQsIG9uS2V5RG93bjogQHdhdGNoRm9yRW50ZXJ9KVxuICAgICAgKEZpbGVMaXN0IHtwcm92aWRlcjogQHByb3BzLnByb3ZpZGVyLCBmb2xkZXI6IEBzdGF0ZS5mb2xkZXIsIHNlbGVjdGVkRmlsZTogQHN0YXRlLm1ldGFkYXRhLCBmaWxlU2VsZWN0ZWQ6IEBmaWxlU2VsZWN0ZWQsIGZpbGVDb25maXJtZWQ6IEBjb25maXJtLCBsaXN0OiBAc3RhdGUubGlzdCwgbGlzdExvYWRlZDogQGxpc3RMb2FkZWQsIGNsaWVudDogQHByb3BzLmNsaWVudH0pXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdidXR0b25zJ30sXG4gICAgICAgIChidXR0b24ge29uQ2xpY2s6IEBjb25maXJtLCBkaXNhYmxlZDogY29uZmlybURpc2FibGVkLCBjbGFzc05hbWU6IGlmIGNvbmZpcm1EaXNhYmxlZCB0aGVuICdkaXNhYmxlZCcgZWxzZSAnJ30sIGlmIEBpc09wZW4oKSB0aGVuICh0ciBcIn5GSUxFX0RJQUxPRy5PUEVOXCIpIGVsc2UgKHRyIFwifkZJTEVfRElBTE9HLlNBVkVcIikpXG4gICAgICAgIGlmIEBwcm9wcy5wcm92aWRlci5jYW4gJ3JlbW92ZSdcbiAgICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAcmVtb3ZlLCBkaXNhYmxlZDogcmVtb3ZlRGlzYWJsZWQsIGNsYXNzTmFtZTogaWYgcmVtb3ZlRGlzYWJsZWQgdGhlbiAnZGlzYWJsZWQnIGVsc2UgJyd9LCAodHIgXCJ+RklMRV9ESUFMT0cuUkVNT1ZFXCIpKVxuICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAY2FuY2VsfSwgKHRyIFwifkZJTEVfRElBTE9HLkNBTkNFTFwiKSlcbiAgICAgIClcbiAgICApXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsZURpYWxvZ1RhYlxuIiwiTW9kYWxUYWJiZWREaWFsb2cgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vbW9kYWwtdGFiYmVkLWRpYWxvZy12aWV3J1xuVGFiYmVkUGFuZWwgPSByZXF1aXJlICcuL3RhYmJlZC1wYW5lbC12aWV3J1xuTG9jYWxGaWxlVGFiID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL2xvY2FsLWZpbGUtdGFiLWxpc3QtdmlldydcblVybFRhYiA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi91cmwtdGFiLXZpZXcnXG5cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuXG5Mb2NhbEZpbGVJbXBvcnRUYWIgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcbiAgZGlzcGxheU5hbWU6ICdJbXBvcnRUYWJiZWREaWFsb2cnXG5cbiAgaW1wb3J0RmlsZTogKG1ldGFkYXRhLCB2aWEpIC0+XG4gICAgc3dpdGNoIG1ldGFkYXRhLnByb3ZpZGVyXG4gICAgICB3aGVuICdsb2NhbEZpbGUnXG4gICAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChsb2FkZWQpID0+XG4gICAgICAgICAgZGF0YSA9XG4gICAgICAgICAgICBmaWxlOlxuICAgICAgICAgICAgICBuYW1lOiBtZXRhZGF0YS5wcm92aWRlckRhdGEuZmlsZS5uYW1lLFxuICAgICAgICAgICAgICBjb250ZW50OiBsb2FkZWQudGFyZ2V0LnJlc3VsdFxuICAgICAgICAgICAgICBvYmplY3Q6IG1ldGFkYXRhLnByb3ZpZGVyRGF0YS5maWxlXG4gICAgICAgICAgICB2aWE6IHZpYVxuICAgICAgICAgIEBwcm9wcy5kaWFsb2cuY2FsbGJhY2s/IGRhdGFcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQgbWV0YWRhdGEucHJvdmlkZXJEYXRhLmZpbGVcblxuICBpbXBvcnRVcmw6ICh1cmwsIHZpYSkgLT5cbiAgICBAcHJvcHMuZGlhbG9nLmNhbGxiYWNrPyB7dXJsOiB1cmwsIHZpYTogdmlhfVxuXG4gIHJlbmRlcjogIC0+XG4gICAgdGFicyA9IFtcbiAgICAgIFRhYmJlZFBhbmVsLlRhYlxuICAgICAgICBrZXk6IDBcbiAgICAgICAgbGFiZWw6ICh0ciBcIn5JTVBPUlQuTE9DQUxfRklMRVwiKVxuICAgICAgICBjb21wb25lbnQ6IExvY2FsRmlsZVRhYlxuICAgICAgICAgIGNsaWVudDogQHByb3BzLmNsaWVudFxuICAgICAgICAgIGRpYWxvZzpcbiAgICAgICAgICAgIGNhbGxiYWNrOiBAaW1wb3J0RmlsZVxuICAgICAgICAgIHByb3ZpZGVyOiAnbG9jYWxGaWxlJyAjIHdlIGFyZSBmYWtpbmcgdGhlIHByb3ZpZGVyIGhlcmUgc28gd2UgY2FuIHJldXNlIHRoZSBsb2NhbCBmaWxlIHRhYlxuICAgICAgICAgIGNsb3NlOiBAcHJvcHMuY2xvc2VcbiAgICAgIFRhYmJlZFBhbmVsLlRhYlxuICAgICAgICBrZXk6IDFcbiAgICAgICAgbGFiZWw6ICh0ciBcIn5JTVBPUlQuVVJMXCIpXG4gICAgICAgIGNvbXBvbmVudDogVXJsVGFiXG4gICAgICAgICAgY2xpZW50OiBAcHJvcHMuY2xpZW50XG4gICAgICAgICAgZGlhbG9nOlxuICAgICAgICAgICAgY2FsbGJhY2s6IEBpbXBvcnRVcmxcbiAgICAgICAgICBjbG9zZTogQHByb3BzLmNsb3NlXG4gICAgXVxuICAgIChNb2RhbFRhYmJlZERpYWxvZyB7dGl0bGU6ICh0ciBcIn5ESUFMT0cuSU1QT1JUX0RBVEFcIiksIGNsb3NlOiBAcHJvcHMuY2xvc2UsIHRhYnM6IHRhYnMsIHNlbGVjdGVkVGFiSW5kZXg6IDB9KVxuIiwie2RpdiwgaW5wdXQsIGJ1dHRvbn0gPSBSZWFjdC5ET01cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuLi9wcm92aWRlcnMvcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZGlzcGxheU5hbWU6ICdMb2NhbEZpbGVMaXN0VGFiJ1xuXG4gICMgU3RhbmRhcmQgUmVhY3QgJ2Ryb3AnIGV2ZW50IGhhbmRsZXJzIGFyZSB0cmlnZ2VyZWQgYWZ0ZXIgY2xpZW50ICdkcm9wJyBldmVudCBoYW5kbGVycy5cbiAgIyBCeSBleHBsaWNpdGx5IGluc3RhbGxpbmcgRE9NIGV2ZW50IGhhbmRsZXJzIHdlIGdldCBmaXJzdCBjcmFjayBhdCB0aGUgJ2Ryb3AnIGV2ZW50LlxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBAcmVmcy5kcm9wWm9uZS5hZGRFdmVudExpc3RlbmVyICdkcm9wJywgQGRyb3BcbiAgICByZXR1cm5cblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBAcmVmcy5kcm9wWm9uZS5yZW1vdmVFdmVudExpc3RlbmVyICdkcm9wJywgQGRyb3BcbiAgICByZXR1cm5cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgaG92ZXI6IGZhbHNlXG5cbiAgY2hhbmdlZDogKGUpIC0+XG4gICAgZmlsZXMgPSBlLnRhcmdldC5maWxlc1xuICAgIGlmIGZpbGVzLmxlbmd0aCA+IDFcbiAgICAgIEBwcm9wcy5jbGllbnQuYWxlcnQgdHIgXCJ+TE9DQUxfRklMRV9ESUFMT0cuTVVMVElQTEVfRklMRVNfU0VMRUNURURcIlxuICAgIGVsc2UgaWYgZmlsZXMubGVuZ3RoIGlzIDFcbiAgICAgIEBvcGVuRmlsZSBmaWxlc1swXSwgJ3NlbGVjdCdcblxuICBvcGVuRmlsZTogKGZpbGUsIHZpYSkgLT5cbiAgICBtZXRhZGF0YSA9IG5ldyBDbG91ZE1ldGFkYXRhXG4gICAgICBuYW1lOiBmaWxlLm5hbWUuc3BsaXQoJy4nKVswXVxuICAgICAgdHlwZTogQ2xvdWRNZXRhZGF0YS5GaWxlXG4gICAgICBwYXJlbnQ6IG51bGxcbiAgICAgIHByb3ZpZGVyOiBAcHJvcHMucHJvdmlkZXJcbiAgICAgIHByb3ZpZGVyRGF0YTpcbiAgICAgICAgZmlsZTogZmlsZVxuICAgIEBwcm9wcy5kaWFsb2cuY2FsbGJhY2s/IG1ldGFkYXRhLCB2aWFcbiAgICBAcHJvcHMuY2xvc2UoKVxuXG4gIGNhbmNlbDogLT5cbiAgICBAcHJvcHMuY2xvc2UoKVxuXG4gIGRyYWdFbnRlcjogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgQHNldFN0YXRlIGhvdmVyOiB0cnVlXG5cbiAgZHJhZ0xlYXZlOiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBAc2V0U3RhdGUgaG92ZXI6IGZhbHNlXG5cbiAgZHJvcDogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGRyb3BwZWRGaWxlcyA9IGlmIGUuZGF0YVRyYW5zZmVyIHRoZW4gZS5kYXRhVHJhbnNmZXIuZmlsZXMgZWxzZSBlLnRhcmdldC5maWxlc1xuICAgIGlmIGRyb3BwZWRGaWxlcy5sZW5ndGggPiAxXG4gICAgICBAcHJvcHMuY2xpZW50LmFsZXJ0IHRyIFwifkxPQ0FMX0ZJTEVfRElBTE9HLk1VTFRJUExFX0ZJTEVTX0RST1BQRURcIlxuICAgIGVsc2UgaWYgZHJvcHBlZEZpbGVzLmxlbmd0aCBpcyAxXG4gICAgICBAb3BlbkZpbGUgZHJvcHBlZEZpbGVzWzBdLCAnZHJvcCdcbiAgICByZXR1cm5cblxuICByZW5kZXI6IC0+XG4gICAgZHJvcENsYXNzID0gXCJkcm9wQXJlYSN7aWYgQHN0YXRlLmhvdmVyIHRoZW4gJyBkcm9wSG92ZXInIGVsc2UgJyd9XCJcbiAgICAoZGl2IHtjbGFzc05hbWU6ICdkaWFsb2dUYWIgbG9jYWxGaWxlTG9hZCd9LFxuICAgICAgIyAnZHJvcCcgZXZlbnQgaGFuZGxlciBpbnN0YWxsZWQgYXMgRE9NIGV2ZW50IGhhbmRsZXIgaW4gY29tcG9uZW50RGlkTW91bnQoKVxuICAgICAgKGRpdiB7cmVmOiAnZHJvcFpvbmUnLCBjbGFzc05hbWU6IGRyb3BDbGFzcywgb25EcmFnRW50ZXI6IEBkcmFnRW50ZXIsIG9uRHJhZ0xlYXZlOiBAZHJhZ0xlYXZlfSxcbiAgICAgICAgKHRyIFwifkxPQ0FMX0ZJTEVfRElBTE9HLkRST1BfRklMRV9IRVJFXCIpXG4gICAgICAgIChpbnB1dCB7dHlwZTogJ2ZpbGUnLCBvbkNoYW5nZTogQGNoYW5nZWR9KVxuICAgICAgKVxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnYnV0dG9ucyd9LFxuICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAY2FuY2VsfSwgKHRyIFwifkZJTEVfRElBTE9HLkNBTkNFTFwiKSlcbiAgICAgIClcbiAgICApXG4iLCJ7ZGl2LCBpbnB1dCwgYnV0dG9uLCBhfSA9IFJlYWN0LkRPTVxudHIgPSByZXF1aXJlICcuLi91dGlscy90cmFuc2xhdGUnXG5DbG91ZE1ldGFkYXRhID0gKHJlcXVpcmUgJy4uL3Byb3ZpZGVycy9wcm92aWRlci1pbnRlcmZhY2UnKS5DbG91ZE1ldGFkYXRhXG5jbG91ZENvbnRlbnRGYWN0b3J5ID0gKHJlcXVpcmUgJy4uL3Byb3ZpZGVycy9wcm92aWRlci1pbnRlcmZhY2UnKS5jbG91ZENvbnRlbnRGYWN0b3J5XG5GaWxlU2F2ZXIgPSByZXF1aXJlKCcuLi9saWIvZmlsZS1zYXZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ0xvY2FsRmlsZVNhdmVUYWInXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgICMgSWYgdGhlIGRpYWxvZyBoYXMgdGhlIGNvbnRlbnQgdG8gc2F2ZSwgd2hpY2ggb2NjdXJzIHdoZW4gc2F2aW5nIHNlY29uZGFyeSBjb250ZW50XG4gICAgIyBsaWtlIENTViBmaWxlcywgdGhlbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkb2N1bWVudCBjb250ZW50IGFuZCBtYWtlIHN1cmUgdGhhdFxuICAgICMgaXQgZG9lc24ndCBnZXQgbW9kaWZpZWQgYnkgKGZvciBpbnN0YW5jZSkgdHJ5aW5nIHRvIHJlbW92ZSBzaGFyaW5nIG1ldGFkYXRhLiBUb1xuICAgICMgZG8gc28sIHdlIHNwZWNpZnkgdGhhdCB3ZSB3YW50IHRvIGluY2x1ZGUgdGhlIHNoYXJlIGluZm8sIHdoaWNoIHRlbGxzIHRoZSBjbGllbnRcbiAgICAjIHRvIGxlYXZlIHRoZSBjb250ZW50IGFsb25lLlxuICAgIGhhc1Byb3BzQ29udGVudCA9IEBwcm9wcy5kaWFsb2cuZGF0YT8uY29udGVudD9cbiAgICBmaWxlbmFtZSA9IEBwcm9wcy5jbGllbnQuc3RhdGUubWV0YWRhdGE/Lm5hbWUgb3IgKHRyIFwifk1FTlVCQVIuVU5USVRMRURfRE9DVU1FTlRcIilcbiAgICBleHRlbnNpb24gPSBpZiBoYXNQcm9wc0NvbnRlbnQgYW5kIEBwcm9wcy5kaWFsb2cuZGF0YS5leHRlbnNpb24gXFxcbiAgICAgICAgICAgICAgICAgIHRoZW4gQHByb3BzLmRpYWxvZy5kYXRhLmV4dGVuc2lvbiBlbHNlICdqc29uJ1xuICAgIHN0YXRlID1cbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgc3VwcG9ydHNEb3dubG9hZEF0dHJpYnV0ZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpLmRvd25sb2FkIGlzbnQgdW5kZWZpbmVkXG4gICAgICBkb3dubG9hZEZpbGVuYW1lOiBAZ2V0RG93bmxvYWRGaWxlbmFtZSBoYXNQcm9wc0NvbnRlbnQsIGZpbGVuYW1lLCBleHRlbnNpb25cbiAgICAgIGV4dGVuc2lvbjogZXh0ZW5zaW9uXG4gICAgICBtaW1lVHlwZTogaWYgaGFzUHJvcHNDb250ZW50IGFuZCBAcHJvcHMuZGlhbG9nLmRhdGEubWltZVR5cGU/IFxcXG4gICAgICAgICAgICAgICAgICB0aGVuIEBwcm9wcy5kaWFsb2cuZGF0YS5taW1lVHlwZSBlbHNlICd0ZXh0L3BsYWluJyxcbiAgICAgIHNoYXJlZDogQHByb3BzLmNsaWVudC5pc1NoYXJlZCgpXG4gICAgICBoYXNQcm9wc0NvbnRlbnQ6IGhhc1Byb3BzQ29udGVudFxuICAgICAgaW5jbHVkZVNoYXJlSW5mbzogaGFzUHJvcHNDb250ZW50XG4gICAgICBnb3RDb250ZW50OiBoYXNQcm9wc0NvbnRlbnRcbiAgICAgIGNvbnRlbnQ6IEBwcm9wcy5kaWFsb2cuZGF0YT8uY29udGVudFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIGlmIG5vdCBAc3RhdGUuaGFzUHJvcHNDb250ZW50XG4gICAgICBAcHJvcHMuY2xpZW50Ll9ldmVudCAnZ2V0Q29udGVudCcsIHsgc2hhcmVkOiBAcHJvcHMuY2xpZW50Ll9zaGFyZWRNZXRhZGF0YSgpIH0sIChjb250ZW50KSA9PlxuICAgICAgICBlbnZlbG9wZWRDb250ZW50ID0gY2xvdWRDb250ZW50RmFjdG9yeS5jcmVhdGVFbnZlbG9wZWRDbG91ZENvbnRlbnQgY29udGVudFxuICAgICAgICBAcHJvcHMuY2xpZW50LnN0YXRlPy5jdXJyZW50Q29udGVudD8uY29weU1ldGFkYXRhVG8gZW52ZWxvcGVkQ29udGVudFxuICAgICAgICBAc2V0U3RhdGVcbiAgICAgICAgICBnb3RDb250ZW50OiB0cnVlXG4gICAgICAgICAgY29udGVudDogZW52ZWxvcGVkQ29udGVudFxuXG4gICAgIyBVc2luZyB0aGUgUmVhY3Qgb25DbGljayBoYW5kbGVyIGZvciB0aGUgZG93bmxvYWQgYnV0dG9uIHlpZWxkZWQgb2RkIGJlaGF2aW9yc1xuICAgICMgaW4gd2hpY2ggdGhlIG9uQ2xpY2sgaGFuZGxlciBnb3QgdHJpZ2dlcmVkIG11bHRpcGxlIHRpbWVzIGFuZCB0aGUgZGVmYXVsdFxuICAgICMgaGFuZGxlciBjb3VsZCBub3QgYmUgcHJldmVudGVkLCBwcmVzdW1hYmx5IGR1ZSB0byBSZWFjdCdzIFN5bnRoZXRpY0V2ZW50IHN5c3RlbS5cbiAgICAjIFRoZSBzb2x1dGlvbiBoZXJlIGlzIHRvIHVzZSBzdGFuZGFyZCBicm93c2VyIGV2ZW50IGhhbmRsZXJzLlxuICAgIEByZWZzLmRvd25sb2FkLmFkZEV2ZW50TGlzdGVuZXIgJ2NsaWNrJywgQGNvbmZpcm1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBAcmVmcy5kb3dubG9hZC5yZW1vdmVFdmVudExpc3RlbmVyICdjbGljaycsIEBjb25maXJtXG5cbiAgZmlsZW5hbWVDaGFuZ2VkOiAtPlxuICAgIGZpbGVuYW1lID0gQHJlZnMuZmlsZW5hbWUudmFsdWVcbiAgICBAc2V0U3RhdGVcbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgZG93bmxvYWRGaWxlbmFtZTogQGdldERvd25sb2FkRmlsZW5hbWUgQHN0YXRlLmhhc1Byb3BzQ29udGVudCwgZmlsZW5hbWUsIEBzdGF0ZS5leHRlbnNpb25cblxuICBpbmNsdWRlU2hhcmVJbmZvQ2hhbmdlZDogLT5cbiAgICBAc2V0U3RhdGUgaW5jbHVkZVNoYXJlSW5mbzogQHJlZnMuaW5jbHVkZVNoYXJlSW5mby5jaGVja2VkXG5cbiAgZ2V0RG93bmxvYWRGaWxlbmFtZTogKGhhc1Byb3BzQ29udGVudCwgZmlsZW5hbWUsIGV4dGVuc2lvbikgLT5cbiAgICBuZXdOYW1lID0gZmlsZW5hbWUucmVwbGFjZSAvXlxccyt8XFxzKyQvLCAnJ1xuICAgIGlmIGhhc1Byb3BzQ29udGVudCBcXFxuICAgICAgdGhlbiBDbG91ZE1ldGFkYXRhLm5ld0V4dGVuc2lvbihuZXdOYW1lLCBleHRlbnNpb24pIFxcXG4gICAgICBlbHNlIENsb3VkTWV0YWRhdGEud2l0aEV4dGVuc2lvbihuZXdOYW1lLCBleHRlbnNpb24pXG5cbiAgY29uZmlybTogKGUsIHNpbXVsYXRlQ2xpY2spIC0+XG4gICAgaWYgbm90IEBjb25maXJtRGlzYWJsZWQoKVxuICAgICAgaWYgQHN0YXRlLnN1cHBvcnRzRG93bmxvYWRBdHRyaWJ1dGVcbiAgICAgICAgQHJlZnMuZG93bmxvYWQuaHJlZiA9IEBwcm9wcy5jbGllbnQuZ2V0RG93bmxvYWRVcmwoQHN0YXRlLmNvbnRlbnQsIEBzdGF0ZS5pbmNsdWRlU2hhcmVJbmZvLCBAc3RhdGUubWltZVR5cGUpXG4gICAgICAgIEByZWZzLmRvd25sb2FkLmNsaWNrKCkgaWYgc2ltdWxhdGVDbGlja1xuICAgICAgZWxzZVxuICAgICAgICBibG9iID0gQHByb3BzLmNsaWVudC5nZXREb3dubG9hZEJsb2IoQHN0YXRlLmNvbnRlbnQsIEBzdGF0ZS5pbmNsdWRlU2hhcmVJbmZvLCBAc3RhdGUubWltZVR5cGUpXG4gICAgICAgIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgQHN0YXRlLmRvd25sb2FkRmlsZW5hbWUsIHRydWUpXG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgbWV0YWRhdGEgPSBuZXcgQ2xvdWRNZXRhZGF0YVxuICAgICAgICBuYW1lOiBAc3RhdGUuZG93bmxvYWRGaWxlbmFtZS5zcGxpdCgnLicpWzBdXG4gICAgICAgIHR5cGU6IENsb3VkTWV0YWRhdGEuRmlsZVxuICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgcHJvdmlkZXI6IEBwcm9wcy5wcm92aWRlclxuICAgICAgQHByb3BzLmRpYWxvZy5jYWxsYmFjayBtZXRhZGF0YVxuICAgICAgQHByb3BzLmNsb3NlKClcblxuICAgICAgIyByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHdoZXRoZXIgdG8gdHJpZ2dlciBocmVmXG4gICAgICByZXR1cm4gQHN0YXRlLnN1cHBvcnRzRG93bmxvYWRBdHRyaWJ1dGVcbiAgICBlbHNlXG4gICAgICBlPy5wcmV2ZW50RGVmYXVsdCgpXG4gICAgcmV0dXJuXG5cbiAgY29udGV4dE1lbnU6IChlKSAtPlxuICAgIEByZWZzLmRvd25sb2FkLmhyZWYgPSBAcHJvcHMuY2xpZW50LmdldERvd25sb2FkVXJsKEBzdGF0ZS5jb250ZW50LCBAc3RhdGUuaW5jbHVkZVNoYXJlSW5mbywgQHN0YXRlLm1pbWVUeXBlKVxuICAgIHJldHVyblxuXG4gIGNhbmNlbDogLT5cbiAgICBAcHJvcHMuY2xvc2UoKVxuICAgIHJldHVyblxuXG4gIHdhdGNoRm9yRW50ZXI6IChlKSAtPlxuICAgIGlmIGUua2V5Q29kZSBpcyAxMyBhbmQgbm90IEBjb25maXJtRGlzYWJsZWQoKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBAY29uZmlybShudWxsLCB0cnVlKVxuICAgIHJldHVyblxuXG4gIGNvbmZpcm1EaXNhYmxlZDogLT5cbiAgICAoQHN0YXRlLmRvd25sb2FkRmlsZW5hbWUubGVuZ3RoIGlzIDApIG9yIG5vdCBAc3RhdGUuZ290Q29udGVudFxuXG4gIHJlbmRlcjogLT5cbiAgICBjb25maXJtRGlzYWJsZWQgPSBAY29uZmlybURpc2FibGVkKClcblxuICAgICMgZm9yIG1vZGVybiBicm93c2Vyc1xuICAgIGRvd25sb2FkQW5jaG9yID0gKGEge1xuICAgICAgaHJlZjogJyMnXG4gICAgICByZWY6ICdkb3dubG9hZCdcbiAgICAgIGNsYXNzTmFtZTogKGlmIGNvbmZpcm1EaXNhYmxlZCB0aGVuICdkaXNhYmxlZCcgZWxzZSAnJylcbiAgICAgIGRvd25sb2FkOiBAc3RhdGUuZG93bmxvYWRGaWxlbmFtZVxuICAgICAgb25Db250ZXh0TWVudTogQGNvbnRleHRNZW51XG4gICAgfSwgdHIgJ35GSUxFX0RJQUxPRy5ET1dOTE9BRCcpXG5cbiAgICAjIGZvciBTYWZhcmkgKG9yIG90aGVyIG5vbi1tb2Rlcm4gYnJvd3NlcnMpXG4gICAgZG93bmxvYWRCdXR0b24gPSAoYnV0dG9uIHtcbiAgICAgIHJlZjogJ2Rvd25sb2FkJ1xuICAgICAgY2xhc3NOYW1lOiAoaWYgY29uZmlybURpc2FibGVkIHRoZW4gJ2Rpc2FibGVkJyBlbHNlICcnKVxuICAgIH0sIHRyICd+RklMRV9ESUFMT0cuRE9XTkxPQUQnKVxuXG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnZGlhbG9nVGFiIGxvY2FsRmlsZVNhdmUnfSxcbiAgICAgIChpbnB1dCB7dHlwZTogJ3RleHQnLCByZWY6ICdmaWxlbmFtZScsIHZhbHVlOiBAc3RhdGUuZmlsZW5hbWUsIHBsYWNlaG9sZGVyOiAodHIgXCJ+RklMRV9ESUFMT0cuRklMRU5BTUVcIiksIG9uQ2hhbmdlOiBAZmlsZW5hbWVDaGFuZ2VkLCBvbktleURvd246IEB3YXRjaEZvckVudGVyfSksXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdzYXZlQXJlYSd9LFxuICAgICAgICBpZiBAc3RhdGUuc2hhcmVkIGFuZCBub3QgQHN0YXRlLmhhc1Byb3BzQ29udGVudFxuICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogJ3NoYXJlQ2hlY2tib3gnfSxcbiAgICAgICAgICAgIChpbnB1dCB7dHlwZTogJ2NoZWNrYm94JywgcmVmOiAnaW5jbHVkZVNoYXJlSW5mbycsIHZhbHVlOiBAc3RhdGUuaW5jbHVkZVNoYXJlSW5mbywgb25DaGFuZ2U6IEBpbmNsdWRlU2hhcmVJbmZvQ2hhbmdlZH0pXG4gICAgICAgICAgICAodHIgJ35ET1dOTE9BRF9ESUFMT0cuSU5DTFVERV9TSEFSRV9JTkZPJylcbiAgICAgICAgICApXG4gICAgICApXG4gICAgICBkaXYoe2NsYXNzTmFtZTogJ25vdGUnfSwgdHIoJ35GSUxFX0RJQUxPRy5ET1dOTE9BRF9OT1RFJywge2Rvd25sb2FkOiB0cignfkZJTEVfRElBTE9HLkRPV05MT0FEJyl9KSlcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2J1dHRvbnMnfSxcbiAgICAgICAgaWYgQHN0YXRlLnN1cHBvcnRzRG93bmxvYWRBdHRyaWJ1dGUgdGhlbiBkb3dubG9hZEFuY2hvciBlbHNlIGRvd25sb2FkQnV0dG9uXG4gICAgICAgIChidXR0b24ge29uQ2xpY2s6IEBjYW5jZWx9LCAodHIgXCJ+RklMRV9ESUFMT0cuQ0FOQ0VMXCIpKVxuICAgICAgKVxuICAgICkiLCJ7ZGl2LCBpLCBzcGFuLCBpbnB1dH0gPSBSZWFjdC5ET01cblxuRHJvcGRvd24gPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vZHJvcGRvd24tdmlldydcbntUcmlhbmdsZU9ubHlBbmNob3J9ID0gcmVxdWlyZSBcIi4vZHJvcGRvd24tYW5jaG9yc1wiXG50ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnTWVudUJhcidcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IC0+XG4gICAgIyBuZWVkIHRvIHVzZSBkaXJlY3QgRE9NIGV2ZW50cyBiZWNhdXNlIHRoZSBldmVudCBuZWVkcyB0byBiZSBjYXB0dXJlZFxuICAgIGlmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAnbW91c2Vkb3duJywgQGNoZWNrQmx1ciwgdHJ1ZVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ3RvdWNoc3RhcnQnLCBAY2hlY2tCbHVyLCB0cnVlXG5cbiAgICBAcHJvcHMuY2xpZW50Ll91aS5saXN0ZW4gKGV2ZW50KSA9PlxuICAgICAgc3dpdGNoIGV2ZW50LnR5cGVcbiAgICAgICAgd2hlbiAnZWRpdEluaXRpYWxGaWxlbmFtZSdcbiAgICAgICAgICBAc2V0U3RhdGVcbiAgICAgICAgICAgIGVkaXRpbmdGaWxlbmFtZTogdHJ1ZVxuICAgICAgICAgICAgZWRpdGluZ0luaXRpYWxGaWxlbmFtZTogdHJ1ZVxuICAgICAgICAgIHNldFRpbWVvdXQgKD0+IEBmb2N1c0ZpbGVuYW1lKCkpLCAxMFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIGlmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciAnbW91c2Vkb3duJywgQGNoZWNrQmx1ciwgdHJ1ZVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ3RvdWNoc3RhcnQnLCBAY2hlY2tCbHVyLCB0cnVlXG5cbiAgZ2V0RmlsZW5hbWU6IChwcm9wcykgLT5cbiAgICBpZiBwcm9wcy5maWxlbmFtZT8ubGVuZ3RoID4gMCB0aGVuIHByb3BzLmZpbGVuYW1lIGVsc2UgKHRyIFwifk1FTlVCQVIuVU5USVRMRURfRE9DVU1FTlRcIilcblxuICBnZXRFZGl0YWJsZUZpbGVuYW1lOiAocHJvcHMpIC0+XG4gICAgaWYgcHJvcHMuZmlsZW5hbWU/Lmxlbmd0aCA+IDAgdGhlbiBwcm9wcy5maWxlbmFtZSBlbHNlICh0ciBcIn5NRU5VQkFSLlVOVElUTEVEX0RPQ1VNRU5UXCIpXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIHN0YXRlID1cbiAgICAgIGVkaXRpbmdGaWxlbmFtZTogZmFsc2VcbiAgICAgIGZpbGVuYW1lOiBAZ2V0RmlsZW5hbWUgQHByb3BzXG4gICAgICBlZGl0YWJsZUZpbGVuYW1lOiBAZ2V0RWRpdGFibGVGaWxlbmFtZSBAcHJvcHNcbiAgICAgIGluaXRpYWxFZGl0YWJsZUZpbGVuYW1lOiBAZ2V0RWRpdGFibGVGaWxlbmFtZSBAcHJvcHNcbiAgICAgIGVkaXRpbmdJbml0aWFsRmlsZW5hbWU6IGZhbHNlXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogKG5leHRQcm9wcykgLT5cbiAgICBAc2V0U3RhdGVcbiAgICAgIGZpbGVuYW1lOiBAZ2V0RmlsZW5hbWUgbmV4dFByb3BzXG4gICAgICBlZGl0YWJsZUZpbGVuYW1lOiBAZ2V0RWRpdGFibGVGaWxlbmFtZSBuZXh0UHJvcHNcbiAgICAgIHByb3ZpZGVyOiBuZXh0UHJvcHMucHJvdmlkZXJcblxuICBmaWxlbmFtZUNsaWNrZWQ6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBAc2V0U3RhdGVcbiAgICAgIGVkaXRpbmdGaWxlbmFtZTogdHJ1ZVxuICAgICAgZWRpdGluZ0luaXRpYWxGaWxlbmFtZTogZmFsc2VcbiAgICBzZXRUaW1lb3V0ICg9PiBAZm9jdXNGaWxlbmFtZSgpKSwgMTBcblxuICBmaWxlbmFtZUNoYW5nZWQ6IC0+XG4gICAgQHNldFN0YXRlXG4gICAgICBlZGl0YWJsZUZpbGVuYW1lOiBAZmlsZW5hbWUoKS52YWx1ZVxuXG4gIGZpbGVuYW1lQmx1cnJlZDogLT5cbiAgICBAcmVuYW1lKClcblxuICBmaWxlbmFtZTogLT5cbiAgICBSZWFjdERPTS5maW5kRE9NTm9kZShAcmVmcy5maWxlbmFtZSlcblxuICBmb2N1c0ZpbGVuYW1lOiAtPlxuICAgIGVsID0gQGZpbGVuYW1lKClcbiAgICBlbC5mb2N1cygpXG4gICAgZWwuc2VsZWN0KClcblxuICBjYW5jZWxFZGl0OiAtPlxuICAgIEBzZXRTdGF0ZVxuICAgICAgZWRpdGluZ0ZpbGVuYW1lOiBmYWxzZVxuICAgICAgZWRpdGFibGVGaWxlbmFtZTogaWYgQHN0YXRlLmZpbGVuYW1lPy5sZW5ndGggPiAwIHRoZW4gQHN0YXRlLmZpbGVuYW1lIGVsc2UgQHN0YXRlLmluaXRpYWxFZGl0YWJsZUZpbGVuYW1lXG5cbiAgcmVuYW1lOiAtPlxuICAgIGZpbGVuYW1lID0gQHN0YXRlLmVkaXRhYmxlRmlsZW5hbWUucmVwbGFjZSAvXlxccyt8XFxzKyQvLCAnJ1xuICAgIGlmIGZpbGVuYW1lLmxlbmd0aCA+IDBcbiAgICAgIGlmIEBzdGF0ZS5lZGl0aW5nSW5pdGlhbEZpbGVuYW1lXG4gICAgICAgIEBwcm9wcy5jbGllbnQuc2V0SW5pdGlhbEZpbGVuYW1lIGZpbGVuYW1lXG4gICAgICBlbHNlXG4gICAgICAgIEBwcm9wcy5jbGllbnQucmVuYW1lIEBwcm9wcy5jbGllbnQuc3RhdGUubWV0YWRhdGEsIGZpbGVuYW1lXG4gICAgICBAc2V0U3RhdGVcbiAgICAgICAgZWRpdGluZ0ZpbGVuYW1lOiBmYWxzZVxuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgICAgZWRpdGFibGVGaWxlbmFtZTogZmlsZW5hbWVcbiAgICBlbHNlXG4gICAgICBAY2FuY2VsRWRpdCgpXG5cbiAgd2F0Y2hGb3JFbnRlcjogKGUpIC0+XG4gICAgaWYgZS5rZXlDb2RlIGlzIDEzXG4gICAgICBAcmVuYW1lKClcbiAgICBlbHNlIGlmIGUua2V5Q29kZSBpcyAyN1xuICAgICAgQGNhbmNlbEVkaXQoKVxuXG4gIGhlbHA6IC0+XG4gICAgd2luZG93Lm9wZW4gQHByb3BzLm9wdGlvbnMuaGVscCwgJ19ibGFuaydcblxuICBpbmZvQ2xpY2tlZDogLT5cbiAgICBAcHJvcHMub3B0aW9ucy5vbkluZm9DbGlja2VkPyhAcHJvcHMuY2xpZW50KVxuXG4gICMgQ09EQVAgZWF0cyB0aGUgY2xpY2sgZXZlbnRzIGluIHRoZSBtYWluIHdvcmtzcGFjZSB3aGljaCBjYXVzZXMgdGhlIGJsdXIgZXZlbnQgbm90IHRvIGZpcmUgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYSBub24tYnViYmxpbmcgZ2xvYmFsIGNsaWNrIGV2ZW50IHdoZW4gZWRpdGluZ1xuICBjaGVja0JsdXI6IChlKSAtPlxuICAgIEBmaWxlbmFtZUJsdXJyZWQoKSBpZiBAc3RhdGUuZWRpdGluZ0ZpbGVuYW1lIGFuZCBlLnRhcmdldCBpc250IEBmaWxlbmFtZSgpXG5cbiAgbGFuZ0NoYW5nZWQ6IChsYW5nQ29kZSkgLT5cbiAgICB7Y2xpZW50LCBvcHRpb25zfSA9IEBwcm9wc1xuICAgIHtvbkxhbmdDaGFuZ2VkfSA9IG9wdGlvbnMubGFuZ3VhZ2VNZW51XG4gICAgaWYgb25MYW5nQ2hhbmdlZD9cbiAgICAgIGNsaWVudC5jaGFuZ2VMYW5ndWFnZSBsYW5nQ29kZSwgb25MYW5nQ2hhbmdlZFxuXG4gIHJlbmRlckxhbmd1YWdlTWVudTogLT5cbiAgICBsYW5nTWVudSA9IEBwcm9wcy5vcHRpb25zLmxhbmd1YWdlTWVudVxuICAgIGl0ZW1zID0gbGFuZ01lbnUub3B0aW9uc1xuICAgICAgIyBEbyBub3Qgc2hvdyBjdXJyZW50IGxhbmd1YWdlIGluIHRoZSBtZW51LlxuICAgICAgLmZpbHRlcigob3B0aW9uKSAtPiBvcHRpb24ubGFuZ0NvZGUgaXNudCBsYW5nTWVudS5jdXJyZW50TGFuZylcbiAgICAgIC5tYXAoKG9wdGlvbikgPT5cbiAgICAgICAgbGFiZWwgPSBvcHRpb24ubGFiZWwgb3Igb3B0aW9uLmxhbmdDb2RlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgY2xhc3NOYW1lID0gXCJmbGFnIGZsYWctI3tvcHRpb24uZmxhZ31cIiBpZiBvcHRpb24uZmxhZ1xuICAgICAgICB7XG4gICAgICAgICAgY29udGVudDogKHNwYW4ge2NsYXNzTmFtZTogJ2xhbmctb3B0aW9uJ30sIChkaXYge2NsYXNzTmFtZX0pLCBsYWJlbClcbiAgICAgICAgICBhY3Rpb246ID0+IEBsYW5nQ2hhbmdlZChvcHRpb24ubGFuZ0NvZGUpXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgIGhhc0ZsYWdzID0gbGFuZ01lbnUub3B0aW9ucy5maWx0ZXIoKG9wdGlvbikgLT4gb3B0aW9uLmZsYWc/KS5sZW5ndGggPiAwXG4gICAgY3VycmVudE9wdGlvbiA9IGxhbmdNZW51Lm9wdGlvbnMuZmlsdGVyKChvcHRpb24pIC0+IG9wdGlvbi5sYW5nQ29kZSBpcyBsYW5nTWVudS5jdXJyZW50TGFuZylbMF1cbiAgICBkZWZhdWx0T3B0aW9uID0gaWYgaGFzRmxhZ3MgdGhlbiB7ZmxhZzogXCJ1c1wifSBlbHNlIHtsYWJlbDogXCJFbmdsaXNoXCJ9XG4gICAge2ZsYWcsIGxhYmVsfSA9IGN1cnJlbnRPcHRpb24gb3IgZGVmYXVsdE9wdGlvblxuICAgIG1lbnVBbmNob3IgPSBpZiBmbGFnXG4gICAgICAoZGl2IHtjbGFzc05hbWU6IFwiZmxhZyBmbGFnLSN7ZmxhZ31cIn0pXG4gICAgZWxzZVxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiBcImxhbmctbWVudSB3aXRoLWJvcmRlclwifSxcbiAgICAgICAgKHNwYW4ge2NsYXNzTmFtZTogXCJsYW5nLWxhYmVsXCJ9LCBsYWJlbCBvciBkZWZhdWx0T3B0aW9uLmxhYmVsKSxcbiAgICAgICAgVHJpYW5nbGVPbmx5QW5jaG9yXG4gICAgICApXG5cbiAgICAoRHJvcGRvd24ge1xuICAgICAgY2xhc3NOYW1lOiBcImxhbmctbWVudVwiLFxuICAgICAgbWVudUFuY2hvckNsYXNzTmFtZTogXCJtZW51LWFuY2hvci1yaWdodFwiLFxuICAgICAgaXRlbXMsXG4gICAgICBtZW51QW5jaG9yXG4gICAgfSlcblxuICByZW5kZXI6IC0+XG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnbWVudS1iYXInfSxcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ21lbnUtYmFyLWxlZnQnfSxcbiAgICAgICAgKERyb3Bkb3duIHtpdGVtczogQHByb3BzLml0ZW1zfSlcbiAgICAgICAgaWYgQHN0YXRlLmVkaXRpbmdGaWxlbmFtZVxuICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogJ21lbnUtYmFyLWNvbnRlbnQtZmlsZW5hbWUnfSxcbiAgICAgICAgICAgIChpbnB1dCB7cmVmOiAnZmlsZW5hbWUnLCB2YWx1ZTogQHN0YXRlLmVkaXRhYmxlRmlsZW5hbWUsIG9uQ2hhbmdlOiBAZmlsZW5hbWVDaGFuZ2VkLCBvbktleURvd246IEB3YXRjaEZvckVudGVyfSlcbiAgICAgICAgICApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdtZW51LWJhci1jb250ZW50LWZpbGVuYW1lJywgb25DbGljazogQGZpbGVuYW1lQ2xpY2tlZH0sIEBzdGF0ZS5maWxlbmFtZSlcbiAgICAgICAgaWYgQHByb3BzLmZpbGVTdGF0dXNcbiAgICAgICAgICAoc3BhbiB7Y2xhc3NOYW1lOiBcIm1lbnUtYmFyLWZpbGUtc3RhdHVzLSN7QHByb3BzLmZpbGVTdGF0dXMudHlwZX1cIn0sIEBwcm9wcy5maWxlU3RhdHVzLm1lc3NhZ2UpXG4gICAgICApXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdtZW51LWJhci1yaWdodCd9LFxuICAgICAgICBpZiBAcHJvcHMub3B0aW9ucy5pbmZvXG4gICAgICAgICAgKHNwYW4ge2NsYXNzTmFtZTogJ21lbnUtYmFyLWluZm8nLCBvbkNsaWNrOiBAaW5mb0NsaWNrZWR9LCBAcHJvcHMub3B0aW9ucy5pbmZvKVxuICAgICAgICBpZiBAcHJvcHMucHJvdmlkZXI/LmF1dGhvcml6ZWQoKVxuICAgICAgICAgIEBwcm9wcy5wcm92aWRlci5yZW5kZXJVc2VyKClcbiAgICAgICAgaWYgQHByb3BzLm9wdGlvbnMuaGVscFxuICAgICAgICAgIChpIHtzdHlsZToge2ZvbnRTaXplOiBcIjEzcHhcIn0sIGNsYXNzTmFtZTogJ2NsaWNrYWJsZSBpY29uLWhlbHAnLCBvbkNsaWNrOiBAaGVscH0pXG4gICAgICAgIGlmIEBwcm9wcy5vcHRpb25zLmxhbmd1YWdlTWVudVxuICAgICAgICAgIEByZW5kZXJMYW5ndWFnZU1lbnUoKVxuICAgICAgKVxuICAgIClcbiIsIk1vZGFsID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL21vZGFsLXZpZXcnXG57ZGl2LCBpfSA9IFJlYWN0LkRPTVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZGlzcGxheU5hbWU6ICdNb2RhbERpYWxvZydcblxuICBjbG9zZTogLT5cbiAgICBAcHJvcHMuY2xvc2U/KClcblxuICByZW5kZXI6IC0+XG4gICAgKE1vZGFsIHtjbG9zZTogQGNsb3NlLCB6SW5kZXg6IEBwcm9wcy56SW5kZXh9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nJ30sXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ21vZGFsLWRpYWxvZy13cmFwcGVyJ30sXG4gICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nLXRpdGxlJ30sXG4gICAgICAgICAgICAoaSB7Y2xhc3NOYW1lOiBcIm1vZGFsLWRpYWxvZy10aXRsZS1jbG9zZSBpY29uLWV4XCIsIG9uQ2xpY2s6IEBjbG9zZX0pXG4gICAgICAgICAgICBAcHJvcHMudGl0bGUgb3IgJ1VudGl0bGVkIERpYWxvZydcbiAgICAgICAgICApXG4gICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwtZGlhbG9nLXdvcmtzcGFjZSd9LCBAcHJvcHMuY2hpbGRyZW4pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4iLCJNb2RhbERpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9tb2RhbC1kaWFsb2ctdmlldydcblRhYmJlZFBhbmVsID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL3RhYmJlZC1wYW5lbC12aWV3J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZGlzcGxheU5hbWU6ICdNb2RhbFRhYmJlZERpYWxvZ1ZpZXcnXG5cbiAgcmVuZGVyOiAtPlxuICAgIChNb2RhbERpYWxvZyB7dGl0bGU6IEBwcm9wcy50aXRsZSwgY2xvc2U6IEBwcm9wcy5jbG9zZX0sXG4gICAgICAoVGFiYmVkUGFuZWwge3RhYnM6IEBwcm9wcy50YWJzLCBzZWxlY3RlZFRhYkluZGV4OiBAcHJvcHMuc2VsZWN0ZWRUYWJJbmRleH0pXG4gICAgKVxuIiwie2Rpdn0gPSBSZWFjdC5ET01cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnTW9kYWwnXG5cbiAgd2F0Y2hGb3JFc2NhcGU6IChlKSAtPlxuICAgIGlmIGUua2V5Q29kZSBpcyAyN1xuICAgICAgQHByb3BzLmNsb3NlPygpXG5cbiAgIyBzaGFkb3cgdGhlIGVudGlyZSB2aWV3cG9ydCBiZWhpbmQgdGhlIGRpYWxvZ1xuICBnZXREaW1lbnNpb25zOiAtPlxuICAgIHdpZHRoOiAnMTAwdncnXG4gICAgaGVpZ2h0OiAnMTAwdmgnXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGRpbWVuc2lvbnMgPSBAZ2V0RGltZW5zaW9ucygpXG4gICAgaW5pdGlhbFN0YXRlID1cbiAgICAgIGJhY2tncm91bmRTdHlsZTogQGdldEJhY2tncm91bmRTdHlsZSBkaW1lbnNpb25zXG4gICAgICBjb250ZW50U3R5bGU6IEBnZXRDb250ZW50U3R5bGUgZGltZW5zaW9uc1xuXG4gIGdldEJhY2tncm91bmRTdHlsZTogKGRpbWVuc2lvbnMpIC0+XG4gICAgaWYgQHByb3BzLnpJbmRleFxuICAgICAgeyB6SW5kZXg6IEBwcm9wcy56SW5kZXgsIHdpZHRoOiBkaW1lbnNpb25zLndpZHRoLCBoZWlnaHQ6IGRpbWVuc2lvbnMuaGVpZ2h0IH1cbiAgICBlbHNlXG4gICAgICBkaW1lbnNpb25zXG5cbiAgZ2V0Q29udGVudFN0eWxlOiAoZGltZW5zaW9ucykgLT5cbiAgICBpZiBAcHJvcHMuekluZGV4XG4gICAgICB7IHpJbmRleDogQHByb3BzLnpJbmRleCArIDEsIHdpZHRoOiBkaW1lbnNpb25zLndpZHRoLCBoZWlnaHQ6IGRpbWVuc2lvbnMuaGVpZ2h0IH1cbiAgICBlbHNlXG4gICAgICBkaW1lbnNpb25zXG5cbiAgdXBkYXRlU3R5bGVzOiAtPlxuICAgIGRpbWVuc2lvbnMgPSBAZ2V0RGltZW5zaW9ucygpXG4gICAgQHNldFN0YXRlXG4gICAgICBiYWNrZ3JvdW5kU3R5bGU6IEBnZXRCYWNrZ3JvdW5kU3R5bGUgZGltZW5zaW9uc1xuICAgICAgY29udGVudFN0eWxlOiBAZ2V0Q29udGVudFN0eWxlIGRpbWVuc2lvbnNcblxuICAjIHVzZSBiaW5kL3VuYmluZCBmb3IgY2xpZW50cyB1c2luZyBvbGRlciB2ZXJzaW9ucyBvZiBqUXVlcnlcbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgJCh3aW5kb3cpLmJpbmQgJ2tleXVwJywgQHdhdGNoRm9yRXNjYXBlXG4gICAgJCh3aW5kb3cpLmJpbmQgJ3Jlc2l6ZScsIEB1cGRhdGVTdHlsZXNcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICAkKHdpbmRvdykudW5iaW5kICdrZXl1cCcsIEB3YXRjaEZvckVzY2FwZVxuICAgICQod2luZG93KS51bmJpbmQgJ3Jlc2l6ZScsIEB1cGRhdGVTdHlsZXNcblxuICByZW5kZXI6IC0+XG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnbW9kYWwnfSxcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ21vZGFsLWJhY2tncm91bmQnLCBzdHlsZTogQHN0YXRlLmJhY2tncm91bmRTdHlsZX0pXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdtb2RhbC1jb250ZW50Jywgc3R5bGU6IEBzdGF0ZS5jb250ZW50U3R5bGV9LCBAcHJvcHMuY2hpbGRyZW4pXG4gICAgKVxuIiwiTW9kYWxUYWJiZWREaWFsb2cgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IHJlcXVpcmUgJy4vbW9kYWwtdGFiYmVkLWRpYWxvZy12aWV3J1xuVGFiYmVkUGFuZWwgPSByZXF1aXJlICcuL3RhYmJlZC1wYW5lbC12aWV3J1xuQ2xvdWRNZXRhZGF0YSA9IChyZXF1aXJlICcuLi9wcm92aWRlcnMvcHJvdmlkZXItaW50ZXJmYWNlJykuQ2xvdWRNZXRhZGF0YVxuRmlsZURpYWxvZ1RhYiA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9maWxlLWRpYWxvZy10YWItdmlldydcblNlbGVjdFByb3ZpZGVyRGlhbG9nVGFiID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL3NlbGVjdC1wcm92aWRlci1kaWFsb2ctdGFiLXZpZXcnXG5cbnRyID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIGRpc3BsYXlOYW1lOiAnUHJvdmlkZXJUYWJiZWREaWFsb2cnXG5cbiAgcmVuZGVyOiAgLT5cbiAgICBbY2FwYWJpbGl0eSwgVGFiQ29tcG9uZW50XSA9IHN3aXRjaCBAcHJvcHMuZGlhbG9nLmFjdGlvblxuICAgICAgd2hlbiAnb3BlbkZpbGUnIHRoZW4gWydsaXN0JywgRmlsZURpYWxvZ1RhYl1cbiAgICAgIHdoZW4gJ3NhdmVGaWxlJywgJ3NhdmVGaWxlQXMnIHRoZW4gWydzYXZlJywgRmlsZURpYWxvZ1RhYl1cbiAgICAgIHdoZW4gJ3NhdmVTZWNvbmRhcnlGaWxlQXMnIHRoZW4gWydleHBvcnQnLCBGaWxlRGlhbG9nVGFiXVxuICAgICAgd2hlbiAnY3JlYXRlQ29weScgdGhlbiBbJ3NhdmUnLCBGaWxlRGlhbG9nVGFiXVxuICAgICAgd2hlbiAnc2VsZWN0UHJvdmlkZXInIHRoZW4gW251bGwsIFNlbGVjdFByb3ZpZGVyRGlhbG9nVGFiXVxuXG4gICAgdGFicyA9IFtdXG4gICAgc2VsZWN0ZWRUYWJJbmRleCA9IDBcbiAgICBmb3IgcHJvdmlkZXIsIGkgaW4gQHByb3BzLmNsaWVudC5zdGF0ZS5hdmFpbGFibGVQcm92aWRlcnNcbiAgICAgIGlmIG5vdCBjYXBhYmlsaXR5IG9yIHByb3ZpZGVyLmNhcGFiaWxpdGllc1tjYXBhYmlsaXR5XVxuICAgICAgICBmaWx0ZXJlZFRhYkNvbXBvbmVudCA9IHByb3ZpZGVyLmZpbHRlclRhYkNvbXBvbmVudCBjYXBhYmlsaXR5LCBUYWJDb21wb25lbnRcbiAgICAgICAgaWYgZmlsdGVyZWRUYWJDb21wb25lbnRcbiAgICAgICAgICBjb21wb25lbnQgPSBmaWx0ZXJlZFRhYkNvbXBvbmVudFxuICAgICAgICAgICAgY2xpZW50OiBAcHJvcHMuY2xpZW50XG4gICAgICAgICAgICBkaWFsb2c6IEBwcm9wcy5kaWFsb2dcbiAgICAgICAgICAgIGNsb3NlOiBAcHJvcHMuY2xvc2VcbiAgICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlclxuICAgICAgICAgIG9uU2VsZWN0ZWQgPSBpZiBwcm92aWRlci5vblByb3ZpZGVyVGFiU2VsZWN0ZWQgdGhlbiBwcm92aWRlci5vblByb3ZpZGVyVGFiU2VsZWN0ZWQuYmluZChwcm92aWRlcikgZWxzZSBudWxsXG4gICAgICAgICAgdGFicy5wdXNoIFRhYmJlZFBhbmVsLlRhYiB7a2V5OiBpLCBsYWJlbDogKHRyIHByb3ZpZGVyLmRpc3BsYXlOYW1lKSwgY29tcG9uZW50OiBjb21wb25lbnQsIGNhcGFiaWxpdHk6IGNhcGFiaWxpdHksIG9uU2VsZWN0ZWQ6IG9uU2VsZWN0ZWR9XG4gICAgICAgICAgaWYgcHJvdmlkZXIubmFtZSBpcyBAcHJvcHMuY2xpZW50LnN0YXRlLm1ldGFkYXRhPy5wcm92aWRlcj8ubmFtZVxuICAgICAgICAgICAgc2VsZWN0ZWRUYWJJbmRleCA9IHRhYnMubGVuZ3RoIC0gMVxuXG4gICAgKE1vZGFsVGFiYmVkRGlhbG9nIHt0aXRsZTogKHRyIEBwcm9wcy5kaWFsb2cudGl0bGUpLCBjbG9zZTogQHByb3BzLmNsb3NlLCB0YWJzOiB0YWJzLCBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4fSlcbiIsIntkaXYsIGlucHV0LCBhLCBidXR0b259ID0gUmVhY3QuRE9NXG5cbk1vZGFsRGlhbG9nID0gUmVhY3QuY3JlYXRlRmFjdG9yeSByZXF1aXJlICcuL21vZGFsLWRpYWxvZy12aWV3J1xuXG50ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnUmVuYW1lRGlhbG9nVmlldydcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZmlsZW5hbWUgPSBAcHJvcHMuZmlsZW5hbWUgb3IgJydcbiAgICBzdGF0ZSA9XG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgIHRyaW1tZWRGaWxlbmFtZTogQHRyaW0gZmlsZW5hbWVcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBAZmlsZW5hbWUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSBAcmVmcy5maWxlbmFtZVxuICAgIEBmaWxlbmFtZS5mb2N1cygpXG5cbiAgdXBkYXRlRmlsZW5hbWU6IC0+XG4gICAgZmlsZW5hbWUgPSBAZmlsZW5hbWUudmFsdWVcbiAgICBAc2V0U3RhdGVcbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgdHJpbW1lZEZpbGVuYW1lOiBAdHJpbSBmaWxlbmFtZVxuXG4gIHRyaW06IChzKSAtPlxuICAgIHMucmVwbGFjZSAvXlxccyt8XFxzKyQvLCAnJ1xuXG4gIHJlbmFtZTogKGUpIC0+XG4gICAgaWYgQHN0YXRlLnRyaW1tZWRGaWxlbmFtZS5sZW5ndGggPiAwXG4gICAgICBAcHJvcHMuY2FsbGJhY2s/IEBzdGF0ZS5maWxlbmFtZVxuICAgICAgQHByb3BzLmNsb3NlKClcbiAgICBlbHNlXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIEBmaWxlbmFtZS5mb2N1cygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIChNb2RhbERpYWxvZyB7dGl0bGU6ICh0ciAnfkRJQUxPRy5SRU5BTUUnKSwgY2xvc2U6IEBwcm9wcy5jbG9zZX0sXG4gICAgICAoZGl2IHtjbGFzc05hbWU6ICdyZW5hbWUtZGlhbG9nJ30sXG4gICAgICAgIChpbnB1dCB7cmVmOiAnZmlsZW5hbWUnLCBwbGFjZWhvbGRlcjogJ0ZpbGVuYW1lJywgdmFsdWU6IEBzdGF0ZS5maWxlbmFtZSwgb25DaGFuZ2U6IEB1cGRhdGVGaWxlbmFtZX0pXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ2J1dHRvbnMnfSxcbiAgICAgICAgICAoYnV0dG9uIHtjbGFzc05hbWU6IChpZiBAc3RhdGUudHJpbW1lZEZpbGVuYW1lLmxlbmd0aCBpcyAwIHRoZW4gJ2Rpc2FibGVkJyBlbHNlICcnKSwgb25DbGljazogQHJlbmFtZX0sIHRyICd+UkVOQU1FX0RJQUxPRy5SRU5BTUUnKVxuICAgICAgICAgIChidXR0b24ge29uQ2xpY2s6IEBwcm9wcy5jbG9zZX0sIHRyICd+UkVOQU1FX0RJQUxPRy5DQU5DRUwnKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwie2Rpdn0gPSBSZWFjdC5ET01cblxuU2VsZWN0UHJvdmlkZXJEaWFsb2dUYWIgPSBSZWFjdC5jcmVhdGVGYWN0b3J5IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIGRpc3BsYXlOYW1lOiAnU2VsZWN0UHJvdmlkZXJEaWFsb2dUYWInXG4gIHJlbmRlcjogLT4gKGRpdiB7fSwgXCJUT0RPOiBTZWxlY3RQcm92aWRlckRpYWxvZ1RhYjogI3tAcHJvcHMucHJvdmlkZXIuZGlzcGxheU5hbWV9XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0UHJvdmlkZXJEaWFsb2dUYWJcbiIsIntkaXYsIGlucHV0LCBhLCBidXR0b24sIHN0cm9uZywgdGV4dGFyZWEsIHN2ZywgZywgcGF0aCwgc3BhbiwgY2lyY2xlLCB1bCwgbGl9ID0gUmVhY3QuRE9NXG5cblNIT1dfTE9OR0VWSVRZX1dBUk5JTkcgPSBmYWxzZVxuXG5Nb2RhbERpYWxvZyA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgcmVxdWlyZSAnLi9tb2RhbC1kaWFsb2ctdmlldydcbmdldFF1ZXJ5UGFyYW0gPSByZXF1aXJlICcuLi91dGlscy9nZXQtcXVlcnktcGFyYW0nXG5cbiMgVGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBcInRyXCIgZWxzZXdoZXJlIGluIHRoaXMgY29kZWxpbmUuXG4jIFVzaW5nIHRoZSBmdWxsbmFtZSwgXCJ0cmFuc2xhdGVcIiBoZXJlLCB0byBhdm9pZCB0aGUgcG90ZW50aWFsIG92ZXJsb2FkaW5nXG4jIG9mIHRoZSByZWFjdCBmdW5jdGlvbiwgXCJ0clwiLlxudHJhbnNsYXRlID0gcmVxdWlyZSAnLi4vdXRpbHMvdHJhbnNsYXRlJ1xuc29jaWFsSWNvbnMgPSByZXF1aXJlICdzdmctc29jaWFsLWljb25zL2xpYi9pY29ucy5qc29uJ1xuXG5Tb2NpYWxJY29uID0gUmVhY3QuY3JlYXRlRmFjdG9yeSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnU29jaWFsSWNvbidcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZGF0YTogc29jaWFsSWNvbnNbQHByb3BzLmljb25dXG5cbiAgY2xpY2tlZDogLT5cbiAgICB3aW5kb3cub3BlbiBAcHJvcHMudXJsXG5cbiAgcmVuZGVyOiAtPlxuICAgIChhIHtjbGFzc05hbWU6ICdzb2NpYWwtaWNvbicsIGhyZWY6IEBwcm9wcy51cmwsIHRhcmdldDogJ19ibGFuayd9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnc29jaWFsLWNvbnRhaW5lcid9LFxuICAgICAgICAoc3ZnIHtjbGFzc05hbWU6ICdzb2NpYWwtc3ZnJywgdmlld0JveDogJzAgMCA2NCA2NCd9LFxuICAgICAgICAgIChnIHtjbGFzc05hbWU6ICdzb2NpYWwtc3ZnLWJhY2tncm91bmQnfSxcbiAgICAgICAgICAgIChjaXJjbGUge2N4OiAzMiwgY3k6IDMyLCByOiAzMX0pXG4gICAgICAgICAgKVxuICAgICAgICAgIChnIHtjbGFzc05hbWU6ICdzb2NpYWwtc3ZnLWljb24nfSxcbiAgICAgICAgICAgIChwYXRoIHtkOiBAc3RhdGUuZGF0YS5pY29ufSlcbiAgICAgICAgICApXG4gICAgICAgICAgKGcge2NsYXNzTmFtZTogJ3NvY2lhbC1zdmctbWFzaycsIHN0eWxlOiB7ZmlsbDogQHN0YXRlLmRhdGEuY29sb3J9fSxcbiAgICAgICAgICAgIChwYXRoIHtkOiBAc3RhdGUuZGF0YS5tYXNrfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ1NoYXJlRGlhbG9nVmlldydcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgbGluazogQGdldFNoYXJlTGluaygpXG4gICAgZW1iZWQ6IEBnZXRFbWJlZCgpXG4gICAgcGFnZVR5cGU6IFwiYXV0b2xhdW5jaFwiXG4gICAgc2VydmVyVXJsOiBAcHJvcHMuc2V0dGluZ3Muc2VydmVyVXJsIG9yIFwiaHR0cHM6Ly9jb2RhcC5jb25jb3JkLm9yZy9yZWxlYXNlcy9sYXRlc3QvXCJcbiAgICBzZXJ2ZXJVcmxMYWJlbDogQHByb3BzLnNldHRpbmdzLnNlcnZlclVybExhYmVsIG9yIHRyYW5zbGF0ZShcIn5TSEFSRV9ESUFMT0cuTEFSQV9DT0RBUF9VUkxcIilcbiAgICBsYXVuY2hCdXR0b25UZXh0OiBcIkxhdW5jaFwiXG4gICAgZnVsbHNjcmVlblNjYWxpbmc6IHRydWVcbiAgICBncmFwaFZpc1RvZ2dsZXM6IGZhbHNlXG4gICAgdGFiU2VsZWN0ZWQ6ICdsaW5rJ1xuXG4gIGdldFNoYXJlZERvY3VtZW50SWQ6IC0+XG4gICAgIyBleHRyYWN0IHNoYXJlZERvY3VtZW50SWQgZnJvbSBDbG91ZENvbnRlbnRcbiAgICBpZiBAcHJvcHMuY2xpZW50LmlzU2hhcmVkKClcbiAgICAgIEBwcm9wcy5jbGllbnQuc3RhdGUuY3VycmVudENvbnRlbnQ/LmdldCBcInNoYXJlZERvY3VtZW50SWRcIlxuICAgIGVsc2VcbiAgICAgIG51bGxcblxuICBnZXRTaGFyZUxpbms6IC0+XG4gICAgc2hhcmVkRG9jdW1lbnRJZCA9IEBnZXRTaGFyZWREb2N1bWVudElkKClcbiAgICBpZiBzaGFyZWREb2N1bWVudElkXG4gICAgICAjIHNoYXJlIGxpbmsgY29tYmluZXMgZG9jdW1lbnQgVVJMIHdpdGggc2hhcmVkRG9jdW1lbnRJZFxuICAgICAgXCIje0Bwcm9wcy5jbGllbnQuZ2V0Q3VycmVudFVybCgpfSNzaGFyZWQ9I3tzaGFyZWREb2N1bWVudElkfVwiXG4gICAgZWxzZVxuICAgICAgbnVsbFxuXG4gIGdldEVtYmVkOiAtPlxuICAgIGlmIEBnZXRTaGFyZUxpbmsoKVxuICAgICAgXCJcIlwiPGlmcmFtZSB3aWR0aD1cIjM5OHB4XCIgaGVpZ2h0PVwiMzEzcHhcIiBmcmFtZWJvcmRlcj1cIm5vXCIgc2Nyb2xsaW5nPVwibm9cIiBhbGxvd2Z1bGxzY3JlZW49XCJ0cnVlXCIgd2Via2l0YWxsb3dmdWxsc2NyZWVuPVwidHJ1ZVwiIG1vemFsbG93ZnVsbHNjcmVlbj1cInRydWVcIiBzcmM9XCIje0BnZXRTaGFyZUxpbmsoKX1cIj48L2lmcmFtZT5cIlwiXCJcbiAgICBlbHNlXG4gICAgICBudWxsXG5cbiAgZ2V0TGFyYTogLT5cbiAgICBzaGFyZWREb2N1bWVudElkID0gQGdldFNoYXJlZERvY3VtZW50SWQoKVxuICAgIGlmIHNoYXJlZERvY3VtZW50SWRcbiAgICAgIGRvY3VtZW50U2VydmVyID0gZ2V0UXVlcnlQYXJhbSgnZG9jdW1lbnRTZXJ2ZXInKSBvciAnaHR0cHM6Ly9kb2N1bWVudC1zdG9yZS5jb25jb3JkLm9yZydcbiAgICAgIGRvY3VtZW50U2VydmVyID0gZG9jdW1lbnRTZXJ2ZXIuc2xpY2UoMCwgLTEpIHdoaWxlIGRvY3VtZW50U2VydmVyLnN1YnN0cigtMSkgaXMgJy8nICAjIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgZ3JhcGhWaXNUb2dnbGVzID0gaWYgQHN0YXRlLmdyYXBoVmlzVG9nZ2xlcyB0aGVuICc/YXBwPWlzJyBlbHNlICcnXG4gICAgICAjIGdyYXBoVmlzVG9nZ2xlcyBpcyBhIHBhcmFtZXRlciBoYW5kbGVkIGJ5IENPREFQLCBzbyBpdCBuZWVkcyB0byBiZSBhZGRlZCB0byBpdHMgVVJMLlxuICAgICAgc2VydmVyID0gZW5jb2RlVVJJQ29tcG9uZW50KEBzdGF0ZS5zZXJ2ZXJVcmwgKyBncmFwaFZpc1RvZ2dsZXMpXG4gICAgICAjIE90aGVyIHBhcmFtcyBhcmUgaGFuZGxlZCBieSBkb2N1bWVudCBzZXJ2ZXIgaXRzZWxmOlxuICAgICAgYnV0dG9uVGV4dCA9IGlmIEBzdGF0ZS5wYWdlVHlwZSBpcyAnbGF1bmNoJyB0aGVuIFwiJmJ1dHRvblRleHQ9I3tlbmNvZGVVUklDb21wb25lbnQoQHN0YXRlLmxhdW5jaEJ1dHRvblRleHQpfVwiIGVsc2UgJydcbiAgICAgIGZ1bGxzY3JlZW5TY2FsaW5nID0gaWYgQHN0YXRlLnBhZ2VUeXBlIGlzICdhdXRvbGF1bmNoJyBhbmQgQHN0YXRlLmZ1bGxzY3JlZW5TY2FsaW5nIHRoZW4gJyZzY2FsaW5nJyBlbHNlICcnXG4gICAgICBcIiN7ZG9jdW1lbnRTZXJ2ZXJ9L3YyL2RvY3VtZW50cy8je3NoYXJlZERvY3VtZW50SWR9LyN7QHN0YXRlLnBhZ2VUeXBlfT9zZXJ2ZXI9I3tzZXJ2ZXJ9I3tidXR0b25UZXh0fSN7ZnVsbHNjcmVlblNjYWxpbmd9XCJcbiAgICBlbHNlXG4gICAgICBudWxsXG5cbiAgIyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3N1ZG9kb2tpL2NvcHktdG8tY2xpcGJvYXJkL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIGNvcHk6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNvcGllZCA9IGZhbHNlXG4gICAgdG9Db3B5ID0gc3dpdGNoIEBzdGF0ZS50YWJTZWxlY3RlZFxuICAgICAgd2hlbiAnZW1iZWQnIHRoZW4gQGdldEVtYmVkKClcbiAgICAgIHdoZW4gJ2xpbmsnIHRoZW4gQGdldFNoYXJlTGluaygpXG4gICAgICB3aGVuICdsYXJhJyB0aGVuIEBnZXRMYXJhKClcbiAgICB0cnlcbiAgICAgIG1hcmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICdtYXJrJ1xuICAgICAgbWFyay50ZXh0Q29udGVudCA9IHRvQ29weVxuICAgICAgIyByZXNldCB1c2VyIHN0eWxlcyBmb3Igc3BhbiBlbGVtZW50XG4gICAgICBtYXJrLnN0eWxlLmFsbCA9ICd1bnNldCdcbiAgICAgICMgcHJldmVudHMgc2Nyb2xsaW5nIHRvIHRoZSBlbmQgb2YgdGhlIHBhZ2VcbiAgICAgIG1hcmsuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgICBtYXJrLnN0eWxlLnRvcCA9IDBcbiAgICAgIG1hcmsuc3R5bGUuY2xpcCA9ICdyZWN0KDAsIDAsIDAsIDApJ1xuICAgICAgIyB1c2VkIHRvIHByZXNlcnZlIHNwYWNlcyBhbmQgbGluZSBicmVha3NcbiAgICAgIG1hcmsuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnXG4gICAgICAjIGRvIG5vdCBpbmhlcml0IHVzZXItc2VsZWN0IChpdCBtYXkgYmUgYG5vbmVgKVxuICAgICAgbWFyay5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ3RleHQnXG4gICAgICBtYXJrLnN0eWxlLk1velVzZXJTZWxlY3QgPSAndGV4dCdcbiAgICAgIG1hcmsuc3R5bGUubXNVc2VyU2VsZWN0ID0gJ3RleHQnXG4gICAgICBtYXJrLnN0eWxlLnVzZXJTZWxlY3QgPSAndGV4dCdcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQgbWFya1xuXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKVxuICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpXG5cbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZSBtYXJrXG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UgcmFuZ2VcblxuICAgICAgY29waWVkID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQgJ2NvcHknXG4gICAgY2F0Y2hcbiAgICAgIHRyeVxuICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhICd0ZXh0JywgdG9Db3B5XG4gICAgICAgIGNvcGllZCA9IHRydWVcbiAgICAgIGNhdGNoXG4gICAgICAgIGNvcGllZCA9IGZhbHNlXG4gICAgZmluYWxseVxuICAgICAgaWYgc2VsZWN0aW9uXG4gICAgICAgIGlmIHR5cGVvZiBzZWxlY3Rpb24ucmVtb3ZlUmFuZ2UgaXMgJ2Z1bmN0aW9uJ1xuICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVSYW5nZSByYW5nZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpXG4gICAgICBpZiBtYXJrXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQgbWFya1xuICAgICAgQHByb3BzLmNsaWVudC5hbGVydCB0cmFuc2xhdGUoaWYgY29waWVkIHRoZW4gXCJ+U0hBUkVfRElBTE9HLkNPUFlfU1VDQ0VTU1wiIGVsc2UgXCJ+U0hBUkVfRElBTE9HLkNPUFlfRVJST1JcIiksICh0cmFuc2xhdGUgXCJ+U0hBUkVfRElBTE9HLkNPUFlfVElUTEVcIilcblxuICB1cGRhdGVTaGFyZTogLT5cbiAgICBAcHJvcHMuY2xpZW50LnNoYXJlVXBkYXRlKClcblxuICB0b2dnbGVTaGFyZTogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgQHByb3BzLmNsaWVudC50b2dnbGVTaGFyZSA9PlxuICAgICAgQHNldFN0YXRlXG4gICAgICAgIGxpbms6IEBnZXRTaGFyZUxpbmsoKVxuICAgICAgICBlbWJlZDogQGdldEVtYmVkKClcblxuICBzZWxlY3RMaW5rVGFiOiAtPlxuICAgIEBzZXRTdGF0ZSB0YWJTZWxlY3RlZDogJ2xpbmsnXG5cbiAgc2VsZWN0RW1iZWRUYWI6IC0+XG4gICAgQHNldFN0YXRlIHRhYlNlbGVjdGVkOiAnZW1iZWQnXG5cbiAgc2VsZWN0TGFyYVRhYjogLT5cbiAgICBAc2V0U3RhdGUgdGFiU2VsZWN0ZWQ6ICdsYXJhJ1xuXG4gIGNoYW5nZWRTZXJ2ZXJVcmw6IChldmVudCkgLT5cbiAgICBAc2V0U3RhdGVcbiAgICAgIHNlcnZlclVybDogZXZlbnQudGFyZ2V0LnZhbHVlXG5cbiAgY2hhbmdlZExhdW5jaEJ1dHRvblRleHQ6IChldmVudCkgLT5cbiAgICBAc2V0U3RhdGVcbiAgICAgIGxhdW5jaEJ1dHRvblRleHQ6IGV2ZW50LnRhcmdldC52YWx1ZVxuXG4gIGNoYW5nZWRBdXRvc2NhbGluZ1BhZ2U6IChldmVudCkgLT5cbiAgICBAc2V0U3RhdGVcbiAgICAgIHBhZ2VUeXBlOiBpZiBldmVudC50YXJnZXQuY2hlY2tlZCB0aGVuICdhdXRvbGF1bmNoJyBlbHNlICdsYXVuY2gnXG5cbiAgY2hhbmdlZEZ1bGxzY3JlZW5TY2FsaW5nOiAoZXZlbnQpIC0+XG4gICAgQHNldFN0YXRlXG4gICAgICBmdWxsc2NyZWVuU2NhbGluZzogZXZlbnQudGFyZ2V0LmNoZWNrZWRcblxuICBjaGFuZ2VkR3JhcGhWaXNUb2dnbGVzOiAoZXZlbnQpIC0+XG4gICAgQHNldFN0YXRlXG4gICAgICBncmFwaFZpc1RvZ2dsZXM6IGV2ZW50LnRhcmdldC5jaGVja2VkXG5cbiAgcmVuZGVyOiAtPlxuICAgIHNoYXJpbmcgPSBAc3RhdGUubGluayBpc250IG51bGxcblxuICAgIChNb2RhbERpYWxvZyB7dGl0bGU6ICh0cmFuc2xhdGUgJ35ESUFMT0cuU0hBUkVEJyksIGNsb3NlOiBAcHJvcHMuY2xvc2V9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnc2hhcmUtZGlhbG9nJ30sXG4gICAgICAgIChkaXYge2NsYXNzTmFtZTogJ3NoYXJlLXRvcC1kaWFsb2cnfSxcbiAgICAgICAgICBpZiBzaGFyaW5nXG4gICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdzaGFyZS1zdGF0dXMnfSxcbiAgICAgICAgICAgICAgICAodHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURVwiKSwgKHN0cm9uZyB7fSwgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9FTkFCTEVEXCIpXG4gICAgICAgICAgICAgICAgKGEge2hyZWY6ICcjJywgb25DbGljazogQHRvZ2dsZVNoYXJlfSwgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5TVE9QX1NIQVJJTkdcIilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdzaGFyZS1idXR0b24nfSxcbiAgICAgICAgICAgICAgICAoYnV0dG9uIHtvbkNsaWNrOiBAdXBkYXRlU2hhcmV9LCB0cmFuc2xhdGUgXCJ+U0hBUkVfRElBTE9HLlVQREFURV9TSEFSSU5HXCIpXG4gICAgICAgICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnc2hhcmUtYnV0dG9uLWhlbHAtc2hhcmluZyd9LFxuICAgICAgICAgICAgICAgICAgKGEge2hyZWY6IEBzdGF0ZS5saW5rLCB0YXJnZXQ6ICdfYmxhbmsnfSwgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5QUkVWSUVXX1NIQVJJTkdcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdzaGFyZS1zdGF0dXMnfSxcbiAgICAgICAgICAgICAgICAodHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURVwiKSwgKHN0cm9uZyB7fSwgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5TSEFSRV9TVEFURV9ESVNBQkxFRFwiKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogJ3NoYXJlLWJ1dHRvbid9LFxuICAgICAgICAgICAgICAgIChidXR0b24ge29uQ2xpY2s6IEB0b2dnbGVTaGFyZX0sIHRyYW5zbGF0ZSBcIn5TSEFSRV9ESUFMT0cuRU5BQkxFX1NIQVJJTkdcIilcbiAgICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdzaGFyZS1idXR0b24taGVscC1ub3Qtc2hhcmluZyd9LCB0cmFuc2xhdGUgXCJ+U0hBUkVfRElBTE9HLkVOQUJMRV9TSEFSSU5HX01FU1NBR0VcIilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIGlmIHNoYXJpbmdcbiAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgKHVsIHtjbGFzc05hbWU6ICdzaGFyaW5nLXRhYnMnfSxcbiAgICAgICAgICAgICAgKGxpIHtjbGFzc05hbWU6IFwic2hhcmluZy10YWIje2lmIEBzdGF0ZS50YWJTZWxlY3RlZCBpcyAnbGluaycgdGhlbiAnIHNoYXJpbmctdGFiLXNlbGVjdGVkJyBlbHNlICcnfVwiLCBzdHlsZToge21hcmdpbkxlZnQ6IDEwfSwgb25DbGljazogQHNlbGVjdExpbmtUYWJ9LCB0cmFuc2xhdGUgXCJ+U0hBUkVfRElBTE9HLkxJTktfVEFCXCIpXG4gICAgICAgICAgICAgIChsaSB7Y2xhc3NOYW1lOiBcInNoYXJpbmctdGFiIHNoYXJpbmctdGFiLWVtYmVkI3tpZiBAc3RhdGUudGFiU2VsZWN0ZWQgaXMgJ2VtYmVkJyB0aGVuICcgc2hhcmluZy10YWItc2VsZWN0ZWQnIGVsc2UgJyd9XCIsIG9uQ2xpY2s6IEBzZWxlY3RFbWJlZFRhYn0sIHRyYW5zbGF0ZSBcIn5TSEFSRV9ESUFMT0cuRU1CRURfVEFCXCIpXG4gICAgICAgICAgICAgIGlmIEBwcm9wcy5lbmFibGVMYXJhU2hhcmluZ1xuICAgICAgICAgICAgICAgIChsaSB7Y2xhc3NOYW1lOiBcInNoYXJpbmctdGFiIHNoYXJpbmctdGFiLWxhcmEje2lmIEBzdGF0ZS50YWJTZWxlY3RlZCBpcyAnbGFyYScgdGhlbiAnIHNoYXJpbmctdGFiLXNlbGVjdGVkJyBlbHNlICcnfVwiLCBvbkNsaWNrOiBAc2VsZWN0TGFyYVRhYn0sIFwiTEFSQVwiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnc2hhcmluZy10YWItY29udGVudHMnfSxcbiAgICAgICAgICAgICAgc3dpdGNoIEBzdGF0ZS50YWJTZWxlY3RlZFxuICAgICAgICAgICAgICAgIHdoZW4gJ2VtYmVkJ1xuICAgICAgICAgICAgICAgICAgKGRpdiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlKFwiflNIQVJFX0RJQUxPRy5FTUJFRF9NRVNTQUdFXCIpLFxuICAgICAgICAgICAgICAgICAgICBpZiBkb2N1bWVudC5leGVjQ29tbWFuZCBvciB3aW5kb3cuY2xpcGJvYXJkRGF0YVxuICAgICAgICAgICAgICAgICAgICAgIChhIHtjbGFzc05hbWU6ICdjb3B5LWxpbmsnLCBocmVmOiAnIycsIG9uQ2xpY2s6IEBjb3B5fSwgdHJhbnNsYXRlICd+U0hBUkVfRElBTE9HLkNPUFknKVxuICAgICAgICAgICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICh0ZXh0YXJlYSB7dmFsdWU6IEBzdGF0ZS5lbWJlZCwgcmVhZE9ubHk6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgd2hlbiAnbGFyYSdcbiAgICAgICAgICAgICAgICAgIChkaXYge30sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZShcIn5TSEFSRV9ESUFMT0cuTEFSQV9NRVNTQUdFXCIpLFxuICAgICAgICAgICAgICAgICAgICBpZiBkb2N1bWVudC5leGVjQ29tbWFuZCBvciB3aW5kb3cuY2xpcGJvYXJkRGF0YVxuICAgICAgICAgICAgICAgICAgICAgIChhIHtjbGFzc05hbWU6ICdjb3B5LWxpbmsnLCBocmVmOiAnIycsIG9uQ2xpY2s6IEBjb3B5fSwgdHJhbnNsYXRlICd+U0hBUkVfRElBTE9HLkNPUFknKVxuICAgICAgICAgICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIChpbnB1dCB7dmFsdWU6IEBnZXRMYXJhKCksIHJlYWRPbmx5OiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdsYXJhLXNldHRpbmdzJ30sXG4gICAgICAgICAgICAgICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnY29kYXAtc2VydmVyLXVybCd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQHN0YXRlLnNlcnZlclVybExhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQge3ZhbHVlOiBAc3RhdGUuc2VydmVyVXJsLCBvbkNoYW5nZTogQGNoYW5nZWRTZXJ2ZXJVcmx9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdhdXRvbGF1bmNoJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQge3R5cGU6ICdjaGVja2JveCcsIGNoZWNrZWQ6IEBzdGF0ZS5wYWdlVHlwZSBpcyAnYXV0b2xhdW5jaCcsIG9uQ2hhbmdlOiBAY2hhbmdlZEF1dG9zY2FsaW5nUGFnZX0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgXCJ+U0hBUkVfRElBTE9HLkxBUkFfQVVUT0xBVU5DSF9QQUdFXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgaWYgQHN0YXRlLnBhZ2VUeXBlIGlzICdhdXRvbGF1bmNoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKGRpdiB7Y2xhc3NOYW1lOiAnZnVsbHNjZWVuLXNjYWxpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0IHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiBAc3RhdGUuZnVsbHNjcmVlblNjYWxpbmcsIG9uQ2hhbmdlOiBAY2hhbmdlZEZ1bGxzY3JlZW5TY2FsaW5nfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5MQVJBX0ZVTExTQ1JFRU5fQlVUVE9OX0FORF9TQ0FMSU5HXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBpZiBAc3RhdGUucGFnZVR5cGUgaXMgJ2xhdW5jaCdcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogJ2xhdW5jaC1idXR0b24tdGV4dCd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUoXCJ+U0hBUkVfRElBTE9HLkxBUkFfTEFVTkNIX0JVVFRPTl9URVhUXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dCB7dmFsdWU6IEBzdGF0ZS5sYXVuY2hCdXR0b25UZXh0LCBvbkNoYW5nZTogQGNoYW5nZWRMYXVuY2hCdXR0b25UZXh0fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0IHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiBAc3RhdGUuZ3JhcGhWaXNUb2dnbGVzLCBvbkNoYW5nZTogQGNoYW5nZWRHcmFwaFZpc1RvZ2dsZXN9KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlIFwiflNIQVJFX0RJQUxPRy5MQVJBX0RJU1BMQVlfVklTSUJJTElUWV9UT0dHTEVTXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAoZGl2IHt9LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUoXCJ+U0hBUkVfRElBTE9HLkxJTktfTUVTU0FHRVwiKSxcbiAgICAgICAgICAgICAgICAgICAgaWYgZG9jdW1lbnQuZXhlY0NvbW1hbmQgb3Igd2luZG93LmNsaXBib2FyZERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAoYSB7Y2xhc3NOYW1lOiAnY29weS1saW5rJywgaHJlZjogJyMnLCBvbkNsaWNrOiBAY29weX0sIHRyYW5zbGF0ZSAnflNIQVJFX0RJQUxPRy5DT1BZJylcbiAgICAgICAgICAgICAgICAgICAgKGRpdiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQge3ZhbHVlOiBAc3RhdGUubGluaywgcmVhZE9ubHk6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIChkaXYge2NsYXNzTmFtZTogJ3NvY2lhbC1pY29ucyd9LFxuICAgICAgICAgICAgICAgICAgICAgIChTb2NpYWxJY29uIHtpY29uOiAnZmFjZWJvb2snLCB1cmw6IFwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci9zaGFyZXIucGhwP3U9I3tlbmNvZGVVUklDb21wb25lbnQgQHN0YXRlLmxpbmt9XCJ9KVxuICAgICAgICAgICAgICAgICAgICAgIChTb2NpYWxJY29uIHtpY29uOiAndHdpdHRlcicsIHVybDogXCJodHRwczovL3R3aXR0ZXIuY29tL2hvbWU/c3RhdHVzPSN7ZW5jb2RlVVJJQ29tcG9uZW50IEBzdGF0ZS5saW5rfVwifSlcbiAgICAgICAgICAgICAgICAgICAgICAjIG5vdCB3b3JraW5nIHdpdGggdXJsIHBhcmFtZXRlcjogKFNvY2lhbEljb24ge2ljb246ICdnb29nbGUnLCB1cmw6IFwiaHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20vc2hhcmU/dXJsPSN7ZW5jb2RlVVJJQ29tcG9uZW50IEBzdGF0ZS5saW5rfVwifSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcblxuICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdidXR0b25zJ30sXG4gICAgICAgICAgKGJ1dHRvbiB7b25DbGljazogQHByb3BzLmNsb3NlfSwgdHJhbnNsYXRlICd+U0hBUkVfRElBTE9HLkNMT1NFJylcbiAgICAgICAgKVxuICAgICAgICAoZGl2IHtjbGFzc05hbWU6ICdsb25nZXZpdHktd2FybmluZyd9LCB0cmFuc2xhdGUgJ35TSEFSRV9ESUFMT0cuTE9OR0VWSVRZX1dBUk5JTkcnKSBpZiBTSE9XX0xPTkdFVklUWV9XQVJOSU5HXG4gICAgICApXG4gICAgKVxuIiwie2RpdiwgdWwsIGxpLCBhfSA9IFJlYWN0LkRPTVxuXG5jbGFzcyBUYWJJbmZvXG4gIGNvbnN0cnVjdG9yOiAoc2V0dGluZ3M9e30pIC0+XG4gICAge0BsYWJlbCwgQGNvbXBvbmVudCwgQGNhcGFiaWxpdHksIEBvblNlbGVjdGVkfSA9IHNldHRpbmdzXG5cblRhYiA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkgUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ1RhYmJlZFBhbmVsVGFiJ1xuXG4gIGNsaWNrZWQ6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIEBwcm9wcy5vblNlbGVjdGVkIEBwcm9wcy5pbmRleFxuXG4gIHJlbmRlcjogLT5cbiAgICBjbGFzc25hbWUgPSBpZiBAcHJvcHMuc2VsZWN0ZWQgdGhlbiAndGFiLXNlbGVjdGVkJyBlbHNlICcnXG4gICAgKGxpIHtjbGFzc05hbWU6IGNsYXNzbmFtZSwgb25DbGljazogQGNsaWNrZWR9LCBAcHJvcHMubGFiZWwpXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBkaXNwbGF5TmFtZTogJ1RhYmJlZFBhbmVsVmlldydcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgc2VsZWN0ZWRUYWJJbmRleDogQHByb3BzLnNlbGVjdGVkVGFiSW5kZXggb3IgMFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIEBwcm9wcy50YWJzW0BzdGF0ZS5zZWxlY3RlZFRhYkluZGV4XS5vblNlbGVjdGVkPyhAcHJvcHMudGFic1tAc3RhdGUuc2VsZWN0ZWRUYWJJbmRleF0uY2FwYWJpbGl0eSlcblxuICBzdGF0aWNzOlxuICAgIFRhYjogKHNldHRpbmdzKSAtPiBuZXcgVGFiSW5mbyBzZXR0aW5nc1xuXG4gIHNlbGVjdGVkVGFiOiAoaW5kZXgpIC0+XG4gICAgQHByb3BzLnRhYnNbaW5kZXhdLm9uU2VsZWN0ZWQ/KEBwcm9wcy50YWJzW2luZGV4XS5jYXBhYmlsaXR5KVxuICAgIEBzZXRTdGF0ZSBzZWxlY3RlZFRhYkluZGV4OiBpbmRleFxuXG4gIHJlbmRlclRhYjogKHRhYiwgaW5kZXgpIC0+XG4gICAgKFRhYlxuICAgICAgbGFiZWw6IHRhYi5sYWJlbFxuICAgICAga2V5OiBpbmRleFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgICBzZWxlY3RlZDogKGluZGV4IGlzIEBzdGF0ZS5zZWxlY3RlZFRhYkluZGV4KVxuICAgICAgb25TZWxlY3RlZDogQHNlbGVjdGVkVGFiXG4gICAgKVxuXG4gIHJlbmRlclRhYnM6IC0+XG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnd29ya3NwYWNlLXRhYnMnfSxcbiAgICAgICh1bCB7a2V5OiBpbmRleH0sIEByZW5kZXJUYWIodGFiLCBpbmRleCkgZm9yIHRhYiwgaW5kZXggaW4gQHByb3BzLnRhYnMpXG4gICAgKVxuXG4gIHJlbmRlclNlbGVjdGVkUGFuZWw6IC0+XG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnd29ya3NwYWNlLXRhYi1jb21wb25lbnQnfSxcbiAgICAgIGZvciB0YWIsIGluZGV4IGluIEBwcm9wcy50YWJzXG4gICAgICAgIChkaXYge1xuICAgICAgICAgIGtleTogaW5kZXhcbiAgICAgICAgICBzdHlsZTpcbiAgICAgICAgICAgIGRpc3BsYXk6IGlmIGluZGV4IGlzIEBzdGF0ZS5zZWxlY3RlZFRhYkluZGV4IHRoZW4gJ2Jsb2NrJyBlbHNlICdub25lJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFiLmNvbXBvbmVudFxuICAgICAgICApXG4gICAgKVxuXG4gIHJlbmRlcjogLT5cbiAgICAoZGl2IHtjbGFzc05hbWU6IFwidGFiYmVkLXBhbmVsXCJ9LFxuICAgICAgQHJlbmRlclRhYnMoKVxuICAgICAgQHJlbmRlclNlbGVjdGVkUGFuZWwoKVxuICAgIClcbiIsIntkaXYsIGlucHV0LCBidXR0b259ID0gUmVhY3QuRE9NXG50ciA9IHJlcXVpcmUgJy4uL3V0aWxzL3RyYW5zbGF0ZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGRpc3BsYXlOYW1lOiAnVXJsVGFiJ1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBob3ZlcjogZmFsc2VcblxuICBpbXBvcnRVcmw6ICh1cmwsIHZpYSkgLT5cbiAgICBAcHJvcHMuZGlhbG9nLmNhbGxiYWNrPyB1cmwsIHZpYVxuICAgIEBwcm9wcy5jbG9zZSgpXG5cbiAgaW1wb3J0OiAtPlxuICAgIHVybCA9ICQudHJpbSBSZWFjdERPTS5maW5kRE9NTm9kZShAcmVmcy51cmwpLnZhbHVlXG4gICAgaWYgdXJsLmxlbmd0aCBpcyAwXG4gICAgICBAcHJvcHMuY2xpZW50LmFsZXJ0IHRyIFwifklNUE9SVF9VUkwuUExFQVNFX0VOVEVSX1VSTFwiXG4gICAgZWxzZVxuICAgICAgQGltcG9ydFVybCB1cmwsICdzZWxlY3QnXG5cbiAgY2FuY2VsOiAtPlxuICAgIEBwcm9wcy5jbG9zZSgpXG5cbiAgZHJhZ0VudGVyOiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBAc2V0U3RhdGUgaG92ZXI6IHRydWVcblxuICBkcmFnTGVhdmU6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIEBzZXRTdGF0ZSBob3ZlcjogZmFsc2VcblxuICBkcm9wOiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBpZiBlLmRhdGFUcmFuc2ZlclxuICAgICAgZHJvcHBlZFVybHMgPSAoZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJykgb3IgZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC91cmktbGlzdCcpIG9yICcnKS5zcGxpdCAnXFxuJ1xuICAgICAgaWYgZHJvcHBlZFVybHMubGVuZ3RoID4gMVxuICAgICAgICBAcHJvcHMuY2xpZW50LmFsZXJ0IHRyIFwifklNUE9SVF9VUkwuTVVMVElQTEVfVVJMU19EUk9QUEVEXCJcbiAgICAgIGVsc2UgaWYgZHJvcHBlZFVybHMubGVuZ3RoIGlzIDFcbiAgICAgICAgQGltcG9ydFVybCBkcm9wcGVkVXJsc1swXSwgJ2Ryb3AnXG5cbiAgcmVuZGVyOiAtPlxuICAgIGRyb3BDbGFzcyA9IFwidXJsRHJvcEFyZWEje2lmIEBzdGF0ZS5ob3ZlciB0aGVuICcgZHJvcEhvdmVyJyBlbHNlICcnfVwiXG4gICAgKGRpdiB7Y2xhc3NOYW1lOiAnZGlhbG9nVGFiIHVybEltcG9ydCd9LFxuICAgICAgKGRpdiB7Y2xhc3NOYW1lOiBkcm9wQ2xhc3MsIG9uRHJhZ0VudGVyOiBAZHJhZ0VudGVyLCBvbkRyYWdMZWF2ZTogQGRyYWdMZWF2ZSwgb25Ecm9wOiBAZHJvcH0sXG4gICAgICAgICh0ciBcIn5VUkxfVEFCLkRST1BfVVJMX0hFUkVcIilcbiAgICAgIClcbiAgICAgIChpbnB1dCB7cmVmOiAndXJsJywgcGxhY2Vob2xkZXI6ICdVUkwnfSlcbiAgICAgIChkaXYge2NsYXNzTmFtZTogJ2J1dHRvbnMnfSxcbiAgICAgICAgKGJ1dHRvbiB7b25DbGljazogQGltcG9ydH0sICh0ciBcIn5VUkxfVEFCLklNUE9SVFwiKSlcbiAgICAgICAgKGJ1dHRvbiB7b25DbGljazogQGNhbmNlbH0sICh0ciBcIn5GSUxFX0RJQUxPRy5DQU5DRUxcIikpXG4gICAgICApXG4gICAgKVxuIl19
